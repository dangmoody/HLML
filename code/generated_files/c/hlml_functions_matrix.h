/*
===========================================================================

HLML.

MIT License

Copyright (c) 2019 Dan Moody

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===========================================================================
*/

// THIS FILE WAS AUTOMATICALLY GENERATED BY A TOOL.
// EDITING THIS FILE MAY CAUSE SIDE EFFECTS.
// DO SO AT YOUR OWN RISK.

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "bool2x2.h"
#include "bool2x3.h"
#include "bool2x4.h"
#include "bool3x2.h"
#include "bool3x3.h"
#include "bool3x4.h"
#include "bool4x2.h"
#include "bool4x3.h"
#include "bool4x4.h"
#include "int2x2.h"
#include "int2x3.h"
#include "int2x4.h"
#include "int3x2.h"
#include "int3x3.h"
#include "int3x4.h"
#include "int4x2.h"
#include "int4x3.h"
#include "int4x4.h"
#include "uint2x2.h"
#include "uint2x3.h"
#include "uint2x4.h"
#include "uint3x2.h"
#include "uint3x3.h"
#include "uint3x4.h"
#include "uint4x2.h"
#include "uint4x3.h"
#include "uint4x4.h"
#include "float2x2.h"
#include "float2x3.h"
#include "float2x4.h"
#include "float3x2.h"
#include "float3x3.h"
#include "float3x4.h"
#include "float4x2.h"
#include "float4x3.h"
#include "float4x4.h"
#include "double2x2.h"
#include "double2x3.h"
#include "double2x4.h"
#include "double3x2.h"
#include "double3x3.h"
#include "double3x4.h"
#include "double4x2.h"
#include "double4x3.h"
#include "double4x4.h"

#include "hlml_functions_vector.h"

// bool2x2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool2x2_equals( const bool2x2* lhs, const bool2x2* rhs )
{
	return
		bool2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		bool2_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool2x2_not_equals( const bool2x2* lhs, const bool2x2* rhs )
{
	return !bool2x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x2 bool2x2_less_than( const bool2x2* lhs, const bool2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		bool2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		bool2_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 bool2x2_less_than_equal( const bool2x2* lhs, const bool2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		bool2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool2_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x2 bool2x2_greater_than( const bool2x2* lhs, const bool2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		bool2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		bool2_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 bool2x2_greater_than_equal( const bool2x2* lhs, const bool2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		bool2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool2x2 bool2x2_cadds( const bool2x2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		bool2_cadds( &lhs->rows[0], rhs ),
		bool2_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool2x2 bool2x2_caddm( const bool2x2* lhs, const bool2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		bool2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		bool2_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool2x2 bool2x2_csubs( const bool2x2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		bool2_csubs( &lhs->rows[0], rhs ),
		bool2_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool2x2 bool2x2_csubm( const bool2x2* lhs, const bool2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		bool2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		bool2_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool2x2 bool2x2_cmuls( const bool2x2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		bool2_cmuls( &lhs->rows[0], rhs ),
		bool2_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool2x2 bool2x2_cmulm( const bool2x2* lhs, const bool2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		bool2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		bool2_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool2x2 bool2x2_cdivs( const bool2x2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		bool2_cdivs( &lhs->rows[0], rhs ),
		bool2_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool2x2 bool2x2_cdivm( const bool2x2* lhs, const bool2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		bool2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		bool2_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool bool2x2_all( const bool2x2* x )
{
	return
		bool2_all( &x->rows[0] ) &&
		bool2_all( &x->rows[1] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool bool2x2_any( const bool2x2* x )
{
	return
		bool2_any( &x->rows[0] ) ||
		bool2_any( &x->rows[1] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void bool2x2_identity( bool2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat->rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool2x2 bool2x2_transpose( const bool2x2* mat )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

// bool2x3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool2x3_equals( const bool2x3* lhs, const bool2x3* rhs )
{
	return
		bool3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		bool3_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool2x3_not_equals( const bool2x3* lhs, const bool2x3* rhs )
{
	return !bool2x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x3 bool2x3_less_than( const bool2x3* lhs, const bool2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		bool3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		bool3_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 bool2x3_less_than_equal( const bool2x3* lhs, const bool2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		bool3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool3_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x3 bool2x3_greater_than( const bool2x3* lhs, const bool2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		bool3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		bool3_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 bool2x3_greater_than_equal( const bool2x3* lhs, const bool2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		bool3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool2x3 bool2x3_cadds( const bool2x3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		bool3_cadds( &lhs->rows[0], rhs ),
		bool3_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool2x3 bool2x3_caddm( const bool2x3* lhs, const bool2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		bool3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		bool3_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool2x3 bool2x3_csubs( const bool2x3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		bool3_csubs( &lhs->rows[0], rhs ),
		bool3_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool2x3 bool2x3_csubm( const bool2x3* lhs, const bool2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		bool3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		bool3_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool2x3 bool2x3_cmuls( const bool2x3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		bool3_cmuls( &lhs->rows[0], rhs ),
		bool3_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool2x3 bool2x3_cmulm( const bool2x3* lhs, const bool2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		bool3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		bool3_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool2x3 bool2x3_cdivs( const bool2x3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		bool3_cdivs( &lhs->rows[0], rhs ),
		bool3_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool2x3 bool2x3_cdivm( const bool2x3* lhs, const bool2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		bool3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		bool3_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool bool2x3_all( const bool2x3* x )
{
	return
		bool3_all( &x->rows[0] ) &&
		bool3_all( &x->rows[1] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool bool2x3_any( const bool2x3* x )
{
	return
		bool3_any( &x->rows[0] ) ||
		bool3_any( &x->rows[1] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void bool2x3_identity( bool2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool3x2 bool2x3_transpose( const bool2x3* mat )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

// bool2x4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool2x4_equals( const bool2x4* lhs, const bool2x4* rhs )
{
	return
		bool4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		bool4_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool2x4_not_equals( const bool2x4* lhs, const bool2x4* rhs )
{
	return !bool2x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x4 bool2x4_less_than( const bool2x4* lhs, const bool2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		bool4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		bool4_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 bool2x4_less_than_equal( const bool2x4* lhs, const bool2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		bool4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool4_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x4 bool2x4_greater_than( const bool2x4* lhs, const bool2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		bool4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		bool4_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 bool2x4_greater_than_equal( const bool2x4* lhs, const bool2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		bool4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool2x4 bool2x4_cadds( const bool2x4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		bool4_cadds( &lhs->rows[0], rhs ),
		bool4_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool2x4 bool2x4_caddm( const bool2x4* lhs, const bool2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		bool4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		bool4_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool2x4 bool2x4_csubs( const bool2x4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		bool4_csubs( &lhs->rows[0], rhs ),
		bool4_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool2x4 bool2x4_csubm( const bool2x4* lhs, const bool2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		bool4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		bool4_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool2x4 bool2x4_cmuls( const bool2x4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		bool4_cmuls( &lhs->rows[0], rhs ),
		bool4_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool2x4 bool2x4_cmulm( const bool2x4* lhs, const bool2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		bool4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		bool4_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool2x4 bool2x4_cdivs( const bool2x4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		bool4_cdivs( &lhs->rows[0], rhs ),
		bool4_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool2x4 bool2x4_cdivm( const bool2x4* lhs, const bool2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		bool4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		bool4_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool bool2x4_all( const bool2x4* x )
{
	return
		bool4_all( &x->rows[0] ) &&
		bool4_all( &x->rows[1] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool bool2x4_any( const bool2x4* x )
{
	return
		bool4_any( &x->rows[0] ) ||
		bool4_any( &x->rows[1] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void bool2x4_identity( bool2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool4x2 bool2x4_transpose( const bool2x4* mat )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

// bool3x2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool3x2_equals( const bool3x2* lhs, const bool3x2* rhs )
{
	return
		bool2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		bool2_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		bool2_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool3x2_not_equals( const bool3x2* lhs, const bool3x2* rhs )
{
	return !bool3x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x2 bool3x2_less_than( const bool3x2* lhs, const bool3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		bool2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		bool2_less_than( &lhs->rows[1], &rhs->rows[1] ),
		bool2_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 bool3x2_less_than_equal( const bool3x2* lhs, const bool3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		bool2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool2_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		bool2_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x2 bool3x2_greater_than( const bool3x2* lhs, const bool3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		bool2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		bool2_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		bool2_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 bool3x2_greater_than_equal( const bool3x2* lhs, const bool3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		bool2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		bool2_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool3x2 bool3x2_cadds( const bool3x2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		bool2_cadds( &lhs->rows[0], rhs ),
		bool2_cadds( &lhs->rows[1], rhs ),
		bool2_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool3x2 bool3x2_caddm( const bool3x2* lhs, const bool3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		bool2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		bool2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		bool2_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool3x2 bool3x2_csubs( const bool3x2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		bool2_csubs( &lhs->rows[0], rhs ),
		bool2_csubs( &lhs->rows[1], rhs ),
		bool2_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool3x2 bool3x2_csubm( const bool3x2* lhs, const bool3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		bool2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		bool2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		bool2_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool3x2 bool3x2_cmuls( const bool3x2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		bool2_cmuls( &lhs->rows[0], rhs ),
		bool2_cmuls( &lhs->rows[1], rhs ),
		bool2_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool3x2 bool3x2_cmulm( const bool3x2* lhs, const bool3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		bool2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		bool2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		bool2_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool3x2 bool3x2_cdivs( const bool3x2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		bool2_cdivs( &lhs->rows[0], rhs ),
		bool2_cdivs( &lhs->rows[1], rhs ),
		bool2_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool3x2 bool3x2_cdivm( const bool3x2* lhs, const bool3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		bool2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		bool2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		bool2_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool bool3x2_all( const bool3x2* x )
{
	return
		bool2_all( &x->rows[0] ) &&
		bool2_all( &x->rows[1] ) &&
		bool2_all( &x->rows[2] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool bool3x2_any( const bool3x2* x )
{
	return
		bool2_any( &x->rows[0] ) ||
		bool2_any( &x->rows[1] ) ||
		bool2_any( &x->rows[2] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void bool3x2_identity( bool3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat->rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
	mat->rows[2] = HLML_CONSTRUCT( bool2 ) { false, false };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool2x3 bool3x2_transpose( const bool3x2* mat )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

// bool3x3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool3x3_equals( const bool3x3* lhs, const bool3x3* rhs )
{
	return
		bool3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		bool3_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		bool3_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool3x3_not_equals( const bool3x3* lhs, const bool3x3* rhs )
{
	return !bool3x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x3 bool3x3_less_than( const bool3x3* lhs, const bool3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		bool3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		bool3_less_than( &lhs->rows[1], &rhs->rows[1] ),
		bool3_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 bool3x3_less_than_equal( const bool3x3* lhs, const bool3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		bool3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool3_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		bool3_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x3 bool3x3_greater_than( const bool3x3* lhs, const bool3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		bool3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		bool3_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		bool3_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 bool3x3_greater_than_equal( const bool3x3* lhs, const bool3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		bool3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		bool3_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool3x3 bool3x3_cadds( const bool3x3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		bool3_cadds( &lhs->rows[0], rhs ),
		bool3_cadds( &lhs->rows[1], rhs ),
		bool3_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool3x3 bool3x3_caddm( const bool3x3* lhs, const bool3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		bool3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		bool3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		bool3_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool3x3 bool3x3_csubs( const bool3x3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		bool3_csubs( &lhs->rows[0], rhs ),
		bool3_csubs( &lhs->rows[1], rhs ),
		bool3_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool3x3 bool3x3_csubm( const bool3x3* lhs, const bool3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		bool3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		bool3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		bool3_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool3x3 bool3x3_cmuls( const bool3x3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		bool3_cmuls( &lhs->rows[0], rhs ),
		bool3_cmuls( &lhs->rows[1], rhs ),
		bool3_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool3x3 bool3x3_cmulm( const bool3x3* lhs, const bool3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		bool3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		bool3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		bool3_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool3x3 bool3x3_cdivs( const bool3x3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		bool3_cdivs( &lhs->rows[0], rhs ),
		bool3_cdivs( &lhs->rows[1], rhs ),
		bool3_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool3x3 bool3x3_cdivm( const bool3x3* lhs, const bool3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		bool3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		bool3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		bool3_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool bool3x3_all( const bool3x3* x )
{
	return
		bool3_all( &x->rows[0] ) &&
		bool3_all( &x->rows[1] ) &&
		bool3_all( &x->rows[2] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool bool3x3_any( const bool3x3* x )
{
	return
		bool3_any( &x->rows[0] ) ||
		bool3_any( &x->rows[1] ) ||
		bool3_any( &x->rows[2] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void bool3x3_identity( bool3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
	mat->rows[2] = HLML_CONSTRUCT( bool3 ) { false, false, true };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool3x3 bool3x3_transpose( const bool3x3* mat )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

// bool3x4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool3x4_equals( const bool3x4* lhs, const bool3x4* rhs )
{
	return
		bool4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		bool4_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		bool4_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool3x4_not_equals( const bool3x4* lhs, const bool3x4* rhs )
{
	return !bool3x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x4 bool3x4_less_than( const bool3x4* lhs, const bool3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		bool4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		bool4_less_than( &lhs->rows[1], &rhs->rows[1] ),
		bool4_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 bool3x4_less_than_equal( const bool3x4* lhs, const bool3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		bool4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool4_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		bool4_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x4 bool3x4_greater_than( const bool3x4* lhs, const bool3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		bool4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		bool4_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		bool4_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 bool3x4_greater_than_equal( const bool3x4* lhs, const bool3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		bool4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		bool4_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool3x4 bool3x4_cadds( const bool3x4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		bool4_cadds( &lhs->rows[0], rhs ),
		bool4_cadds( &lhs->rows[1], rhs ),
		bool4_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool3x4 bool3x4_caddm( const bool3x4* lhs, const bool3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		bool4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		bool4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		bool4_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool3x4 bool3x4_csubs( const bool3x4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		bool4_csubs( &lhs->rows[0], rhs ),
		bool4_csubs( &lhs->rows[1], rhs ),
		bool4_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool3x4 bool3x4_csubm( const bool3x4* lhs, const bool3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		bool4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		bool4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		bool4_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool3x4 bool3x4_cmuls( const bool3x4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		bool4_cmuls( &lhs->rows[0], rhs ),
		bool4_cmuls( &lhs->rows[1], rhs ),
		bool4_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool3x4 bool3x4_cmulm( const bool3x4* lhs, const bool3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		bool4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		bool4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		bool4_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool3x4 bool3x4_cdivs( const bool3x4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		bool4_cdivs( &lhs->rows[0], rhs ),
		bool4_cdivs( &lhs->rows[1], rhs ),
		bool4_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool3x4 bool3x4_cdivm( const bool3x4* lhs, const bool3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		bool4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		bool4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		bool4_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool bool3x4_all( const bool3x4* x )
{
	return
		bool4_all( &x->rows[0] ) &&
		bool4_all( &x->rows[1] ) &&
		bool4_all( &x->rows[2] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool bool3x4_any( const bool3x4* x )
{
	return
		bool4_any( &x->rows[0] ) ||
		bool4_any( &x->rows[1] ) ||
		bool4_any( &x->rows[2] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void bool3x4_identity( bool3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
	mat->rows[2] = HLML_CONSTRUCT( bool4 ) { false, false, true, false };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool4x3 bool3x4_transpose( const bool3x4* mat )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

// bool4x2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool4x2_equals( const bool4x2* lhs, const bool4x2* rhs )
{
	return
		bool2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		bool2_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		bool2_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		bool2_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool4x2_not_equals( const bool4x2* lhs, const bool4x2* rhs )
{
	return !bool4x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x2 bool4x2_less_than( const bool4x2* lhs, const bool4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		bool2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		bool2_less_than( &lhs->rows[1], &rhs->rows[1] ),
		bool2_less_than( &lhs->rows[2], &rhs->rows[2] ),
		bool2_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 bool4x2_less_than_equal( const bool4x2* lhs, const bool4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		bool2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool2_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		bool2_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		bool2_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x2 bool4x2_greater_than( const bool4x2* lhs, const bool4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		bool2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		bool2_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		bool2_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		bool2_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 bool4x2_greater_than_equal( const bool4x2* lhs, const bool4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		bool2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		bool2_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		bool2_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool4x2 bool4x2_cadds( const bool4x2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		bool2_cadds( &lhs->rows[0], rhs ),
		bool2_cadds( &lhs->rows[1], rhs ),
		bool2_cadds( &lhs->rows[2], rhs ),
		bool2_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool4x2 bool4x2_caddm( const bool4x2* lhs, const bool4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		bool2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		bool2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		bool2_caddv( &lhs->rows[2], &rhs->rows[2] ),
		bool2_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool4x2 bool4x2_csubs( const bool4x2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		bool2_csubs( &lhs->rows[0], rhs ),
		bool2_csubs( &lhs->rows[1], rhs ),
		bool2_csubs( &lhs->rows[2], rhs ),
		bool2_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool4x2 bool4x2_csubm( const bool4x2* lhs, const bool4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		bool2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		bool2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		bool2_csubv( &lhs->rows[2], &rhs->rows[2] ),
		bool2_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool4x2 bool4x2_cmuls( const bool4x2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		bool2_cmuls( &lhs->rows[0], rhs ),
		bool2_cmuls( &lhs->rows[1], rhs ),
		bool2_cmuls( &lhs->rows[2], rhs ),
		bool2_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool4x2 bool4x2_cmulm( const bool4x2* lhs, const bool4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		bool2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		bool2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		bool2_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		bool2_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool4x2 bool4x2_cdivs( const bool4x2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		bool2_cdivs( &lhs->rows[0], rhs ),
		bool2_cdivs( &lhs->rows[1], rhs ),
		bool2_cdivs( &lhs->rows[2], rhs ),
		bool2_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool4x2 bool4x2_cdivm( const bool4x2* lhs, const bool4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		bool2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		bool2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		bool2_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		bool2_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool bool4x2_all( const bool4x2* x )
{
	return
		bool2_all( &x->rows[0] ) &&
		bool2_all( &x->rows[1] ) &&
		bool2_all( &x->rows[2] ) &&
		bool2_all( &x->rows[3] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool bool4x2_any( const bool4x2* x )
{
	return
		bool2_any( &x->rows[0] ) ||
		bool2_any( &x->rows[1] ) ||
		bool2_any( &x->rows[2] ) ||
		bool2_any( &x->rows[3] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void bool4x2_identity( bool4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat->rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
	mat->rows[2] = HLML_CONSTRUCT( bool2 ) { false, false };
	mat->rows[3] = HLML_CONSTRUCT( bool2 ) { false, false };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool2x4 bool4x2_transpose( const bool4x2* mat )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

// bool4x3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool4x3_equals( const bool4x3* lhs, const bool4x3* rhs )
{
	return
		bool3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		bool3_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		bool3_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		bool3_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool4x3_not_equals( const bool4x3* lhs, const bool4x3* rhs )
{
	return !bool4x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x3 bool4x3_less_than( const bool4x3* lhs, const bool4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		bool3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		bool3_less_than( &lhs->rows[1], &rhs->rows[1] ),
		bool3_less_than( &lhs->rows[2], &rhs->rows[2] ),
		bool3_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 bool4x3_less_than_equal( const bool4x3* lhs, const bool4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		bool3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool3_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		bool3_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		bool3_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x3 bool4x3_greater_than( const bool4x3* lhs, const bool4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		bool3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		bool3_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		bool3_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		bool3_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 bool4x3_greater_than_equal( const bool4x3* lhs, const bool4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		bool3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		bool3_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		bool3_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool4x3 bool4x3_cadds( const bool4x3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		bool3_cadds( &lhs->rows[0], rhs ),
		bool3_cadds( &lhs->rows[1], rhs ),
		bool3_cadds( &lhs->rows[2], rhs ),
		bool3_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool4x3 bool4x3_caddm( const bool4x3* lhs, const bool4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		bool3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		bool3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		bool3_caddv( &lhs->rows[2], &rhs->rows[2] ),
		bool3_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool4x3 bool4x3_csubs( const bool4x3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		bool3_csubs( &lhs->rows[0], rhs ),
		bool3_csubs( &lhs->rows[1], rhs ),
		bool3_csubs( &lhs->rows[2], rhs ),
		bool3_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool4x3 bool4x3_csubm( const bool4x3* lhs, const bool4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		bool3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		bool3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		bool3_csubv( &lhs->rows[2], &rhs->rows[2] ),
		bool3_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool4x3 bool4x3_cmuls( const bool4x3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		bool3_cmuls( &lhs->rows[0], rhs ),
		bool3_cmuls( &lhs->rows[1], rhs ),
		bool3_cmuls( &lhs->rows[2], rhs ),
		bool3_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool4x3 bool4x3_cmulm( const bool4x3* lhs, const bool4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		bool3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		bool3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		bool3_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		bool3_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool4x3 bool4x3_cdivs( const bool4x3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		bool3_cdivs( &lhs->rows[0], rhs ),
		bool3_cdivs( &lhs->rows[1], rhs ),
		bool3_cdivs( &lhs->rows[2], rhs ),
		bool3_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool4x3 bool4x3_cdivm( const bool4x3* lhs, const bool4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		bool3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		bool3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		bool3_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		bool3_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool bool4x3_all( const bool4x3* x )
{
	return
		bool3_all( &x->rows[0] ) &&
		bool3_all( &x->rows[1] ) &&
		bool3_all( &x->rows[2] ) &&
		bool3_all( &x->rows[3] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool bool4x3_any( const bool4x3* x )
{
	return
		bool3_any( &x->rows[0] ) ||
		bool3_any( &x->rows[1] ) ||
		bool3_any( &x->rows[2] ) ||
		bool3_any( &x->rows[3] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void bool4x3_identity( bool4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
	mat->rows[2] = HLML_CONSTRUCT( bool3 ) { false, false, true };
	mat->rows[3] = HLML_CONSTRUCT( bool3 ) { false, false, false };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool3x4 bool4x3_transpose( const bool4x3* mat )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

// bool4x4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool4x4_equals( const bool4x4* lhs, const bool4x4* rhs )
{
	return
		bool4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		bool4_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		bool4_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		bool4_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool4x4_not_equals( const bool4x4* lhs, const bool4x4* rhs )
{
	return !bool4x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x4 bool4x4_less_than( const bool4x4* lhs, const bool4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		bool4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		bool4_less_than( &lhs->rows[1], &rhs->rows[1] ),
		bool4_less_than( &lhs->rows[2], &rhs->rows[2] ),
		bool4_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 bool4x4_less_than_equal( const bool4x4* lhs, const bool4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		bool4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool4_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		bool4_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		bool4_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x4 bool4x4_greater_than( const bool4x4* lhs, const bool4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		bool4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		bool4_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		bool4_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		bool4_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 bool4x4_greater_than_equal( const bool4x4* lhs, const bool4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		bool4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		bool4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		bool4_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		bool4_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool4x4 bool4x4_cadds( const bool4x4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		bool4_cadds( &lhs->rows[0], rhs ),
		bool4_cadds( &lhs->rows[1], rhs ),
		bool4_cadds( &lhs->rows[2], rhs ),
		bool4_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool4x4 bool4x4_caddm( const bool4x4* lhs, const bool4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		bool4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		bool4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		bool4_caddv( &lhs->rows[2], &rhs->rows[2] ),
		bool4_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool4x4 bool4x4_csubs( const bool4x4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		bool4_csubs( &lhs->rows[0], rhs ),
		bool4_csubs( &lhs->rows[1], rhs ),
		bool4_csubs( &lhs->rows[2], rhs ),
		bool4_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool4x4 bool4x4_csubm( const bool4x4* lhs, const bool4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		bool4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		bool4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		bool4_csubv( &lhs->rows[2], &rhs->rows[2] ),
		bool4_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool4x4 bool4x4_cmuls( const bool4x4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		bool4_cmuls( &lhs->rows[0], rhs ),
		bool4_cmuls( &lhs->rows[1], rhs ),
		bool4_cmuls( &lhs->rows[2], rhs ),
		bool4_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool4x4 bool4x4_cmulm( const bool4x4* lhs, const bool4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		bool4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		bool4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		bool4_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		bool4_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool4x4 bool4x4_cdivs( const bool4x4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		bool4_cdivs( &lhs->rows[0], rhs ),
		bool4_cdivs( &lhs->rows[1], rhs ),
		bool4_cdivs( &lhs->rows[2], rhs ),
		bool4_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool4x4 bool4x4_cdivm( const bool4x4* lhs, const bool4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		bool4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		bool4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		bool4_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		bool4_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool bool4x4_all( const bool4x4* x )
{
	return
		bool4_all( &x->rows[0] ) &&
		bool4_all( &x->rows[1] ) &&
		bool4_all( &x->rows[2] ) &&
		bool4_all( &x->rows[3] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool bool4x4_any( const bool4x4* x )
{
	return
		bool4_any( &x->rows[0] ) ||
		bool4_any( &x->rows[1] ) ||
		bool4_any( &x->rows[2] ) ||
		bool4_any( &x->rows[3] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void bool4x4_identity( bool4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
	mat->rows[2] = HLML_CONSTRUCT( bool4 ) { false, false, true, false };
	mat->rows[3] = HLML_CONSTRUCT( bool4 ) { false, false, false, true };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool4x4 bool4x4_transpose( const bool4x4* mat )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

// int2x2
// Performs a int2x2_sign function on each row of the matrix.
HLML_INLINE int2x2 int2x2_sign( const int2x2* x )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_sign( &x->rows[0] ),
		int2_sign( &x->rows[1] )
	};
}

// Performs a int2x2_min function on each row of the matrix.
HLML_INLINE int2x2 int2x2_min( const int2x2* x, const int2x2* y )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_min( &x->rows[0], &y->rows[0] ),
		int2_min( &x->rows[1], &y->rows[1] )
	};
}

// Performs a int2x2_max function on each row of the matrix.
HLML_INLINE int2x2 int2x2_max( const int2x2* x, const int2x2* y )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_max( &x->rows[0], &y->rows[0] ),
		int2_max( &x->rows[1], &y->rows[1] )
	};
}

// Performs a int2x2_clamp function on each row of the matrix.
HLML_INLINE int2x2 int2x2_clamp( const int2x2* x, const int2x2* low, const int2x2* high )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		int2_clamp( &x->rows[1], &low->rows[1], &high->rows[1] )
	};
}

// Performs a int2x2_saturate function on each row of the matrix.
HLML_INLINE int2x2 int2x2_saturate( const int2x2* x )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_saturate( &x->rows[0] ),
		int2_saturate( &x->rows[1] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int2x2_equals( const int2x2* lhs, const int2x2* rhs )
{
	return
		int2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		int2_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int2x2_not_equals( const int2x2* lhs, const int2x2* rhs )
{
	return !int2x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x2 int2x2_less_than( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		int2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		int2_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 int2x2_less_than_equal( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		int2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int2_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x2 int2x2_greater_than( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		int2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		int2_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 int2x2_greater_than_equal( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		int2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 int2x2_cadds( const int2x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cadds( &lhs->rows[0], rhs ),
		int2_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int2x2 int2x2_caddm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int2_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 int2x2_csubs( const int2x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_csubs( &lhs->rows[0], rhs ),
		int2_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int2x2 int2x2_csubm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int2_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 int2x2_cmuls( const int2x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cmuls( &lhs->rows[0], rhs ),
		int2_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int2x2 int2x2_cmulm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 int2x2_cdivs( const int2x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cdivs( &lhs->rows[0], rhs ),
		int2_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int2x2 int2x2_cdivm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE int2x2 int2x2_negate( const int2x2* x )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_negate( &x->rows[0] ),
		int2_negate( &x->rows[1] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE int2x2 int2x2_not( const int2x2* x )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_not( &x->rows[0] ),
		int2_not( &x->rows[1] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 int2x2_cands( const int2x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cands( &lhs->rows[0], rhs ),
		int2_cands( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int2x2 int2x2_candm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_candv( &lhs->rows[0], &rhs->rows[0] ),
		int2_candv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 int2x2_cors( const int2x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cors( &lhs->rows[0], rhs ),
		int2_cors( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int2x2 int2x2_corm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_corv( &lhs->rows[0], &rhs->rows[0] ),
		int2_corv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 int2x2_cxors( const int2x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cxors( &lhs->rows[0], rhs ),
		int2_cxors( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int2x2 int2x2_cxorm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cxorv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 int2x2_cshift_lefts( const int2x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cshift_lefts( &lhs->rows[0], rhs ),
		int2_cshift_lefts( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int2x2 int2x2_cshift_leftm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cshift_leftv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 int2x2_cshift_rights( const int2x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cshift_rights( &lhs->rows[0], rhs ),
		int2_cshift_rights( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int2x2 int2x2_cshift_rightm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		int2_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cshift_rightv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void int2x2_identity( int2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int2x2 int2x2_transpose( const int2x2* mat )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

// Returns the determinant of the matrix.
HLML_INLINE int32_t int2x2_determinant( const int2x2* mat )
{
	return mat->rows[0].x * mat->rows[1].y - mat->rows[1].x * mat->rows[0].y;
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int2x2 int2x2_mulm( const int2x2* lhs, const int2x2* rhs )
{
	int2 row0 = lhs->rows[0];
	int2 row1 = lhs->rows[1];

	int2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	int2 col1 = { rhs->rows[0].y, rhs->rows[1].y };

	return HLML_CONSTRUCT( int2x2 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE int2 int2x2_mulv( const int2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		( lhs->x * rhs->rows[0].x ) + ( lhs->y * rhs->rows[1].x ),
		( lhs->x * rhs->rows[0].y ) + ( lhs->y * rhs->rows[1].y )
	};
}

// int2x3
// Performs a int2x3_sign function on each row of the matrix.
HLML_INLINE int2x3 int2x3_sign( const int2x3* x )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_sign( &x->rows[0] ),
		int3_sign( &x->rows[1] )
	};
}

// Performs a int2x3_min function on each row of the matrix.
HLML_INLINE int2x3 int2x3_min( const int2x3* x, const int2x3* y )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_min( &x->rows[0], &y->rows[0] ),
		int3_min( &x->rows[1], &y->rows[1] )
	};
}

// Performs a int2x3_max function on each row of the matrix.
HLML_INLINE int2x3 int2x3_max( const int2x3* x, const int2x3* y )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_max( &x->rows[0], &y->rows[0] ),
		int3_max( &x->rows[1], &y->rows[1] )
	};
}

// Performs a int2x3_clamp function on each row of the matrix.
HLML_INLINE int2x3 int2x3_clamp( const int2x3* x, const int2x3* low, const int2x3* high )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		int3_clamp( &x->rows[1], &low->rows[1], &high->rows[1] )
	};
}

// Performs a int2x3_saturate function on each row of the matrix.
HLML_INLINE int2x3 int2x3_saturate( const int2x3* x )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_saturate( &x->rows[0] ),
		int3_saturate( &x->rows[1] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int2x3_equals( const int2x3* lhs, const int2x3* rhs )
{
	return
		int3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		int3_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int2x3_not_equals( const int2x3* lhs, const int2x3* rhs )
{
	return !int2x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x3 int2x3_less_than( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		int3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		int3_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 int2x3_less_than_equal( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		int3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int3_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x3 int2x3_greater_than( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		int3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		int3_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 int2x3_greater_than_equal( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		int3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 int2x3_cadds( const int2x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cadds( &lhs->rows[0], rhs ),
		int3_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int2x3 int2x3_caddm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int3_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 int2x3_csubs( const int2x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_csubs( &lhs->rows[0], rhs ),
		int3_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int2x3 int2x3_csubm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int3_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 int2x3_cmuls( const int2x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cmuls( &lhs->rows[0], rhs ),
		int3_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int2x3 int2x3_cmulm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 int2x3_cdivs( const int2x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cdivs( &lhs->rows[0], rhs ),
		int3_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int2x3 int2x3_cdivm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE int2x3 int2x3_negate( const int2x3* x )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_negate( &x->rows[0] ),
		int3_negate( &x->rows[1] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE int2x3 int2x3_not( const int2x3* x )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_not( &x->rows[0] ),
		int3_not( &x->rows[1] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 int2x3_cands( const int2x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cands( &lhs->rows[0], rhs ),
		int3_cands( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int2x3 int2x3_candm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_candv( &lhs->rows[0], &rhs->rows[0] ),
		int3_candv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 int2x3_cors( const int2x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cors( &lhs->rows[0], rhs ),
		int3_cors( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int2x3 int2x3_corm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_corv( &lhs->rows[0], &rhs->rows[0] ),
		int3_corv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 int2x3_cxors( const int2x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cxors( &lhs->rows[0], rhs ),
		int3_cxors( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int2x3 int2x3_cxorm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cxorv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 int2x3_cshift_lefts( const int2x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cshift_lefts( &lhs->rows[0], rhs ),
		int3_cshift_lefts( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int2x3 int2x3_cshift_leftm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cshift_leftv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 int2x3_cshift_rights( const int2x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cshift_rights( &lhs->rows[0], rhs ),
		int3_cshift_rights( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int2x3 int2x3_cshift_rightm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		int3_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cshift_rightv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void int2x3_identity( int2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int3x2 int2x3_transpose( const int2x3* mat )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int2x2 int2x3_mulm( const int2x3* lhs, const int3x2* rhs )
{
	int3 row0 = lhs->rows[0];
	int3 row1 = lhs->rows[1];

	int3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	int3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };

	return HLML_CONSTRUCT( int2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

// int2x4
// Performs a int2x4_sign function on each row of the matrix.
HLML_INLINE int2x4 int2x4_sign( const int2x4* x )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_sign( &x->rows[0] ),
		int4_sign( &x->rows[1] )
	};
}

// Performs a int2x4_min function on each row of the matrix.
HLML_INLINE int2x4 int2x4_min( const int2x4* x, const int2x4* y )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_min( &x->rows[0], &y->rows[0] ),
		int4_min( &x->rows[1], &y->rows[1] )
	};
}

// Performs a int2x4_max function on each row of the matrix.
HLML_INLINE int2x4 int2x4_max( const int2x4* x, const int2x4* y )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_max( &x->rows[0], &y->rows[0] ),
		int4_max( &x->rows[1], &y->rows[1] )
	};
}

// Performs a int2x4_clamp function on each row of the matrix.
HLML_INLINE int2x4 int2x4_clamp( const int2x4* x, const int2x4* low, const int2x4* high )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		int4_clamp( &x->rows[1], &low->rows[1], &high->rows[1] )
	};
}

// Performs a int2x4_saturate function on each row of the matrix.
HLML_INLINE int2x4 int2x4_saturate( const int2x4* x )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_saturate( &x->rows[0] ),
		int4_saturate( &x->rows[1] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int2x4_equals( const int2x4* lhs, const int2x4* rhs )
{
	return
		int4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		int4_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int2x4_not_equals( const int2x4* lhs, const int2x4* rhs )
{
	return !int2x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x4 int2x4_less_than( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		int4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		int4_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 int2x4_less_than_equal( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		int4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int4_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x4 int2x4_greater_than( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		int4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		int4_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 int2x4_greater_than_equal( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		int4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 int2x4_cadds( const int2x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cadds( &lhs->rows[0], rhs ),
		int4_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int2x4 int2x4_caddm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int4_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 int2x4_csubs( const int2x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_csubs( &lhs->rows[0], rhs ),
		int4_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int2x4 int2x4_csubm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int4_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 int2x4_cmuls( const int2x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cmuls( &lhs->rows[0], rhs ),
		int4_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int2x4 int2x4_cmulm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 int2x4_cdivs( const int2x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cdivs( &lhs->rows[0], rhs ),
		int4_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int2x4 int2x4_cdivm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE int2x4 int2x4_negate( const int2x4* x )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_negate( &x->rows[0] ),
		int4_negate( &x->rows[1] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE int2x4 int2x4_not( const int2x4* x )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_not( &x->rows[0] ),
		int4_not( &x->rows[1] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 int2x4_cands( const int2x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cands( &lhs->rows[0], rhs ),
		int4_cands( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int2x4 int2x4_candm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_candv( &lhs->rows[0], &rhs->rows[0] ),
		int4_candv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 int2x4_cors( const int2x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cors( &lhs->rows[0], rhs ),
		int4_cors( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int2x4 int2x4_corm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_corv( &lhs->rows[0], &rhs->rows[0] ),
		int4_corv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 int2x4_cxors( const int2x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cxors( &lhs->rows[0], rhs ),
		int4_cxors( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int2x4 int2x4_cxorm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cxorv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 int2x4_cshift_lefts( const int2x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cshift_lefts( &lhs->rows[0], rhs ),
		int4_cshift_lefts( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int2x4 int2x4_cshift_leftm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cshift_leftv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 int2x4_cshift_rights( const int2x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cshift_rights( &lhs->rows[0], rhs ),
		int4_cshift_rights( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int2x4 int2x4_cshift_rightm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		int4_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cshift_rightv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void int2x4_identity( int2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int4x2 int2x4_transpose( const int2x4* mat )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int2x2 int2x4_mulm( const int2x4* lhs, const int4x2* rhs )
{
	int4 row0 = lhs->rows[0];
	int4 row1 = lhs->rows[1];

	int4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	int4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };

	return HLML_CONSTRUCT( int2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

// int3x2
// Performs a int3x2_sign function on each row of the matrix.
HLML_INLINE int3x2 int3x2_sign( const int3x2* x )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_sign( &x->rows[0] ),
		int2_sign( &x->rows[1] ),
		int2_sign( &x->rows[2] )
	};
}

// Performs a int3x2_min function on each row of the matrix.
HLML_INLINE int3x2 int3x2_min( const int3x2* x, const int3x2* y )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_min( &x->rows[0], &y->rows[0] ),
		int2_min( &x->rows[1], &y->rows[1] ),
		int2_min( &x->rows[2], &y->rows[2] )
	};
}

// Performs a int3x2_max function on each row of the matrix.
HLML_INLINE int3x2 int3x2_max( const int3x2* x, const int3x2* y )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_max( &x->rows[0], &y->rows[0] ),
		int2_max( &x->rows[1], &y->rows[1] ),
		int2_max( &x->rows[2], &y->rows[2] )
	};
}

// Performs a int3x2_clamp function on each row of the matrix.
HLML_INLINE int3x2 int3x2_clamp( const int3x2* x, const int3x2* low, const int3x2* high )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		int2_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		int2_clamp( &x->rows[2], &low->rows[2], &high->rows[2] )
	};
}

// Performs a int3x2_saturate function on each row of the matrix.
HLML_INLINE int3x2 int3x2_saturate( const int3x2* x )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_saturate( &x->rows[0] ),
		int2_saturate( &x->rows[1] ),
		int2_saturate( &x->rows[2] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int3x2_equals( const int3x2* lhs, const int3x2* rhs )
{
	return
		int2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		int2_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		int2_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int3x2_not_equals( const int3x2* lhs, const int3x2* rhs )
{
	return !int3x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x2 int3x2_less_than( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		int2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		int2_less_than( &lhs->rows[1], &rhs->rows[1] ),
		int2_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 int3x2_less_than_equal( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		int2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int2_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		int2_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x2 int3x2_greater_than( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		int2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		int2_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		int2_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 int3x2_greater_than_equal( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		int2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		int2_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 int3x2_cadds( const int3x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cadds( &lhs->rows[0], rhs ),
		int2_cadds( &lhs->rows[1], rhs ),
		int2_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int3x2 int3x2_caddm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		int2_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 int3x2_csubs( const int3x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_csubs( &lhs->rows[0], rhs ),
		int2_csubs( &lhs->rows[1], rhs ),
		int2_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int3x2 int3x2_csubm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		int2_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 int3x2_cmuls( const int3x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cmuls( &lhs->rows[0], rhs ),
		int2_cmuls( &lhs->rows[1], rhs ),
		int2_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int3x2 int3x2_cmulm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 int3x2_cdivs( const int3x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cdivs( &lhs->rows[0], rhs ),
		int2_cdivs( &lhs->rows[1], rhs ),
		int2_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int3x2 int3x2_cdivm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE int3x2 int3x2_negate( const int3x2* x )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_negate( &x->rows[0] ),
		int2_negate( &x->rows[1] ),
		int2_negate( &x->rows[2] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE int3x2 int3x2_not( const int3x2* x )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_not( &x->rows[0] ),
		int2_not( &x->rows[1] ),
		int2_not( &x->rows[2] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 int3x2_cands( const int3x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cands( &lhs->rows[0], rhs ),
		int2_cands( &lhs->rows[1], rhs ),
		int2_cands( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int3x2 int3x2_candm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_candv( &lhs->rows[0], &rhs->rows[0] ),
		int2_candv( &lhs->rows[1], &rhs->rows[1] ),
		int2_candv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 int3x2_cors( const int3x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cors( &lhs->rows[0], rhs ),
		int2_cors( &lhs->rows[1], rhs ),
		int2_cors( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int3x2 int3x2_corm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_corv( &lhs->rows[0], &rhs->rows[0] ),
		int2_corv( &lhs->rows[1], &rhs->rows[1] ),
		int2_corv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 int3x2_cxors( const int3x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cxors( &lhs->rows[0], rhs ),
		int2_cxors( &lhs->rows[1], rhs ),
		int2_cxors( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int3x2 int3x2_cxorm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cxorv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cxorv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 int3x2_cshift_lefts( const int3x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cshift_lefts( &lhs->rows[0], rhs ),
		int2_cshift_lefts( &lhs->rows[1], rhs ),
		int2_cshift_lefts( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int3x2 int3x2_cshift_leftm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cshift_leftv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cshift_leftv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 int3x2_cshift_rights( const int3x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cshift_rights( &lhs->rows[0], rhs ),
		int2_cshift_rights( &lhs->rows[1], rhs ),
		int2_cshift_rights( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int3x2 int3x2_cshift_rightm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		int2_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cshift_rightv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cshift_rightv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void int3x2_identity( int3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
	mat->rows[2] = HLML_CONSTRUCT( int2 ) { 0, 0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int2x3 int3x2_transpose( const int3x2* mat )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int3x3 int3x2_mulm( const int3x2* lhs, const int2x3* rhs )
{
	int2 row0 = lhs->rows[0];
	int2 row1 = lhs->rows[1];
	int2 row2 = lhs->rows[2];

	int2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	int2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	int2 col2 = { rhs->rows[0].z, rhs->rows[1].z };

	return HLML_CONSTRUCT( int3x3 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

// int3x3
// Performs a int3x3_sign function on each row of the matrix.
HLML_INLINE int3x3 int3x3_sign( const int3x3* x )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_sign( &x->rows[0] ),
		int3_sign( &x->rows[1] ),
		int3_sign( &x->rows[2] )
	};
}

// Performs a int3x3_min function on each row of the matrix.
HLML_INLINE int3x3 int3x3_min( const int3x3* x, const int3x3* y )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_min( &x->rows[0], &y->rows[0] ),
		int3_min( &x->rows[1], &y->rows[1] ),
		int3_min( &x->rows[2], &y->rows[2] )
	};
}

// Performs a int3x3_max function on each row of the matrix.
HLML_INLINE int3x3 int3x3_max( const int3x3* x, const int3x3* y )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_max( &x->rows[0], &y->rows[0] ),
		int3_max( &x->rows[1], &y->rows[1] ),
		int3_max( &x->rows[2], &y->rows[2] )
	};
}

// Performs a int3x3_clamp function on each row of the matrix.
HLML_INLINE int3x3 int3x3_clamp( const int3x3* x, const int3x3* low, const int3x3* high )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		int3_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		int3_clamp( &x->rows[2], &low->rows[2], &high->rows[2] )
	};
}

// Performs a int3x3_saturate function on each row of the matrix.
HLML_INLINE int3x3 int3x3_saturate( const int3x3* x )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_saturate( &x->rows[0] ),
		int3_saturate( &x->rows[1] ),
		int3_saturate( &x->rows[2] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int3x3_equals( const int3x3* lhs, const int3x3* rhs )
{
	return
		int3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		int3_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		int3_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int3x3_not_equals( const int3x3* lhs, const int3x3* rhs )
{
	return !int3x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x3 int3x3_less_than( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		int3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		int3_less_than( &lhs->rows[1], &rhs->rows[1] ),
		int3_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 int3x3_less_than_equal( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		int3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int3_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		int3_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x3 int3x3_greater_than( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		int3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		int3_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		int3_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 int3x3_greater_than_equal( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		int3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		int3_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 int3x3_cadds( const int3x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cadds( &lhs->rows[0], rhs ),
		int3_cadds( &lhs->rows[1], rhs ),
		int3_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int3x3 int3x3_caddm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		int3_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 int3x3_csubs( const int3x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_csubs( &lhs->rows[0], rhs ),
		int3_csubs( &lhs->rows[1], rhs ),
		int3_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int3x3 int3x3_csubm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		int3_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 int3x3_cmuls( const int3x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cmuls( &lhs->rows[0], rhs ),
		int3_cmuls( &lhs->rows[1], rhs ),
		int3_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int3x3 int3x3_cmulm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 int3x3_cdivs( const int3x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cdivs( &lhs->rows[0], rhs ),
		int3_cdivs( &lhs->rows[1], rhs ),
		int3_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int3x3 int3x3_cdivm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE int3x3 int3x3_negate( const int3x3* x )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_negate( &x->rows[0] ),
		int3_negate( &x->rows[1] ),
		int3_negate( &x->rows[2] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE int3x3 int3x3_not( const int3x3* x )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_not( &x->rows[0] ),
		int3_not( &x->rows[1] ),
		int3_not( &x->rows[2] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 int3x3_cands( const int3x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cands( &lhs->rows[0], rhs ),
		int3_cands( &lhs->rows[1], rhs ),
		int3_cands( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int3x3 int3x3_candm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_candv( &lhs->rows[0], &rhs->rows[0] ),
		int3_candv( &lhs->rows[1], &rhs->rows[1] ),
		int3_candv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 int3x3_cors( const int3x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cors( &lhs->rows[0], rhs ),
		int3_cors( &lhs->rows[1], rhs ),
		int3_cors( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int3x3 int3x3_corm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_corv( &lhs->rows[0], &rhs->rows[0] ),
		int3_corv( &lhs->rows[1], &rhs->rows[1] ),
		int3_corv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 int3x3_cxors( const int3x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cxors( &lhs->rows[0], rhs ),
		int3_cxors( &lhs->rows[1], rhs ),
		int3_cxors( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int3x3 int3x3_cxorm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cxorv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cxorv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 int3x3_cshift_lefts( const int3x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cshift_lefts( &lhs->rows[0], rhs ),
		int3_cshift_lefts( &lhs->rows[1], rhs ),
		int3_cshift_lefts( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int3x3 int3x3_cshift_leftm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cshift_leftv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cshift_leftv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 int3x3_cshift_rights( const int3x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cshift_rights( &lhs->rows[0], rhs ),
		int3_cshift_rights( &lhs->rows[1], rhs ),
		int3_cshift_rights( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int3x3 int3x3_cshift_rightm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		int3_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cshift_rightv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cshift_rightv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void int3x3_identity( int3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
	mat->rows[2] = HLML_CONSTRUCT( int3 ) { 0, 0, 1 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int3x3 int3x3_transpose( const int3x3* mat )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

// Returns the determinant of the matrix.
HLML_INLINE int32_t int3x3_determinant( const int3x3* mat )
{
	return
		+ mat->rows[0].x * ( mat->rows[1].y * mat->rows[2].z - mat->rows[2].y * mat->rows[1].z ) 
		- mat->rows[0].y * ( mat->rows[1].x * mat->rows[2].z - mat->rows[2].x * mat->rows[1].z ) 
		+ mat->rows[0].z * ( mat->rows[1].x * mat->rows[2].y - mat->rows[2].x * mat->rows[1].y );
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int3x3 int3x3_mulm( const int3x3* lhs, const int3x3* rhs )
{
	int3 row0 = lhs->rows[0];
	int3 row1 = lhs->rows[1];
	int3 row2 = lhs->rows[2];

	int3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	int3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	int3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };

	return HLML_CONSTRUCT( int3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE int3 int3x3_mulv( const int3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		( lhs->x * rhs->rows[0].x ) + ( lhs->y * rhs->rows[1].x ) + ( lhs->z * rhs->rows[2].x ),
		( lhs->x * rhs->rows[0].y ) + ( lhs->y * rhs->rows[1].y ) + ( lhs->z * rhs->rows[2].y ),
		( lhs->x * rhs->rows[0].z ) + ( lhs->y * rhs->rows[1].z ) + ( lhs->z * rhs->rows[2].z )
	};
}

// int3x4
// Performs a int3x4_sign function on each row of the matrix.
HLML_INLINE int3x4 int3x4_sign( const int3x4* x )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_sign( &x->rows[0] ),
		int4_sign( &x->rows[1] ),
		int4_sign( &x->rows[2] )
	};
}

// Performs a int3x4_min function on each row of the matrix.
HLML_INLINE int3x4 int3x4_min( const int3x4* x, const int3x4* y )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_min( &x->rows[0], &y->rows[0] ),
		int4_min( &x->rows[1], &y->rows[1] ),
		int4_min( &x->rows[2], &y->rows[2] )
	};
}

// Performs a int3x4_max function on each row of the matrix.
HLML_INLINE int3x4 int3x4_max( const int3x4* x, const int3x4* y )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_max( &x->rows[0], &y->rows[0] ),
		int4_max( &x->rows[1], &y->rows[1] ),
		int4_max( &x->rows[2], &y->rows[2] )
	};
}

// Performs a int3x4_clamp function on each row of the matrix.
HLML_INLINE int3x4 int3x4_clamp( const int3x4* x, const int3x4* low, const int3x4* high )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		int4_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		int4_clamp( &x->rows[2], &low->rows[2], &high->rows[2] )
	};
}

// Performs a int3x4_saturate function on each row of the matrix.
HLML_INLINE int3x4 int3x4_saturate( const int3x4* x )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_saturate( &x->rows[0] ),
		int4_saturate( &x->rows[1] ),
		int4_saturate( &x->rows[2] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int3x4_equals( const int3x4* lhs, const int3x4* rhs )
{
	return
		int4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		int4_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		int4_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int3x4_not_equals( const int3x4* lhs, const int3x4* rhs )
{
	return !int3x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x4 int3x4_less_than( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		int4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		int4_less_than( &lhs->rows[1], &rhs->rows[1] ),
		int4_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 int3x4_less_than_equal( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		int4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int4_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		int4_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x4 int3x4_greater_than( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		int4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		int4_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		int4_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 int3x4_greater_than_equal( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		int4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		int4_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 int3x4_cadds( const int3x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cadds( &lhs->rows[0], rhs ),
		int4_cadds( &lhs->rows[1], rhs ),
		int4_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int3x4 int3x4_caddm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		int4_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 int3x4_csubs( const int3x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_csubs( &lhs->rows[0], rhs ),
		int4_csubs( &lhs->rows[1], rhs ),
		int4_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int3x4 int3x4_csubm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		int4_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 int3x4_cmuls( const int3x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cmuls( &lhs->rows[0], rhs ),
		int4_cmuls( &lhs->rows[1], rhs ),
		int4_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int3x4 int3x4_cmulm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 int3x4_cdivs( const int3x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cdivs( &lhs->rows[0], rhs ),
		int4_cdivs( &lhs->rows[1], rhs ),
		int4_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int3x4 int3x4_cdivm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE int3x4 int3x4_negate( const int3x4* x )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_negate( &x->rows[0] ),
		int4_negate( &x->rows[1] ),
		int4_negate( &x->rows[2] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE int3x4 int3x4_not( const int3x4* x )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_not( &x->rows[0] ),
		int4_not( &x->rows[1] ),
		int4_not( &x->rows[2] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 int3x4_cands( const int3x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cands( &lhs->rows[0], rhs ),
		int4_cands( &lhs->rows[1], rhs ),
		int4_cands( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int3x4 int3x4_candm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_candv( &lhs->rows[0], &rhs->rows[0] ),
		int4_candv( &lhs->rows[1], &rhs->rows[1] ),
		int4_candv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 int3x4_cors( const int3x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cors( &lhs->rows[0], rhs ),
		int4_cors( &lhs->rows[1], rhs ),
		int4_cors( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int3x4 int3x4_corm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_corv( &lhs->rows[0], &rhs->rows[0] ),
		int4_corv( &lhs->rows[1], &rhs->rows[1] ),
		int4_corv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 int3x4_cxors( const int3x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cxors( &lhs->rows[0], rhs ),
		int4_cxors( &lhs->rows[1], rhs ),
		int4_cxors( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int3x4 int3x4_cxorm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cxorv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cxorv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 int3x4_cshift_lefts( const int3x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cshift_lefts( &lhs->rows[0], rhs ),
		int4_cshift_lefts( &lhs->rows[1], rhs ),
		int4_cshift_lefts( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int3x4 int3x4_cshift_leftm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cshift_leftv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cshift_leftv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 int3x4_cshift_rights( const int3x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cshift_rights( &lhs->rows[0], rhs ),
		int4_cshift_rights( &lhs->rows[1], rhs ),
		int4_cshift_rights( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int3x4 int3x4_cshift_rightm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		int4_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cshift_rightv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cshift_rightv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void int3x4_identity( int3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
	mat->rows[2] = HLML_CONSTRUCT( int4 ) { 0, 0, 1, 0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int4x3 int3x4_transpose( const int3x4* mat )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int3x3 int3x4_mulm( const int3x4* lhs, const int4x3* rhs )
{
	int4 row0 = lhs->rows[0];
	int4 row1 = lhs->rows[1];
	int4 row2 = lhs->rows[2];

	int4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	int4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	int4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };

	return HLML_CONSTRUCT( int3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

// int4x2
// Performs a int4x2_sign function on each row of the matrix.
HLML_INLINE int4x2 int4x2_sign( const int4x2* x )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_sign( &x->rows[0] ),
		int2_sign( &x->rows[1] ),
		int2_sign( &x->rows[2] ),
		int2_sign( &x->rows[3] )
	};
}

// Performs a int4x2_min function on each row of the matrix.
HLML_INLINE int4x2 int4x2_min( const int4x2* x, const int4x2* y )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_min( &x->rows[0], &y->rows[0] ),
		int2_min( &x->rows[1], &y->rows[1] ),
		int2_min( &x->rows[2], &y->rows[2] ),
		int2_min( &x->rows[3], &y->rows[3] )
	};
}

// Performs a int4x2_max function on each row of the matrix.
HLML_INLINE int4x2 int4x2_max( const int4x2* x, const int4x2* y )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_max( &x->rows[0], &y->rows[0] ),
		int2_max( &x->rows[1], &y->rows[1] ),
		int2_max( &x->rows[2], &y->rows[2] ),
		int2_max( &x->rows[3], &y->rows[3] )
	};
}

// Performs a int4x2_clamp function on each row of the matrix.
HLML_INLINE int4x2 int4x2_clamp( const int4x2* x, const int4x2* low, const int4x2* high )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		int2_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		int2_clamp( &x->rows[2], &low->rows[2], &high->rows[2] ),
		int2_clamp( &x->rows[3], &low->rows[3], &high->rows[3] )
	};
}

// Performs a int4x2_saturate function on each row of the matrix.
HLML_INLINE int4x2 int4x2_saturate( const int4x2* x )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_saturate( &x->rows[0] ),
		int2_saturate( &x->rows[1] ),
		int2_saturate( &x->rows[2] ),
		int2_saturate( &x->rows[3] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int4x2_equals( const int4x2* lhs, const int4x2* rhs )
{
	return
		int2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		int2_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		int2_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		int2_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int4x2_not_equals( const int4x2* lhs, const int4x2* rhs )
{
	return !int4x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x2 int4x2_less_than( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		int2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		int2_less_than( &lhs->rows[1], &rhs->rows[1] ),
		int2_less_than( &lhs->rows[2], &rhs->rows[2] ),
		int2_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 int4x2_less_than_equal( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		int2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int2_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		int2_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		int2_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x2 int4x2_greater_than( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		int2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		int2_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		int2_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		int2_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 int4x2_greater_than_equal( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		int2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		int2_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		int2_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 int4x2_cadds( const int4x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cadds( &lhs->rows[0], rhs ),
		int2_cadds( &lhs->rows[1], rhs ),
		int2_cadds( &lhs->rows[2], rhs ),
		int2_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int4x2 int4x2_caddm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		int2_caddv( &lhs->rows[2], &rhs->rows[2] ),
		int2_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 int4x2_csubs( const int4x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_csubs( &lhs->rows[0], rhs ),
		int2_csubs( &lhs->rows[1], rhs ),
		int2_csubs( &lhs->rows[2], rhs ),
		int2_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int4x2 int4x2_csubm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		int2_csubv( &lhs->rows[2], &rhs->rows[2] ),
		int2_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 int4x2_cmuls( const int4x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cmuls( &lhs->rows[0], rhs ),
		int2_cmuls( &lhs->rows[1], rhs ),
		int2_cmuls( &lhs->rows[2], rhs ),
		int2_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int4x2 int4x2_cmulm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		int2_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 int4x2_cdivs( const int4x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cdivs( &lhs->rows[0], rhs ),
		int2_cdivs( &lhs->rows[1], rhs ),
		int2_cdivs( &lhs->rows[2], rhs ),
		int2_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int4x2 int4x2_cdivm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		int2_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE int4x2 int4x2_negate( const int4x2* x )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_negate( &x->rows[0] ),
		int2_negate( &x->rows[1] ),
		int2_negate( &x->rows[2] ),
		int2_negate( &x->rows[3] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE int4x2 int4x2_not( const int4x2* x )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_not( &x->rows[0] ),
		int2_not( &x->rows[1] ),
		int2_not( &x->rows[2] ),
		int2_not( &x->rows[3] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 int4x2_cands( const int4x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cands( &lhs->rows[0], rhs ),
		int2_cands( &lhs->rows[1], rhs ),
		int2_cands( &lhs->rows[2], rhs ),
		int2_cands( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int4x2 int4x2_candm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_candv( &lhs->rows[0], &rhs->rows[0] ),
		int2_candv( &lhs->rows[1], &rhs->rows[1] ),
		int2_candv( &lhs->rows[2], &rhs->rows[2] ),
		int2_candv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 int4x2_cors( const int4x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cors( &lhs->rows[0], rhs ),
		int2_cors( &lhs->rows[1], rhs ),
		int2_cors( &lhs->rows[2], rhs ),
		int2_cors( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int4x2 int4x2_corm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_corv( &lhs->rows[0], &rhs->rows[0] ),
		int2_corv( &lhs->rows[1], &rhs->rows[1] ),
		int2_corv( &lhs->rows[2], &rhs->rows[2] ),
		int2_corv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 int4x2_cxors( const int4x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cxors( &lhs->rows[0], rhs ),
		int2_cxors( &lhs->rows[1], rhs ),
		int2_cxors( &lhs->rows[2], rhs ),
		int2_cxors( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int4x2 int4x2_cxorm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cxorv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cxorv( &lhs->rows[2], &rhs->rows[2] ),
		int2_cxorv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 int4x2_cshift_lefts( const int4x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cshift_lefts( &lhs->rows[0], rhs ),
		int2_cshift_lefts( &lhs->rows[1], rhs ),
		int2_cshift_lefts( &lhs->rows[2], rhs ),
		int2_cshift_lefts( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int4x2 int4x2_cshift_leftm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cshift_leftv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cshift_leftv( &lhs->rows[2], &rhs->rows[2] ),
		int2_cshift_leftv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 int4x2_cshift_rights( const int4x2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cshift_rights( &lhs->rows[0], rhs ),
		int2_cshift_rights( &lhs->rows[1], rhs ),
		int2_cshift_rights( &lhs->rows[2], rhs ),
		int2_cshift_rights( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int4x2 int4x2_cshift_rightm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		int2_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cshift_rightv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cshift_rightv( &lhs->rows[2], &rhs->rows[2] ),
		int2_cshift_rightv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void int4x2_identity( int4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
	mat->rows[2] = HLML_CONSTRUCT( int2 ) { 0, 0 };
	mat->rows[3] = HLML_CONSTRUCT( int2 ) { 0, 0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int2x4 int4x2_transpose( const int4x2* mat )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int4x4 int4x2_mulm( const int4x2* lhs, const int2x4* rhs )
{
	int2 row0 = lhs->rows[0];
	int2 row1 = lhs->rows[1];
	int2 row2 = lhs->rows[2];
	int2 row3 = lhs->rows[3];

	int2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	int2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	int2 col2 = { rhs->rows[0].z, rhs->rows[1].z };
	int2 col3 = { rhs->rows[0].w, rhs->rows[1].w };

	return HLML_CONSTRUCT( int4x4 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

// int4x3
// Performs a int4x3_sign function on each row of the matrix.
HLML_INLINE int4x3 int4x3_sign( const int4x3* x )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_sign( &x->rows[0] ),
		int3_sign( &x->rows[1] ),
		int3_sign( &x->rows[2] ),
		int3_sign( &x->rows[3] )
	};
}

// Performs a int4x3_min function on each row of the matrix.
HLML_INLINE int4x3 int4x3_min( const int4x3* x, const int4x3* y )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_min( &x->rows[0], &y->rows[0] ),
		int3_min( &x->rows[1], &y->rows[1] ),
		int3_min( &x->rows[2], &y->rows[2] ),
		int3_min( &x->rows[3], &y->rows[3] )
	};
}

// Performs a int4x3_max function on each row of the matrix.
HLML_INLINE int4x3 int4x3_max( const int4x3* x, const int4x3* y )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_max( &x->rows[0], &y->rows[0] ),
		int3_max( &x->rows[1], &y->rows[1] ),
		int3_max( &x->rows[2], &y->rows[2] ),
		int3_max( &x->rows[3], &y->rows[3] )
	};
}

// Performs a int4x3_clamp function on each row of the matrix.
HLML_INLINE int4x3 int4x3_clamp( const int4x3* x, const int4x3* low, const int4x3* high )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		int3_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		int3_clamp( &x->rows[2], &low->rows[2], &high->rows[2] ),
		int3_clamp( &x->rows[3], &low->rows[3], &high->rows[3] )
	};
}

// Performs a int4x3_saturate function on each row of the matrix.
HLML_INLINE int4x3 int4x3_saturate( const int4x3* x )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_saturate( &x->rows[0] ),
		int3_saturate( &x->rows[1] ),
		int3_saturate( &x->rows[2] ),
		int3_saturate( &x->rows[3] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int4x3_equals( const int4x3* lhs, const int4x3* rhs )
{
	return
		int3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		int3_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		int3_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		int3_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int4x3_not_equals( const int4x3* lhs, const int4x3* rhs )
{
	return !int4x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x3 int4x3_less_than( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		int3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		int3_less_than( &lhs->rows[1], &rhs->rows[1] ),
		int3_less_than( &lhs->rows[2], &rhs->rows[2] ),
		int3_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 int4x3_less_than_equal( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		int3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int3_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		int3_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		int3_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x3 int4x3_greater_than( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		int3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		int3_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		int3_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		int3_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 int4x3_greater_than_equal( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		int3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		int3_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		int3_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 int4x3_cadds( const int4x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cadds( &lhs->rows[0], rhs ),
		int3_cadds( &lhs->rows[1], rhs ),
		int3_cadds( &lhs->rows[2], rhs ),
		int3_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int4x3 int4x3_caddm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		int3_caddv( &lhs->rows[2], &rhs->rows[2] ),
		int3_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 int4x3_csubs( const int4x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_csubs( &lhs->rows[0], rhs ),
		int3_csubs( &lhs->rows[1], rhs ),
		int3_csubs( &lhs->rows[2], rhs ),
		int3_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int4x3 int4x3_csubm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		int3_csubv( &lhs->rows[2], &rhs->rows[2] ),
		int3_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 int4x3_cmuls( const int4x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cmuls( &lhs->rows[0], rhs ),
		int3_cmuls( &lhs->rows[1], rhs ),
		int3_cmuls( &lhs->rows[2], rhs ),
		int3_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int4x3 int4x3_cmulm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		int3_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 int4x3_cdivs( const int4x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cdivs( &lhs->rows[0], rhs ),
		int3_cdivs( &lhs->rows[1], rhs ),
		int3_cdivs( &lhs->rows[2], rhs ),
		int3_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int4x3 int4x3_cdivm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		int3_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE int4x3 int4x3_negate( const int4x3* x )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_negate( &x->rows[0] ),
		int3_negate( &x->rows[1] ),
		int3_negate( &x->rows[2] ),
		int3_negate( &x->rows[3] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE int4x3 int4x3_not( const int4x3* x )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_not( &x->rows[0] ),
		int3_not( &x->rows[1] ),
		int3_not( &x->rows[2] ),
		int3_not( &x->rows[3] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 int4x3_cands( const int4x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cands( &lhs->rows[0], rhs ),
		int3_cands( &lhs->rows[1], rhs ),
		int3_cands( &lhs->rows[2], rhs ),
		int3_cands( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int4x3 int4x3_candm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_candv( &lhs->rows[0], &rhs->rows[0] ),
		int3_candv( &lhs->rows[1], &rhs->rows[1] ),
		int3_candv( &lhs->rows[2], &rhs->rows[2] ),
		int3_candv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 int4x3_cors( const int4x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cors( &lhs->rows[0], rhs ),
		int3_cors( &lhs->rows[1], rhs ),
		int3_cors( &lhs->rows[2], rhs ),
		int3_cors( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int4x3 int4x3_corm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_corv( &lhs->rows[0], &rhs->rows[0] ),
		int3_corv( &lhs->rows[1], &rhs->rows[1] ),
		int3_corv( &lhs->rows[2], &rhs->rows[2] ),
		int3_corv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 int4x3_cxors( const int4x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cxors( &lhs->rows[0], rhs ),
		int3_cxors( &lhs->rows[1], rhs ),
		int3_cxors( &lhs->rows[2], rhs ),
		int3_cxors( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int4x3 int4x3_cxorm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cxorv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cxorv( &lhs->rows[2], &rhs->rows[2] ),
		int3_cxorv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 int4x3_cshift_lefts( const int4x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cshift_lefts( &lhs->rows[0], rhs ),
		int3_cshift_lefts( &lhs->rows[1], rhs ),
		int3_cshift_lefts( &lhs->rows[2], rhs ),
		int3_cshift_lefts( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int4x3 int4x3_cshift_leftm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cshift_leftv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cshift_leftv( &lhs->rows[2], &rhs->rows[2] ),
		int3_cshift_leftv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 int4x3_cshift_rights( const int4x3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cshift_rights( &lhs->rows[0], rhs ),
		int3_cshift_rights( &lhs->rows[1], rhs ),
		int3_cshift_rights( &lhs->rows[2], rhs ),
		int3_cshift_rights( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int4x3 int4x3_cshift_rightm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		int3_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cshift_rightv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cshift_rightv( &lhs->rows[2], &rhs->rows[2] ),
		int3_cshift_rightv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void int4x3_identity( int4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
	mat->rows[2] = HLML_CONSTRUCT( int3 ) { 0, 0, 1 };
	mat->rows[3] = HLML_CONSTRUCT( int3 ) { 0, 0, 0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int3x4 int4x3_transpose( const int4x3* mat )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int4x4 int4x3_mulm( const int4x3* lhs, const int3x4* rhs )
{
	int3 row0 = lhs->rows[0];
	int3 row1 = lhs->rows[1];
	int3 row2 = lhs->rows[2];
	int3 row3 = lhs->rows[3];

	int3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	int3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	int3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };
	int3 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w };

	return HLML_CONSTRUCT( int4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

// int4x4
// Performs a int4x4_sign function on each row of the matrix.
HLML_INLINE int4x4 int4x4_sign( const int4x4* x )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_sign( &x->rows[0] ),
		int4_sign( &x->rows[1] ),
		int4_sign( &x->rows[2] ),
		int4_sign( &x->rows[3] )
	};
}

// Performs a int4x4_min function on each row of the matrix.
HLML_INLINE int4x4 int4x4_min( const int4x4* x, const int4x4* y )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_min( &x->rows[0], &y->rows[0] ),
		int4_min( &x->rows[1], &y->rows[1] ),
		int4_min( &x->rows[2], &y->rows[2] ),
		int4_min( &x->rows[3], &y->rows[3] )
	};
}

// Performs a int4x4_max function on each row of the matrix.
HLML_INLINE int4x4 int4x4_max( const int4x4* x, const int4x4* y )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_max( &x->rows[0], &y->rows[0] ),
		int4_max( &x->rows[1], &y->rows[1] ),
		int4_max( &x->rows[2], &y->rows[2] ),
		int4_max( &x->rows[3], &y->rows[3] )
	};
}

// Performs a int4x4_clamp function on each row of the matrix.
HLML_INLINE int4x4 int4x4_clamp( const int4x4* x, const int4x4* low, const int4x4* high )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		int4_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		int4_clamp( &x->rows[2], &low->rows[2], &high->rows[2] ),
		int4_clamp( &x->rows[3], &low->rows[3], &high->rows[3] )
	};
}

// Performs a int4x4_saturate function on each row of the matrix.
HLML_INLINE int4x4 int4x4_saturate( const int4x4* x )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_saturate( &x->rows[0] ),
		int4_saturate( &x->rows[1] ),
		int4_saturate( &x->rows[2] ),
		int4_saturate( &x->rows[3] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int4x4_equals( const int4x4* lhs, const int4x4* rhs )
{
	return
		int4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		int4_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		int4_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		int4_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int4x4_not_equals( const int4x4* lhs, const int4x4* rhs )
{
	return !int4x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x4 int4x4_less_than( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		int4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		int4_less_than( &lhs->rows[1], &rhs->rows[1] ),
		int4_less_than( &lhs->rows[2], &rhs->rows[2] ),
		int4_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 int4x4_less_than_equal( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		int4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int4_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		int4_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		int4_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x4 int4x4_greater_than( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		int4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		int4_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		int4_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		int4_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 int4x4_greater_than_equal( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		int4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		int4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		int4_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		int4_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 int4x4_cadds( const int4x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cadds( &lhs->rows[0], rhs ),
		int4_cadds( &lhs->rows[1], rhs ),
		int4_cadds( &lhs->rows[2], rhs ),
		int4_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int4x4 int4x4_caddm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		int4_caddv( &lhs->rows[2], &rhs->rows[2] ),
		int4_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 int4x4_csubs( const int4x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_csubs( &lhs->rows[0], rhs ),
		int4_csubs( &lhs->rows[1], rhs ),
		int4_csubs( &lhs->rows[2], rhs ),
		int4_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int4x4 int4x4_csubm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		int4_csubv( &lhs->rows[2], &rhs->rows[2] ),
		int4_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 int4x4_cmuls( const int4x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cmuls( &lhs->rows[0], rhs ),
		int4_cmuls( &lhs->rows[1], rhs ),
		int4_cmuls( &lhs->rows[2], rhs ),
		int4_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int4x4 int4x4_cmulm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		int4_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 int4x4_cdivs( const int4x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cdivs( &lhs->rows[0], rhs ),
		int4_cdivs( &lhs->rows[1], rhs ),
		int4_cdivs( &lhs->rows[2], rhs ),
		int4_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int4x4 int4x4_cdivm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		int4_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE int4x4 int4x4_negate( const int4x4* x )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_negate( &x->rows[0] ),
		int4_negate( &x->rows[1] ),
		int4_negate( &x->rows[2] ),
		int4_negate( &x->rows[3] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE int4x4 int4x4_not( const int4x4* x )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_not( &x->rows[0] ),
		int4_not( &x->rows[1] ),
		int4_not( &x->rows[2] ),
		int4_not( &x->rows[3] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 int4x4_cands( const int4x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cands( &lhs->rows[0], rhs ),
		int4_cands( &lhs->rows[1], rhs ),
		int4_cands( &lhs->rows[2], rhs ),
		int4_cands( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int4x4 int4x4_candm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_candv( &lhs->rows[0], &rhs->rows[0] ),
		int4_candv( &lhs->rows[1], &rhs->rows[1] ),
		int4_candv( &lhs->rows[2], &rhs->rows[2] ),
		int4_candv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 int4x4_cors( const int4x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cors( &lhs->rows[0], rhs ),
		int4_cors( &lhs->rows[1], rhs ),
		int4_cors( &lhs->rows[2], rhs ),
		int4_cors( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int4x4 int4x4_corm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_corv( &lhs->rows[0], &rhs->rows[0] ),
		int4_corv( &lhs->rows[1], &rhs->rows[1] ),
		int4_corv( &lhs->rows[2], &rhs->rows[2] ),
		int4_corv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 int4x4_cxors( const int4x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cxors( &lhs->rows[0], rhs ),
		int4_cxors( &lhs->rows[1], rhs ),
		int4_cxors( &lhs->rows[2], rhs ),
		int4_cxors( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int4x4 int4x4_cxorm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cxorv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cxorv( &lhs->rows[2], &rhs->rows[2] ),
		int4_cxorv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 int4x4_cshift_lefts( const int4x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cshift_lefts( &lhs->rows[0], rhs ),
		int4_cshift_lefts( &lhs->rows[1], rhs ),
		int4_cshift_lefts( &lhs->rows[2], rhs ),
		int4_cshift_lefts( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int4x4 int4x4_cshift_leftm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cshift_leftv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cshift_leftv( &lhs->rows[2], &rhs->rows[2] ),
		int4_cshift_leftv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 int4x4_cshift_rights( const int4x4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cshift_rights( &lhs->rows[0], rhs ),
		int4_cshift_rights( &lhs->rows[1], rhs ),
		int4_cshift_rights( &lhs->rows[2], rhs ),
		int4_cshift_rights( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int4x4 int4x4_cshift_rightm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		int4_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cshift_rightv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cshift_rightv( &lhs->rows[2], &rhs->rows[2] ),
		int4_cshift_rightv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void int4x4_identity( int4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
	mat->rows[2] = HLML_CONSTRUCT( int4 ) { 0, 0, 1, 0 };
	mat->rows[3] = HLML_CONSTRUCT( int4 ) { 0, 0, 0, 1 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int4x4 int4x4_transpose( const int4x4* mat )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

// Returns the determinant of the matrix.
HLML_INLINE int32_t int4x4_determinant( const int4x4* mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	int32_t sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	int32_t sub01 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	int32_t sub02 = mat->rows[2].y * mat->rows[3].z - mat->rows[3].y * mat->rows[2].z;
	int32_t sub03 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	int32_t sub04 = mat->rows[2].x * mat->rows[3].z - mat->rows[3].x * mat->rows[2].z;
	int32_t sub05 = mat->rows[2].x * mat->rows[3].y - mat->rows[3].x * mat->rows[2].y;

	int4 cofactor = HLML_CONSTRUCT( int4 )
	{
		 ( ( ( mat->rows[1].y * sub00 ) - ( mat->rows[1].z * sub01 ) ) + ( mat->rows[1].w * sub02 ) ),
		-( ( ( mat->rows[1].x * sub00 ) - ( mat->rows[1].z * sub03 ) ) + ( mat->rows[1].w * sub04 ) ),
		 ( ( ( mat->rows[1].x * sub01 ) - ( mat->rows[1].y * sub03 ) ) + ( mat->rows[1].w * sub05 ) ),
		-( ( ( mat->rows[1].x * sub02 ) - ( mat->rows[1].y * sub04 ) ) + ( mat->rows[1].z * sub05 ) ) 
	};

	return
		mat->rows[0].x * cofactor.x + mat->rows[0].y * cofactor.y +
		mat->rows[0].z * cofactor.z + mat->rows[0].w * cofactor.w; 
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int4x4 int4x4_mulm( const int4x4* lhs, const int4x4* rhs )
{
	int4 row0 = lhs->rows[0];
	int4 row1 = lhs->rows[1];
	int4 row2 = lhs->rows[2];
	int4 row3 = lhs->rows[3];

	int4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	int4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	int4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };
	int4 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w, rhs->rows[3].w };

	return HLML_CONSTRUCT( int4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE int4 int4x4_mulv( const int4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		( lhs->x * rhs->rows[0].x ) + ( lhs->y * rhs->rows[1].x ) + ( lhs->z * rhs->rows[2].x ) + ( lhs->w * rhs->rows[3].x ),
		( lhs->x * rhs->rows[0].y ) + ( lhs->y * rhs->rows[1].y ) + ( lhs->z * rhs->rows[2].y ) + ( lhs->w * rhs->rows[3].y ),
		( lhs->x * rhs->rows[0].z ) + ( lhs->y * rhs->rows[1].z ) + ( lhs->z * rhs->rows[2].z ) + ( lhs->w * rhs->rows[3].z ),
		( lhs->x * rhs->rows[0].w ) + ( lhs->y * rhs->rows[1].w ) + ( lhs->z * rhs->rows[2].w ) + ( lhs->w * rhs->rows[3].w )
	};
}

// "Translates" the matrix.  Adds the last column of 'mat' by the position vector 'vec'.
HLML_INLINE int4x4 int4x4_translate( const int4x4* mat, const int3* vec )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z,
		mat->rows[3].x, mat->rows[3].y, mat->rows[3].z, mat->rows[3].w
	};
}

// Applies a non-uniform scale to the matrix and returns the result.
HLML_INLINE int4x4 int4x4_scale( const int4x4* mat, const int3* scale )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		mat->rows[0].x * scale->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * scale->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z * scale->z,
		mat->rows[2].w,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z,
		mat->rows[3].w
	};
}

// uint2x2
// Performs a uint2x2_min function on each row of the matrix.
HLML_INLINE uint2x2 uint2x2_min( const uint2x2* x, const uint2x2* y )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_min( &x->rows[0], &y->rows[0] ),
		uint2_min( &x->rows[1], &y->rows[1] )
	};
}

// Performs a uint2x2_max function on each row of the matrix.
HLML_INLINE uint2x2 uint2x2_max( const uint2x2* x, const uint2x2* y )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_max( &x->rows[0], &y->rows[0] ),
		uint2_max( &x->rows[1], &y->rows[1] )
	};
}

// Performs a uint2x2_clamp function on each row of the matrix.
HLML_INLINE uint2x2 uint2x2_clamp( const uint2x2* x, const uint2x2* low, const uint2x2* high )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		uint2_clamp( &x->rows[1], &low->rows[1], &high->rows[1] )
	};
}

// Performs a uint2x2_saturate function on each row of the matrix.
HLML_INLINE uint2x2 uint2x2_saturate( const uint2x2* x )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_saturate( &x->rows[0] ),
		uint2_saturate( &x->rows[1] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint2x2_equals( const uint2x2* lhs, const uint2x2* rhs )
{
	return
		uint2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		uint2_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint2x2_not_equals( const uint2x2* lhs, const uint2x2* rhs )
{
	return !uint2x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x2 uint2x2_less_than( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		uint2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		uint2_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 uint2x2_less_than_equal( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		uint2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint2_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x2 uint2x2_greater_than( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		uint2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		uint2_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 uint2x2_greater_than_equal( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		uint2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 uint2x2_cadds( const uint2x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cadds( &lhs->rows[0], rhs ),
		uint2_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint2x2 uint2x2_caddm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 uint2x2_csubs( const uint2x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_csubs( &lhs->rows[0], rhs ),
		uint2_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint2x2 uint2x2_csubm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 uint2x2_cmuls( const uint2x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cmuls( &lhs->rows[0], rhs ),
		uint2_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint2x2 uint2x2_cmulm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 uint2x2_cdivs( const uint2x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cdivs( &lhs->rows[0], rhs ),
		uint2_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint2x2 uint2x2_cdivm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE uint2x2 uint2x2_negate( const uint2x2* x )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_negate( &x->rows[0] ),
		uint2_negate( &x->rows[1] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE uint2x2 uint2x2_not( const uint2x2* x )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_not( &x->rows[0] ),
		uint2_not( &x->rows[1] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 uint2x2_cands( const uint2x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cands( &lhs->rows[0], rhs ),
		uint2_cands( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint2x2 uint2x2_candm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_candv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_candv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 uint2x2_cors( const uint2x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cors( &lhs->rows[0], rhs ),
		uint2_cors( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint2x2 uint2x2_corm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_corv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_corv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 uint2x2_cxors( const uint2x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cxors( &lhs->rows[0], rhs ),
		uint2_cxors( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint2x2 uint2x2_cxorm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cxorv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 uint2x2_cshift_lefts( const uint2x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cshift_lefts( &lhs->rows[0], rhs ),
		uint2_cshift_lefts( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint2x2 uint2x2_cshift_leftm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cshift_leftv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 uint2x2_cshift_rights( const uint2x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cshift_rights( &lhs->rows[0], rhs ),
		uint2_cshift_rights( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint2x2 uint2x2_cshift_rightm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		uint2_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cshift_rightv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void uint2x2_identity( uint2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint2x2 uint2x2_transpose( const uint2x2* mat )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint2x2 uint2x2_mulm( const uint2x2* lhs, const uint2x2* rhs )
{
	uint2 row0 = lhs->rows[0];
	uint2 row1 = lhs->rows[1];

	uint2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	uint2 col1 = { rhs->rows[0].y, rhs->rows[1].y };

	return HLML_CONSTRUCT( uint2x2 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE uint2 uint2x2_mulv( const uint2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		( lhs->x * rhs->rows[0].x ) + ( lhs->y * rhs->rows[1].x ),
		( lhs->x * rhs->rows[0].y ) + ( lhs->y * rhs->rows[1].y )
	};
}

// uint2x3
// Performs a uint2x3_min function on each row of the matrix.
HLML_INLINE uint2x3 uint2x3_min( const uint2x3* x, const uint2x3* y )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_min( &x->rows[0], &y->rows[0] ),
		uint3_min( &x->rows[1], &y->rows[1] )
	};
}

// Performs a uint2x3_max function on each row of the matrix.
HLML_INLINE uint2x3 uint2x3_max( const uint2x3* x, const uint2x3* y )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_max( &x->rows[0], &y->rows[0] ),
		uint3_max( &x->rows[1], &y->rows[1] )
	};
}

// Performs a uint2x3_clamp function on each row of the matrix.
HLML_INLINE uint2x3 uint2x3_clamp( const uint2x3* x, const uint2x3* low, const uint2x3* high )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		uint3_clamp( &x->rows[1], &low->rows[1], &high->rows[1] )
	};
}

// Performs a uint2x3_saturate function on each row of the matrix.
HLML_INLINE uint2x3 uint2x3_saturate( const uint2x3* x )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_saturate( &x->rows[0] ),
		uint3_saturate( &x->rows[1] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint2x3_equals( const uint2x3* lhs, const uint2x3* rhs )
{
	return
		uint3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		uint3_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint2x3_not_equals( const uint2x3* lhs, const uint2x3* rhs )
{
	return !uint2x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x3 uint2x3_less_than( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		uint3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		uint3_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 uint2x3_less_than_equal( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		uint3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint3_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x3 uint2x3_greater_than( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		uint3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		uint3_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 uint2x3_greater_than_equal( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		uint3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 uint2x3_cadds( const uint2x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cadds( &lhs->rows[0], rhs ),
		uint3_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint2x3 uint2x3_caddm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 uint2x3_csubs( const uint2x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_csubs( &lhs->rows[0], rhs ),
		uint3_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint2x3 uint2x3_csubm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 uint2x3_cmuls( const uint2x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cmuls( &lhs->rows[0], rhs ),
		uint3_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint2x3 uint2x3_cmulm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 uint2x3_cdivs( const uint2x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cdivs( &lhs->rows[0], rhs ),
		uint3_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint2x3 uint2x3_cdivm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE uint2x3 uint2x3_negate( const uint2x3* x )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_negate( &x->rows[0] ),
		uint3_negate( &x->rows[1] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE uint2x3 uint2x3_not( const uint2x3* x )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_not( &x->rows[0] ),
		uint3_not( &x->rows[1] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 uint2x3_cands( const uint2x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cands( &lhs->rows[0], rhs ),
		uint3_cands( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint2x3 uint2x3_candm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_candv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_candv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 uint2x3_cors( const uint2x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cors( &lhs->rows[0], rhs ),
		uint3_cors( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint2x3 uint2x3_corm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_corv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_corv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 uint2x3_cxors( const uint2x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cxors( &lhs->rows[0], rhs ),
		uint3_cxors( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint2x3 uint2x3_cxorm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cxorv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 uint2x3_cshift_lefts( const uint2x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cshift_lefts( &lhs->rows[0], rhs ),
		uint3_cshift_lefts( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint2x3 uint2x3_cshift_leftm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cshift_leftv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 uint2x3_cshift_rights( const uint2x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cshift_rights( &lhs->rows[0], rhs ),
		uint3_cshift_rights( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint2x3 uint2x3_cshift_rightm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		uint3_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cshift_rightv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void uint2x3_identity( uint2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint3x2 uint2x3_transpose( const uint2x3* mat )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint2x2 uint2x3_mulm( const uint2x3* lhs, const uint3x2* rhs )
{
	uint3 row0 = lhs->rows[0];
	uint3 row1 = lhs->rows[1];

	uint3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	uint3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };

	return HLML_CONSTRUCT( uint2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

// uint2x4
// Performs a uint2x4_min function on each row of the matrix.
HLML_INLINE uint2x4 uint2x4_min( const uint2x4* x, const uint2x4* y )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_min( &x->rows[0], &y->rows[0] ),
		uint4_min( &x->rows[1], &y->rows[1] )
	};
}

// Performs a uint2x4_max function on each row of the matrix.
HLML_INLINE uint2x4 uint2x4_max( const uint2x4* x, const uint2x4* y )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_max( &x->rows[0], &y->rows[0] ),
		uint4_max( &x->rows[1], &y->rows[1] )
	};
}

// Performs a uint2x4_clamp function on each row of the matrix.
HLML_INLINE uint2x4 uint2x4_clamp( const uint2x4* x, const uint2x4* low, const uint2x4* high )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		uint4_clamp( &x->rows[1], &low->rows[1], &high->rows[1] )
	};
}

// Performs a uint2x4_saturate function on each row of the matrix.
HLML_INLINE uint2x4 uint2x4_saturate( const uint2x4* x )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_saturate( &x->rows[0] ),
		uint4_saturate( &x->rows[1] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint2x4_equals( const uint2x4* lhs, const uint2x4* rhs )
{
	return
		uint4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		uint4_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint2x4_not_equals( const uint2x4* lhs, const uint2x4* rhs )
{
	return !uint2x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x4 uint2x4_less_than( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		uint4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		uint4_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 uint2x4_less_than_equal( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		uint4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint4_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x4 uint2x4_greater_than( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		uint4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		uint4_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 uint2x4_greater_than_equal( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		uint4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 uint2x4_cadds( const uint2x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cadds( &lhs->rows[0], rhs ),
		uint4_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint2x4 uint2x4_caddm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 uint2x4_csubs( const uint2x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_csubs( &lhs->rows[0], rhs ),
		uint4_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint2x4 uint2x4_csubm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 uint2x4_cmuls( const uint2x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cmuls( &lhs->rows[0], rhs ),
		uint4_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint2x4 uint2x4_cmulm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 uint2x4_cdivs( const uint2x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cdivs( &lhs->rows[0], rhs ),
		uint4_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint2x4 uint2x4_cdivm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE uint2x4 uint2x4_negate( const uint2x4* x )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_negate( &x->rows[0] ),
		uint4_negate( &x->rows[1] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE uint2x4 uint2x4_not( const uint2x4* x )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_not( &x->rows[0] ),
		uint4_not( &x->rows[1] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 uint2x4_cands( const uint2x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cands( &lhs->rows[0], rhs ),
		uint4_cands( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint2x4 uint2x4_candm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_candv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_candv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 uint2x4_cors( const uint2x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cors( &lhs->rows[0], rhs ),
		uint4_cors( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint2x4 uint2x4_corm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_corv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_corv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 uint2x4_cxors( const uint2x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cxors( &lhs->rows[0], rhs ),
		uint4_cxors( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint2x4 uint2x4_cxorm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cxorv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 uint2x4_cshift_lefts( const uint2x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cshift_lefts( &lhs->rows[0], rhs ),
		uint4_cshift_lefts( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint2x4 uint2x4_cshift_leftm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cshift_leftv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 uint2x4_cshift_rights( const uint2x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cshift_rights( &lhs->rows[0], rhs ),
		uint4_cshift_rights( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint2x4 uint2x4_cshift_rightm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		uint4_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cshift_rightv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void uint2x4_identity( uint2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint4x2 uint2x4_transpose( const uint2x4* mat )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint2x2 uint2x4_mulm( const uint2x4* lhs, const uint4x2* rhs )
{
	uint4 row0 = lhs->rows[0];
	uint4 row1 = lhs->rows[1];

	uint4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	uint4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };

	return HLML_CONSTRUCT( uint2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

// uint3x2
// Performs a uint3x2_min function on each row of the matrix.
HLML_INLINE uint3x2 uint3x2_min( const uint3x2* x, const uint3x2* y )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_min( &x->rows[0], &y->rows[0] ),
		uint2_min( &x->rows[1], &y->rows[1] ),
		uint2_min( &x->rows[2], &y->rows[2] )
	};
}

// Performs a uint3x2_max function on each row of the matrix.
HLML_INLINE uint3x2 uint3x2_max( const uint3x2* x, const uint3x2* y )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_max( &x->rows[0], &y->rows[0] ),
		uint2_max( &x->rows[1], &y->rows[1] ),
		uint2_max( &x->rows[2], &y->rows[2] )
	};
}

// Performs a uint3x2_clamp function on each row of the matrix.
HLML_INLINE uint3x2 uint3x2_clamp( const uint3x2* x, const uint3x2* low, const uint3x2* high )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		uint2_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		uint2_clamp( &x->rows[2], &low->rows[2], &high->rows[2] )
	};
}

// Performs a uint3x2_saturate function on each row of the matrix.
HLML_INLINE uint3x2 uint3x2_saturate( const uint3x2* x )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_saturate( &x->rows[0] ),
		uint2_saturate( &x->rows[1] ),
		uint2_saturate( &x->rows[2] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint3x2_equals( const uint3x2* lhs, const uint3x2* rhs )
{
	return
		uint2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		uint2_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		uint2_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint3x2_not_equals( const uint3x2* lhs, const uint3x2* rhs )
{
	return !uint3x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x2 uint3x2_less_than( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		uint2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		uint2_less_than( &lhs->rows[1], &rhs->rows[1] ),
		uint2_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 uint3x2_less_than_equal( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		uint2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint2_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		uint2_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x2 uint3x2_greater_than( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		uint2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		uint2_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		uint2_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 uint3x2_greater_than_equal( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		uint2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		uint2_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 uint3x2_cadds( const uint3x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cadds( &lhs->rows[0], rhs ),
		uint2_cadds( &lhs->rows[1], rhs ),
		uint2_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint3x2 uint3x2_caddm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 uint3x2_csubs( const uint3x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_csubs( &lhs->rows[0], rhs ),
		uint2_csubs( &lhs->rows[1], rhs ),
		uint2_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint3x2 uint3x2_csubm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 uint3x2_cmuls( const uint3x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cmuls( &lhs->rows[0], rhs ),
		uint2_cmuls( &lhs->rows[1], rhs ),
		uint2_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint3x2 uint3x2_cmulm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 uint3x2_cdivs( const uint3x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cdivs( &lhs->rows[0], rhs ),
		uint2_cdivs( &lhs->rows[1], rhs ),
		uint2_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint3x2 uint3x2_cdivm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE uint3x2 uint3x2_negate( const uint3x2* x )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_negate( &x->rows[0] ),
		uint2_negate( &x->rows[1] ),
		uint2_negate( &x->rows[2] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE uint3x2 uint3x2_not( const uint3x2* x )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_not( &x->rows[0] ),
		uint2_not( &x->rows[1] ),
		uint2_not( &x->rows[2] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 uint3x2_cands( const uint3x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cands( &lhs->rows[0], rhs ),
		uint2_cands( &lhs->rows[1], rhs ),
		uint2_cands( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint3x2 uint3x2_candm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_candv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_candv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_candv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 uint3x2_cors( const uint3x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cors( &lhs->rows[0], rhs ),
		uint2_cors( &lhs->rows[1], rhs ),
		uint2_cors( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint3x2 uint3x2_corm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_corv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_corv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_corv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 uint3x2_cxors( const uint3x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cxors( &lhs->rows[0], rhs ),
		uint2_cxors( &lhs->rows[1], rhs ),
		uint2_cxors( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint3x2 uint3x2_cxorm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cxorv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cxorv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 uint3x2_cshift_lefts( const uint3x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cshift_lefts( &lhs->rows[0], rhs ),
		uint2_cshift_lefts( &lhs->rows[1], rhs ),
		uint2_cshift_lefts( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint3x2 uint3x2_cshift_leftm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cshift_leftv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cshift_leftv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 uint3x2_cshift_rights( const uint3x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cshift_rights( &lhs->rows[0], rhs ),
		uint2_cshift_rights( &lhs->rows[1], rhs ),
		uint2_cshift_rights( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint3x2 uint3x2_cshift_rightm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		uint2_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cshift_rightv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cshift_rightv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void uint3x2_identity( uint3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
	mat->rows[2] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint2x3 uint3x2_transpose( const uint3x2* mat )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint3x3 uint3x2_mulm( const uint3x2* lhs, const uint2x3* rhs )
{
	uint2 row0 = lhs->rows[0];
	uint2 row1 = lhs->rows[1];
	uint2 row2 = lhs->rows[2];

	uint2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	uint2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	uint2 col2 = { rhs->rows[0].z, rhs->rows[1].z };

	return HLML_CONSTRUCT( uint3x3 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

// uint3x3
// Performs a uint3x3_min function on each row of the matrix.
HLML_INLINE uint3x3 uint3x3_min( const uint3x3* x, const uint3x3* y )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_min( &x->rows[0], &y->rows[0] ),
		uint3_min( &x->rows[1], &y->rows[1] ),
		uint3_min( &x->rows[2], &y->rows[2] )
	};
}

// Performs a uint3x3_max function on each row of the matrix.
HLML_INLINE uint3x3 uint3x3_max( const uint3x3* x, const uint3x3* y )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_max( &x->rows[0], &y->rows[0] ),
		uint3_max( &x->rows[1], &y->rows[1] ),
		uint3_max( &x->rows[2], &y->rows[2] )
	};
}

// Performs a uint3x3_clamp function on each row of the matrix.
HLML_INLINE uint3x3 uint3x3_clamp( const uint3x3* x, const uint3x3* low, const uint3x3* high )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		uint3_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		uint3_clamp( &x->rows[2], &low->rows[2], &high->rows[2] )
	};
}

// Performs a uint3x3_saturate function on each row of the matrix.
HLML_INLINE uint3x3 uint3x3_saturate( const uint3x3* x )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_saturate( &x->rows[0] ),
		uint3_saturate( &x->rows[1] ),
		uint3_saturate( &x->rows[2] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint3x3_equals( const uint3x3* lhs, const uint3x3* rhs )
{
	return
		uint3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		uint3_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		uint3_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint3x3_not_equals( const uint3x3* lhs, const uint3x3* rhs )
{
	return !uint3x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x3 uint3x3_less_than( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		uint3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		uint3_less_than( &lhs->rows[1], &rhs->rows[1] ),
		uint3_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 uint3x3_less_than_equal( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		uint3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint3_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		uint3_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x3 uint3x3_greater_than( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		uint3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		uint3_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		uint3_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 uint3x3_greater_than_equal( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		uint3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		uint3_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 uint3x3_cadds( const uint3x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cadds( &lhs->rows[0], rhs ),
		uint3_cadds( &lhs->rows[1], rhs ),
		uint3_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint3x3 uint3x3_caddm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 uint3x3_csubs( const uint3x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_csubs( &lhs->rows[0], rhs ),
		uint3_csubs( &lhs->rows[1], rhs ),
		uint3_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint3x3 uint3x3_csubm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 uint3x3_cmuls( const uint3x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cmuls( &lhs->rows[0], rhs ),
		uint3_cmuls( &lhs->rows[1], rhs ),
		uint3_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint3x3 uint3x3_cmulm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 uint3x3_cdivs( const uint3x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cdivs( &lhs->rows[0], rhs ),
		uint3_cdivs( &lhs->rows[1], rhs ),
		uint3_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint3x3 uint3x3_cdivm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE uint3x3 uint3x3_negate( const uint3x3* x )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_negate( &x->rows[0] ),
		uint3_negate( &x->rows[1] ),
		uint3_negate( &x->rows[2] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE uint3x3 uint3x3_not( const uint3x3* x )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_not( &x->rows[0] ),
		uint3_not( &x->rows[1] ),
		uint3_not( &x->rows[2] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 uint3x3_cands( const uint3x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cands( &lhs->rows[0], rhs ),
		uint3_cands( &lhs->rows[1], rhs ),
		uint3_cands( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint3x3 uint3x3_candm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_candv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_candv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_candv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 uint3x3_cors( const uint3x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cors( &lhs->rows[0], rhs ),
		uint3_cors( &lhs->rows[1], rhs ),
		uint3_cors( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint3x3 uint3x3_corm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_corv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_corv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_corv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 uint3x3_cxors( const uint3x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cxors( &lhs->rows[0], rhs ),
		uint3_cxors( &lhs->rows[1], rhs ),
		uint3_cxors( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint3x3 uint3x3_cxorm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cxorv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cxorv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 uint3x3_cshift_lefts( const uint3x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cshift_lefts( &lhs->rows[0], rhs ),
		uint3_cshift_lefts( &lhs->rows[1], rhs ),
		uint3_cshift_lefts( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint3x3 uint3x3_cshift_leftm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cshift_leftv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cshift_leftv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 uint3x3_cshift_rights( const uint3x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cshift_rights( &lhs->rows[0], rhs ),
		uint3_cshift_rights( &lhs->rows[1], rhs ),
		uint3_cshift_rights( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint3x3 uint3x3_cshift_rightm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		uint3_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cshift_rightv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cshift_rightv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void uint3x3_identity( uint3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
	mat->rows[2] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 1U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint3x3 uint3x3_transpose( const uint3x3* mat )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint3x3 uint3x3_mulm( const uint3x3* lhs, const uint3x3* rhs )
{
	uint3 row0 = lhs->rows[0];
	uint3 row1 = lhs->rows[1];
	uint3 row2 = lhs->rows[2];

	uint3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	uint3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	uint3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };

	return HLML_CONSTRUCT( uint3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE uint3 uint3x3_mulv( const uint3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		( lhs->x * rhs->rows[0].x ) + ( lhs->y * rhs->rows[1].x ) + ( lhs->z * rhs->rows[2].x ),
		( lhs->x * rhs->rows[0].y ) + ( lhs->y * rhs->rows[1].y ) + ( lhs->z * rhs->rows[2].y ),
		( lhs->x * rhs->rows[0].z ) + ( lhs->y * rhs->rows[1].z ) + ( lhs->z * rhs->rows[2].z )
	};
}

// uint3x4
// Performs a uint3x4_min function on each row of the matrix.
HLML_INLINE uint3x4 uint3x4_min( const uint3x4* x, const uint3x4* y )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_min( &x->rows[0], &y->rows[0] ),
		uint4_min( &x->rows[1], &y->rows[1] ),
		uint4_min( &x->rows[2], &y->rows[2] )
	};
}

// Performs a uint3x4_max function on each row of the matrix.
HLML_INLINE uint3x4 uint3x4_max( const uint3x4* x, const uint3x4* y )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_max( &x->rows[0], &y->rows[0] ),
		uint4_max( &x->rows[1], &y->rows[1] ),
		uint4_max( &x->rows[2], &y->rows[2] )
	};
}

// Performs a uint3x4_clamp function on each row of the matrix.
HLML_INLINE uint3x4 uint3x4_clamp( const uint3x4* x, const uint3x4* low, const uint3x4* high )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		uint4_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		uint4_clamp( &x->rows[2], &low->rows[2], &high->rows[2] )
	};
}

// Performs a uint3x4_saturate function on each row of the matrix.
HLML_INLINE uint3x4 uint3x4_saturate( const uint3x4* x )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_saturate( &x->rows[0] ),
		uint4_saturate( &x->rows[1] ),
		uint4_saturate( &x->rows[2] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint3x4_equals( const uint3x4* lhs, const uint3x4* rhs )
{
	return
		uint4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		uint4_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		uint4_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint3x4_not_equals( const uint3x4* lhs, const uint3x4* rhs )
{
	return !uint3x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x4 uint3x4_less_than( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		uint4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		uint4_less_than( &lhs->rows[1], &rhs->rows[1] ),
		uint4_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 uint3x4_less_than_equal( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		uint4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint4_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		uint4_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x4 uint3x4_greater_than( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		uint4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		uint4_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		uint4_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 uint3x4_greater_than_equal( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		uint4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		uint4_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 uint3x4_cadds( const uint3x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cadds( &lhs->rows[0], rhs ),
		uint4_cadds( &lhs->rows[1], rhs ),
		uint4_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint3x4 uint3x4_caddm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 uint3x4_csubs( const uint3x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_csubs( &lhs->rows[0], rhs ),
		uint4_csubs( &lhs->rows[1], rhs ),
		uint4_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint3x4 uint3x4_csubm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 uint3x4_cmuls( const uint3x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cmuls( &lhs->rows[0], rhs ),
		uint4_cmuls( &lhs->rows[1], rhs ),
		uint4_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint3x4 uint3x4_cmulm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 uint3x4_cdivs( const uint3x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cdivs( &lhs->rows[0], rhs ),
		uint4_cdivs( &lhs->rows[1], rhs ),
		uint4_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint3x4 uint3x4_cdivm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE uint3x4 uint3x4_negate( const uint3x4* x )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_negate( &x->rows[0] ),
		uint4_negate( &x->rows[1] ),
		uint4_negate( &x->rows[2] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE uint3x4 uint3x4_not( const uint3x4* x )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_not( &x->rows[0] ),
		uint4_not( &x->rows[1] ),
		uint4_not( &x->rows[2] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 uint3x4_cands( const uint3x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cands( &lhs->rows[0], rhs ),
		uint4_cands( &lhs->rows[1], rhs ),
		uint4_cands( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint3x4 uint3x4_candm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_candv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_candv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_candv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 uint3x4_cors( const uint3x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cors( &lhs->rows[0], rhs ),
		uint4_cors( &lhs->rows[1], rhs ),
		uint4_cors( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint3x4 uint3x4_corm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_corv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_corv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_corv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 uint3x4_cxors( const uint3x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cxors( &lhs->rows[0], rhs ),
		uint4_cxors( &lhs->rows[1], rhs ),
		uint4_cxors( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint3x4 uint3x4_cxorm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cxorv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cxorv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 uint3x4_cshift_lefts( const uint3x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cshift_lefts( &lhs->rows[0], rhs ),
		uint4_cshift_lefts( &lhs->rows[1], rhs ),
		uint4_cshift_lefts( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint3x4 uint3x4_cshift_leftm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cshift_leftv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cshift_leftv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 uint3x4_cshift_rights( const uint3x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cshift_rights( &lhs->rows[0], rhs ),
		uint4_cshift_rights( &lhs->rows[1], rhs ),
		uint4_cshift_rights( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint3x4 uint3x4_cshift_rightm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		uint4_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cshift_rightv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cshift_rightv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void uint3x4_identity( uint3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
	mat->rows[2] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 1U, 0U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint4x3 uint3x4_transpose( const uint3x4* mat )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint3x3 uint3x4_mulm( const uint3x4* lhs, const uint4x3* rhs )
{
	uint4 row0 = lhs->rows[0];
	uint4 row1 = lhs->rows[1];
	uint4 row2 = lhs->rows[2];

	uint4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	uint4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	uint4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };

	return HLML_CONSTRUCT( uint3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

// uint4x2
// Performs a uint4x2_min function on each row of the matrix.
HLML_INLINE uint4x2 uint4x2_min( const uint4x2* x, const uint4x2* y )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_min( &x->rows[0], &y->rows[0] ),
		uint2_min( &x->rows[1], &y->rows[1] ),
		uint2_min( &x->rows[2], &y->rows[2] ),
		uint2_min( &x->rows[3], &y->rows[3] )
	};
}

// Performs a uint4x2_max function on each row of the matrix.
HLML_INLINE uint4x2 uint4x2_max( const uint4x2* x, const uint4x2* y )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_max( &x->rows[0], &y->rows[0] ),
		uint2_max( &x->rows[1], &y->rows[1] ),
		uint2_max( &x->rows[2], &y->rows[2] ),
		uint2_max( &x->rows[3], &y->rows[3] )
	};
}

// Performs a uint4x2_clamp function on each row of the matrix.
HLML_INLINE uint4x2 uint4x2_clamp( const uint4x2* x, const uint4x2* low, const uint4x2* high )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		uint2_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		uint2_clamp( &x->rows[2], &low->rows[2], &high->rows[2] ),
		uint2_clamp( &x->rows[3], &low->rows[3], &high->rows[3] )
	};
}

// Performs a uint4x2_saturate function on each row of the matrix.
HLML_INLINE uint4x2 uint4x2_saturate( const uint4x2* x )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_saturate( &x->rows[0] ),
		uint2_saturate( &x->rows[1] ),
		uint2_saturate( &x->rows[2] ),
		uint2_saturate( &x->rows[3] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint4x2_equals( const uint4x2* lhs, const uint4x2* rhs )
{
	return
		uint2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		uint2_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		uint2_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		uint2_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint4x2_not_equals( const uint4x2* lhs, const uint4x2* rhs )
{
	return !uint4x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x2 uint4x2_less_than( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		uint2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		uint2_less_than( &lhs->rows[1], &rhs->rows[1] ),
		uint2_less_than( &lhs->rows[2], &rhs->rows[2] ),
		uint2_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 uint4x2_less_than_equal( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		uint2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint2_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		uint2_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		uint2_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x2 uint4x2_greater_than( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		uint2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		uint2_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		uint2_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		uint2_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 uint4x2_greater_than_equal( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		uint2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		uint2_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		uint2_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 uint4x2_cadds( const uint4x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cadds( &lhs->rows[0], rhs ),
		uint2_cadds( &lhs->rows[1], rhs ),
		uint2_cadds( &lhs->rows[2], rhs ),
		uint2_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint4x2 uint4x2_caddm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_caddv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 uint4x2_csubs( const uint4x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_csubs( &lhs->rows[0], rhs ),
		uint2_csubs( &lhs->rows[1], rhs ),
		uint2_csubs( &lhs->rows[2], rhs ),
		uint2_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint4x2 uint4x2_csubm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_csubv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 uint4x2_cmuls( const uint4x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cmuls( &lhs->rows[0], rhs ),
		uint2_cmuls( &lhs->rows[1], rhs ),
		uint2_cmuls( &lhs->rows[2], rhs ),
		uint2_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint4x2 uint4x2_cmulm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 uint4x2_cdivs( const uint4x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cdivs( &lhs->rows[0], rhs ),
		uint2_cdivs( &lhs->rows[1], rhs ),
		uint2_cdivs( &lhs->rows[2], rhs ),
		uint2_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint4x2 uint4x2_cdivm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE uint4x2 uint4x2_negate( const uint4x2* x )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_negate( &x->rows[0] ),
		uint2_negate( &x->rows[1] ),
		uint2_negate( &x->rows[2] ),
		uint2_negate( &x->rows[3] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE uint4x2 uint4x2_not( const uint4x2* x )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_not( &x->rows[0] ),
		uint2_not( &x->rows[1] ),
		uint2_not( &x->rows[2] ),
		uint2_not( &x->rows[3] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 uint4x2_cands( const uint4x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cands( &lhs->rows[0], rhs ),
		uint2_cands( &lhs->rows[1], rhs ),
		uint2_cands( &lhs->rows[2], rhs ),
		uint2_cands( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint4x2 uint4x2_candm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_candv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_candv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_candv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_candv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 uint4x2_cors( const uint4x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cors( &lhs->rows[0], rhs ),
		uint2_cors( &lhs->rows[1], rhs ),
		uint2_cors( &lhs->rows[2], rhs ),
		uint2_cors( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint4x2 uint4x2_corm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_corv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_corv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_corv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_corv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 uint4x2_cxors( const uint4x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cxors( &lhs->rows[0], rhs ),
		uint2_cxors( &lhs->rows[1], rhs ),
		uint2_cxors( &lhs->rows[2], rhs ),
		uint2_cxors( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint4x2 uint4x2_cxorm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cxorv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cxorv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cxorv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 uint4x2_cshift_lefts( const uint4x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cshift_lefts( &lhs->rows[0], rhs ),
		uint2_cshift_lefts( &lhs->rows[1], rhs ),
		uint2_cshift_lefts( &lhs->rows[2], rhs ),
		uint2_cshift_lefts( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint4x2 uint4x2_cshift_leftm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cshift_leftv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cshift_leftv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cshift_leftv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 uint4x2_cshift_rights( const uint4x2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cshift_rights( &lhs->rows[0], rhs ),
		uint2_cshift_rights( &lhs->rows[1], rhs ),
		uint2_cshift_rights( &lhs->rows[2], rhs ),
		uint2_cshift_rights( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint4x2 uint4x2_cshift_rightm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		uint2_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cshift_rightv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cshift_rightv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cshift_rightv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void uint4x2_identity( uint4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
	mat->rows[2] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
	mat->rows[3] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint2x4 uint4x2_transpose( const uint4x2* mat )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint4x4 uint4x2_mulm( const uint4x2* lhs, const uint2x4* rhs )
{
	uint2 row0 = lhs->rows[0];
	uint2 row1 = lhs->rows[1];
	uint2 row2 = lhs->rows[2];
	uint2 row3 = lhs->rows[3];

	uint2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	uint2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	uint2 col2 = { rhs->rows[0].z, rhs->rows[1].z };
	uint2 col3 = { rhs->rows[0].w, rhs->rows[1].w };

	return HLML_CONSTRUCT( uint4x4 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

// uint4x3
// Performs a uint4x3_min function on each row of the matrix.
HLML_INLINE uint4x3 uint4x3_min( const uint4x3* x, const uint4x3* y )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_min( &x->rows[0], &y->rows[0] ),
		uint3_min( &x->rows[1], &y->rows[1] ),
		uint3_min( &x->rows[2], &y->rows[2] ),
		uint3_min( &x->rows[3], &y->rows[3] )
	};
}

// Performs a uint4x3_max function on each row of the matrix.
HLML_INLINE uint4x3 uint4x3_max( const uint4x3* x, const uint4x3* y )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_max( &x->rows[0], &y->rows[0] ),
		uint3_max( &x->rows[1], &y->rows[1] ),
		uint3_max( &x->rows[2], &y->rows[2] ),
		uint3_max( &x->rows[3], &y->rows[3] )
	};
}

// Performs a uint4x3_clamp function on each row of the matrix.
HLML_INLINE uint4x3 uint4x3_clamp( const uint4x3* x, const uint4x3* low, const uint4x3* high )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		uint3_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		uint3_clamp( &x->rows[2], &low->rows[2], &high->rows[2] ),
		uint3_clamp( &x->rows[3], &low->rows[3], &high->rows[3] )
	};
}

// Performs a uint4x3_saturate function on each row of the matrix.
HLML_INLINE uint4x3 uint4x3_saturate( const uint4x3* x )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_saturate( &x->rows[0] ),
		uint3_saturate( &x->rows[1] ),
		uint3_saturate( &x->rows[2] ),
		uint3_saturate( &x->rows[3] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint4x3_equals( const uint4x3* lhs, const uint4x3* rhs )
{
	return
		uint3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		uint3_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		uint3_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		uint3_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint4x3_not_equals( const uint4x3* lhs, const uint4x3* rhs )
{
	return !uint4x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x3 uint4x3_less_than( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		uint3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		uint3_less_than( &lhs->rows[1], &rhs->rows[1] ),
		uint3_less_than( &lhs->rows[2], &rhs->rows[2] ),
		uint3_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 uint4x3_less_than_equal( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		uint3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint3_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		uint3_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		uint3_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x3 uint4x3_greater_than( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		uint3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		uint3_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		uint3_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		uint3_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 uint4x3_greater_than_equal( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		uint3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		uint3_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		uint3_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 uint4x3_cadds( const uint4x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cadds( &lhs->rows[0], rhs ),
		uint3_cadds( &lhs->rows[1], rhs ),
		uint3_cadds( &lhs->rows[2], rhs ),
		uint3_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint4x3 uint4x3_caddm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_caddv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 uint4x3_csubs( const uint4x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_csubs( &lhs->rows[0], rhs ),
		uint3_csubs( &lhs->rows[1], rhs ),
		uint3_csubs( &lhs->rows[2], rhs ),
		uint3_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint4x3 uint4x3_csubm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_csubv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 uint4x3_cmuls( const uint4x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cmuls( &lhs->rows[0], rhs ),
		uint3_cmuls( &lhs->rows[1], rhs ),
		uint3_cmuls( &lhs->rows[2], rhs ),
		uint3_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint4x3 uint4x3_cmulm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 uint4x3_cdivs( const uint4x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cdivs( &lhs->rows[0], rhs ),
		uint3_cdivs( &lhs->rows[1], rhs ),
		uint3_cdivs( &lhs->rows[2], rhs ),
		uint3_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint4x3 uint4x3_cdivm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE uint4x3 uint4x3_negate( const uint4x3* x )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_negate( &x->rows[0] ),
		uint3_negate( &x->rows[1] ),
		uint3_negate( &x->rows[2] ),
		uint3_negate( &x->rows[3] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE uint4x3 uint4x3_not( const uint4x3* x )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_not( &x->rows[0] ),
		uint3_not( &x->rows[1] ),
		uint3_not( &x->rows[2] ),
		uint3_not( &x->rows[3] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 uint4x3_cands( const uint4x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cands( &lhs->rows[0], rhs ),
		uint3_cands( &lhs->rows[1], rhs ),
		uint3_cands( &lhs->rows[2], rhs ),
		uint3_cands( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint4x3 uint4x3_candm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_candv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_candv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_candv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_candv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 uint4x3_cors( const uint4x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cors( &lhs->rows[0], rhs ),
		uint3_cors( &lhs->rows[1], rhs ),
		uint3_cors( &lhs->rows[2], rhs ),
		uint3_cors( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint4x3 uint4x3_corm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_corv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_corv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_corv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_corv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 uint4x3_cxors( const uint4x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cxors( &lhs->rows[0], rhs ),
		uint3_cxors( &lhs->rows[1], rhs ),
		uint3_cxors( &lhs->rows[2], rhs ),
		uint3_cxors( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint4x3 uint4x3_cxorm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cxorv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cxorv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cxorv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 uint4x3_cshift_lefts( const uint4x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cshift_lefts( &lhs->rows[0], rhs ),
		uint3_cshift_lefts( &lhs->rows[1], rhs ),
		uint3_cshift_lefts( &lhs->rows[2], rhs ),
		uint3_cshift_lefts( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint4x3 uint4x3_cshift_leftm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cshift_leftv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cshift_leftv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cshift_leftv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 uint4x3_cshift_rights( const uint4x3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cshift_rights( &lhs->rows[0], rhs ),
		uint3_cshift_rights( &lhs->rows[1], rhs ),
		uint3_cshift_rights( &lhs->rows[2], rhs ),
		uint3_cshift_rights( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint4x3 uint4x3_cshift_rightm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		uint3_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cshift_rightv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cshift_rightv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cshift_rightv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void uint4x3_identity( uint4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
	mat->rows[2] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 1U };
	mat->rows[3] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 0U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint3x4 uint4x3_transpose( const uint4x3* mat )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint4x4 uint4x3_mulm( const uint4x3* lhs, const uint3x4* rhs )
{
	uint3 row0 = lhs->rows[0];
	uint3 row1 = lhs->rows[1];
	uint3 row2 = lhs->rows[2];
	uint3 row3 = lhs->rows[3];

	uint3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	uint3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	uint3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };
	uint3 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w };

	return HLML_CONSTRUCT( uint4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

// uint4x4
// Performs a uint4x4_min function on each row of the matrix.
HLML_INLINE uint4x4 uint4x4_min( const uint4x4* x, const uint4x4* y )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_min( &x->rows[0], &y->rows[0] ),
		uint4_min( &x->rows[1], &y->rows[1] ),
		uint4_min( &x->rows[2], &y->rows[2] ),
		uint4_min( &x->rows[3], &y->rows[3] )
	};
}

// Performs a uint4x4_max function on each row of the matrix.
HLML_INLINE uint4x4 uint4x4_max( const uint4x4* x, const uint4x4* y )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_max( &x->rows[0], &y->rows[0] ),
		uint4_max( &x->rows[1], &y->rows[1] ),
		uint4_max( &x->rows[2], &y->rows[2] ),
		uint4_max( &x->rows[3], &y->rows[3] )
	};
}

// Performs a uint4x4_clamp function on each row of the matrix.
HLML_INLINE uint4x4 uint4x4_clamp( const uint4x4* x, const uint4x4* low, const uint4x4* high )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		uint4_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		uint4_clamp( &x->rows[2], &low->rows[2], &high->rows[2] ),
		uint4_clamp( &x->rows[3], &low->rows[3], &high->rows[3] )
	};
}

// Performs a uint4x4_saturate function on each row of the matrix.
HLML_INLINE uint4x4 uint4x4_saturate( const uint4x4* x )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_saturate( &x->rows[0] ),
		uint4_saturate( &x->rows[1] ),
		uint4_saturate( &x->rows[2] ),
		uint4_saturate( &x->rows[3] )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint4x4_equals( const uint4x4* lhs, const uint4x4* rhs )
{
	return
		uint4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		uint4_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		uint4_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		uint4_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint4x4_not_equals( const uint4x4* lhs, const uint4x4* rhs )
{
	return !uint4x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x4 uint4x4_less_than( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		uint4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		uint4_less_than( &lhs->rows[1], &rhs->rows[1] ),
		uint4_less_than( &lhs->rows[2], &rhs->rows[2] ),
		uint4_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 uint4x4_less_than_equal( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		uint4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint4_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		uint4_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		uint4_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x4 uint4x4_greater_than( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		uint4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		uint4_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		uint4_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		uint4_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 uint4x4_greater_than_equal( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		uint4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		uint4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		uint4_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		uint4_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 uint4x4_cadds( const uint4x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cadds( &lhs->rows[0], rhs ),
		uint4_cadds( &lhs->rows[1], rhs ),
		uint4_cadds( &lhs->rows[2], rhs ),
		uint4_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint4x4 uint4x4_caddm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_caddv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 uint4x4_csubs( const uint4x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_csubs( &lhs->rows[0], rhs ),
		uint4_csubs( &lhs->rows[1], rhs ),
		uint4_csubs( &lhs->rows[2], rhs ),
		uint4_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint4x4 uint4x4_csubm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_csubv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 uint4x4_cmuls( const uint4x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cmuls( &lhs->rows[0], rhs ),
		uint4_cmuls( &lhs->rows[1], rhs ),
		uint4_cmuls( &lhs->rows[2], rhs ),
		uint4_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint4x4 uint4x4_cmulm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 uint4x4_cdivs( const uint4x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cdivs( &lhs->rows[0], rhs ),
		uint4_cdivs( &lhs->rows[1], rhs ),
		uint4_cdivs( &lhs->rows[2], rhs ),
		uint4_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint4x4 uint4x4_cdivm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE uint4x4 uint4x4_negate( const uint4x4* x )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_negate( &x->rows[0] ),
		uint4_negate( &x->rows[1] ),
		uint4_negate( &x->rows[2] ),
		uint4_negate( &x->rows[3] )
	};
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
HLML_INLINE uint4x4 uint4x4_not( const uint4x4* x )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_not( &x->rows[0] ),
		uint4_not( &x->rows[1] ),
		uint4_not( &x->rows[2] ),
		uint4_not( &x->rows[3] )
	};
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 uint4x4_cands( const uint4x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cands( &lhs->rows[0], rhs ),
		uint4_cands( &lhs->rows[1], rhs ),
		uint4_cands( &lhs->rows[2], rhs ),
		uint4_cands( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint4x4 uint4x4_candm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_candv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_candv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_candv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_candv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 uint4x4_cors( const uint4x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cors( &lhs->rows[0], rhs ),
		uint4_cors( &lhs->rows[1], rhs ),
		uint4_cors( &lhs->rows[2], rhs ),
		uint4_cors( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint4x4 uint4x4_corm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_corv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_corv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_corv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_corv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 uint4x4_cxors( const uint4x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cxors( &lhs->rows[0], rhs ),
		uint4_cxors( &lhs->rows[1], rhs ),
		uint4_cxors( &lhs->rows[2], rhs ),
		uint4_cxors( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint4x4 uint4x4_cxorm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cxorv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cxorv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cxorv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cxorv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 uint4x4_cshift_lefts( const uint4x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cshift_lefts( &lhs->rows[0], rhs ),
		uint4_cshift_lefts( &lhs->rows[1], rhs ),
		uint4_cshift_lefts( &lhs->rows[2], rhs ),
		uint4_cshift_lefts( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint4x4 uint4x4_cshift_leftm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cshift_leftv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cshift_leftv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cshift_leftv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cshift_leftv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 uint4x4_cshift_rights( const uint4x4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cshift_rights( &lhs->rows[0], rhs ),
		uint4_cshift_rights( &lhs->rows[1], rhs ),
		uint4_cshift_rights( &lhs->rows[2], rhs ),
		uint4_cshift_rights( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint4x4 uint4x4_cshift_rightm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		uint4_cshift_rightv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cshift_rightv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cshift_rightv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cshift_rightv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void uint4x4_identity( uint4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
	mat->rows[2] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 1U, 0U };
	mat->rows[3] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 0U, 1U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint4x4 uint4x4_transpose( const uint4x4* mat )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint4x4 uint4x4_mulm( const uint4x4* lhs, const uint4x4* rhs )
{
	uint4 row0 = lhs->rows[0];
	uint4 row1 = lhs->rows[1];
	uint4 row2 = lhs->rows[2];
	uint4 row3 = lhs->rows[3];

	uint4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	uint4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	uint4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };
	uint4 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w, rhs->rows[3].w };

	return HLML_CONSTRUCT( uint4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE uint4 uint4x4_mulv( const uint4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		( lhs->x * rhs->rows[0].x ) + ( lhs->y * rhs->rows[1].x ) + ( lhs->z * rhs->rows[2].x ) + ( lhs->w * rhs->rows[3].x ),
		( lhs->x * rhs->rows[0].y ) + ( lhs->y * rhs->rows[1].y ) + ( lhs->z * rhs->rows[2].y ) + ( lhs->w * rhs->rows[3].y ),
		( lhs->x * rhs->rows[0].z ) + ( lhs->y * rhs->rows[1].z ) + ( lhs->z * rhs->rows[2].z ) + ( lhs->w * rhs->rows[3].z ),
		( lhs->x * rhs->rows[0].w ) + ( lhs->y * rhs->rows[1].w ) + ( lhs->z * rhs->rows[2].w ) + ( lhs->w * rhs->rows[3].w )
	};
}

// "Translates" the matrix.  Adds the last column of 'mat' by the position vector 'vec'.
HLML_INLINE uint4x4 uint4x4_translate( const uint4x4* mat, const uint3* vec )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z,
		mat->rows[3].x, mat->rows[3].y, mat->rows[3].z, mat->rows[3].w
	};
}

// Applies a non-uniform scale to the matrix and returns the result.
HLML_INLINE uint4x4 uint4x4_scale( const uint4x4* mat, const uint3* scale )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		mat->rows[0].x * scale->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * scale->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z * scale->z,
		mat->rows[2].w,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z,
		mat->rows[3].w
	};
}

// float2x2
// Performs a float2x2_sign function on each row of the matrix.
HLML_INLINE int2x2 float2x2_sign( const float2x2* x )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		float2_sign( &x->rows[0] ),
		float2_sign( &x->rows[1] )
	};
}

// Performs a float2x2_min function on each row of the matrix.
HLML_INLINE float2x2 float2x2_min( const float2x2* x, const float2x2* y )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_min( &x->rows[0], &y->rows[0] ),
		float2_min( &x->rows[1], &y->rows[1] )
	};
}

// Performs a float2x2_max function on each row of the matrix.
HLML_INLINE float2x2 float2x2_max( const float2x2* x, const float2x2* y )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_max( &x->rows[0], &y->rows[0] ),
		float2_max( &x->rows[1], &y->rows[1] )
	};
}

// Performs a float2x2_clamp function on each row of the matrix.
HLML_INLINE float2x2 float2x2_clamp( const float2x2* x, const float2x2* low, const float2x2* high )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		float2_clamp( &x->rows[1], &low->rows[1], &high->rows[1] )
	};
}

// Performs a float2x2_saturate function on each row of the matrix.
HLML_INLINE float2x2 float2x2_saturate( const float2x2* x )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_saturate( &x->rows[0] ),
		float2_saturate( &x->rows[1] )
	};
}

// Performs a float2x2_lerp function on each row of the matrix.
HLML_INLINE float2x2 float2x2_lerp( const float2x2* lhs, const float2x2* rhs, const float t )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		float2_lerp( &lhs->rows[1], &rhs->rows[1], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float2x2_equals( const float2x2* lhs, const float2x2* rhs )
{
	return
		float2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		float2_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float2x2_not_equals( const float2x2* lhs, const float2x2* rhs )
{
	return !float2x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x2 float2x2_less_than( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		float2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		float2_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 float2x2_less_than_equal( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		float2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float2_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x2 float2x2_greater_than( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		float2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		float2_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 float2x2_greater_than_equal( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		float2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float2x2 float2x2_cadds( const float2x2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_cadds( &lhs->rows[0], rhs ),
		float2_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float2x2 float2x2_caddm( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float2_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float2x2 float2x2_csubs( const float2x2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_csubs( &lhs->rows[0], rhs ),
		float2_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float2x2 float2x2_csubm( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float2_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float2x2 float2x2_cmuls( const float2x2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_cmuls( &lhs->rows[0], rhs ),
		float2_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float2x2 float2x2_cmulm( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float2x2 float2x2_cdivs( const float2x2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_cdivs( &lhs->rows[0], rhs ),
		float2_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float2x2 float2x2_cdivm( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float2_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE float2x2 float2x2_negate( const float2x2* x )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		float2_negate( &x->rows[0] ),
		float2_negate( &x->rows[1] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void float2x2_identity( float2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float2x2 float2x2_transpose( const float2x2* mat )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

// Returns the determinant of the matrix.
HLML_INLINE float float2x2_determinant( const float2x2* mat )
{
	return mat->rows[0].x * mat->rows[1].y - mat->rows[1].x * mat->rows[0].y;
}

// Returns a copy of the matrix that is inversed.
// This is only applicable for square matrices.
HLML_INLINE float2x2 float2x2_inverse( const float2x2* mat )
{
	const float invdet = 1.0f / float2x2_determinant( mat );
	return HLML_CONSTRUCT( float2x2 )
	{
		 mat->rows[1].y * invdet, -mat->rows[0].y * invdet,
		-mat->rows[1].x * invdet,  mat->rows[0].x * invdet
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float2x2 float2x2_mulm( const float2x2* lhs, const float2x2* rhs )
{
	float2 row0 = lhs->rows[0];
	float2 row1 = lhs->rows[1];

	float2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	float2 col1 = { rhs->rows[0].y, rhs->rows[1].y };

	return HLML_CONSTRUCT( float2x2 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE float2 float2x2_mulv( const float2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2 )
	{
		( lhs->x * rhs->rows[0].x ) + ( lhs->y * rhs->rows[1].x ),
		( lhs->x * rhs->rows[0].y ) + ( lhs->y * rhs->rows[1].y )
	};
}

// float2x3
// Performs a float2x3_sign function on each row of the matrix.
HLML_INLINE int2x3 float2x3_sign( const float2x3* x )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		float3_sign( &x->rows[0] ),
		float3_sign( &x->rows[1] )
	};
}

// Performs a float2x3_min function on each row of the matrix.
HLML_INLINE float2x3 float2x3_min( const float2x3* x, const float2x3* y )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_min( &x->rows[0], &y->rows[0] ),
		float3_min( &x->rows[1], &y->rows[1] )
	};
}

// Performs a float2x3_max function on each row of the matrix.
HLML_INLINE float2x3 float2x3_max( const float2x3* x, const float2x3* y )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_max( &x->rows[0], &y->rows[0] ),
		float3_max( &x->rows[1], &y->rows[1] )
	};
}

// Performs a float2x3_clamp function on each row of the matrix.
HLML_INLINE float2x3 float2x3_clamp( const float2x3* x, const float2x3* low, const float2x3* high )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		float3_clamp( &x->rows[1], &low->rows[1], &high->rows[1] )
	};
}

// Performs a float2x3_saturate function on each row of the matrix.
HLML_INLINE float2x3 float2x3_saturate( const float2x3* x )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_saturate( &x->rows[0] ),
		float3_saturate( &x->rows[1] )
	};
}

// Performs a float2x3_lerp function on each row of the matrix.
HLML_INLINE float2x3 float2x3_lerp( const float2x3* lhs, const float2x3* rhs, const float t )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		float3_lerp( &lhs->rows[1], &rhs->rows[1], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float2x3_equals( const float2x3* lhs, const float2x3* rhs )
{
	return
		float3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		float3_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float2x3_not_equals( const float2x3* lhs, const float2x3* rhs )
{
	return !float2x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x3 float2x3_less_than( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		float3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		float3_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 float2x3_less_than_equal( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		float3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float3_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x3 float2x3_greater_than( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		float3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		float3_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 float2x3_greater_than_equal( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		float3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float2x3 float2x3_cadds( const float2x3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_cadds( &lhs->rows[0], rhs ),
		float3_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float2x3 float2x3_caddm( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float3_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float2x3 float2x3_csubs( const float2x3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_csubs( &lhs->rows[0], rhs ),
		float3_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float2x3 float2x3_csubm( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float3_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float2x3 float2x3_cmuls( const float2x3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_cmuls( &lhs->rows[0], rhs ),
		float3_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float2x3 float2x3_cmulm( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float2x3 float2x3_cdivs( const float2x3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_cdivs( &lhs->rows[0], rhs ),
		float3_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float2x3 float2x3_cdivm( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float3_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE float2x3 float2x3_negate( const float2x3* x )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		float3_negate( &x->rows[0] ),
		float3_negate( &x->rows[1] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void float2x3_identity( float2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float3x2 float2x3_transpose( const float2x3* mat )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float2x2 float2x3_mulm( const float2x3* lhs, const float3x2* rhs )
{
	float3 row0 = lhs->rows[0];
	float3 row1 = lhs->rows[1];

	float3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	float3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };

	return HLML_CONSTRUCT( float2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

// float2x4
// Performs a float2x4_sign function on each row of the matrix.
HLML_INLINE int2x4 float2x4_sign( const float2x4* x )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		float4_sign( &x->rows[0] ),
		float4_sign( &x->rows[1] )
	};
}

// Performs a float2x4_min function on each row of the matrix.
HLML_INLINE float2x4 float2x4_min( const float2x4* x, const float2x4* y )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_min( &x->rows[0], &y->rows[0] ),
		float4_min( &x->rows[1], &y->rows[1] )
	};
}

// Performs a float2x4_max function on each row of the matrix.
HLML_INLINE float2x4 float2x4_max( const float2x4* x, const float2x4* y )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_max( &x->rows[0], &y->rows[0] ),
		float4_max( &x->rows[1], &y->rows[1] )
	};
}

// Performs a float2x4_clamp function on each row of the matrix.
HLML_INLINE float2x4 float2x4_clamp( const float2x4* x, const float2x4* low, const float2x4* high )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		float4_clamp( &x->rows[1], &low->rows[1], &high->rows[1] )
	};
}

// Performs a float2x4_saturate function on each row of the matrix.
HLML_INLINE float2x4 float2x4_saturate( const float2x4* x )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_saturate( &x->rows[0] ),
		float4_saturate( &x->rows[1] )
	};
}

// Performs a float2x4_lerp function on each row of the matrix.
HLML_INLINE float2x4 float2x4_lerp( const float2x4* lhs, const float2x4* rhs, const float t )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		float4_lerp( &lhs->rows[1], &rhs->rows[1], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float2x4_equals( const float2x4* lhs, const float2x4* rhs )
{
	return
		float4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		float4_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float2x4_not_equals( const float2x4* lhs, const float2x4* rhs )
{
	return !float2x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x4 float2x4_less_than( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		float4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		float4_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 float2x4_less_than_equal( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		float4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float4_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x4 float2x4_greater_than( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		float4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		float4_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 float2x4_greater_than_equal( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		float4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float2x4 float2x4_cadds( const float2x4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_cadds( &lhs->rows[0], rhs ),
		float4_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float2x4 float2x4_caddm( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float4_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float2x4 float2x4_csubs( const float2x4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_csubs( &lhs->rows[0], rhs ),
		float4_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float2x4 float2x4_csubm( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float4_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float2x4 float2x4_cmuls( const float2x4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_cmuls( &lhs->rows[0], rhs ),
		float4_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float2x4 float2x4_cmulm( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float2x4 float2x4_cdivs( const float2x4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_cdivs( &lhs->rows[0], rhs ),
		float4_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float2x4 float2x4_cdivm( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float4_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE float2x4 float2x4_negate( const float2x4* x )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		float4_negate( &x->rows[0] ),
		float4_negate( &x->rows[1] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void float2x4_identity( float2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float4x2 float2x4_transpose( const float2x4* mat )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float2x2 float2x4_mulm( const float2x4* lhs, const float4x2* rhs )
{
	float4 row0 = lhs->rows[0];
	float4 row1 = lhs->rows[1];

	float4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	float4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };

	return HLML_CONSTRUCT( float2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

// float3x2
// Performs a float3x2_sign function on each row of the matrix.
HLML_INLINE int3x2 float3x2_sign( const float3x2* x )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		float2_sign( &x->rows[0] ),
		float2_sign( &x->rows[1] ),
		float2_sign( &x->rows[2] )
	};
}

// Performs a float3x2_min function on each row of the matrix.
HLML_INLINE float3x2 float3x2_min( const float3x2* x, const float3x2* y )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_min( &x->rows[0], &y->rows[0] ),
		float2_min( &x->rows[1], &y->rows[1] ),
		float2_min( &x->rows[2], &y->rows[2] )
	};
}

// Performs a float3x2_max function on each row of the matrix.
HLML_INLINE float3x2 float3x2_max( const float3x2* x, const float3x2* y )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_max( &x->rows[0], &y->rows[0] ),
		float2_max( &x->rows[1], &y->rows[1] ),
		float2_max( &x->rows[2], &y->rows[2] )
	};
}

// Performs a float3x2_clamp function on each row of the matrix.
HLML_INLINE float3x2 float3x2_clamp( const float3x2* x, const float3x2* low, const float3x2* high )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		float2_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		float2_clamp( &x->rows[2], &low->rows[2], &high->rows[2] )
	};
}

// Performs a float3x2_saturate function on each row of the matrix.
HLML_INLINE float3x2 float3x2_saturate( const float3x2* x )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_saturate( &x->rows[0] ),
		float2_saturate( &x->rows[1] ),
		float2_saturate( &x->rows[2] )
	};
}

// Performs a float3x2_lerp function on each row of the matrix.
HLML_INLINE float3x2 float3x2_lerp( const float3x2* lhs, const float3x2* rhs, const float t )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		float2_lerp( &lhs->rows[1], &rhs->rows[1], t ),
		float2_lerp( &lhs->rows[2], &rhs->rows[2], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float3x2_equals( const float3x2* lhs, const float3x2* rhs )
{
	return
		float2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		float2_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		float2_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float3x2_not_equals( const float3x2* lhs, const float3x2* rhs )
{
	return !float3x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x2 float3x2_less_than( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		float2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		float2_less_than( &lhs->rows[1], &rhs->rows[1] ),
		float2_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 float3x2_less_than_equal( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		float2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float2_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		float2_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x2 float3x2_greater_than( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		float2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		float2_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		float2_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 float3x2_greater_than_equal( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		float2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		float2_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float3x2 float3x2_cadds( const float3x2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_cadds( &lhs->rows[0], rhs ),
		float2_cadds( &lhs->rows[1], rhs ),
		float2_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float3x2 float3x2_caddm( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		float2_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float3x2 float3x2_csubs( const float3x2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_csubs( &lhs->rows[0], rhs ),
		float2_csubs( &lhs->rows[1], rhs ),
		float2_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float3x2 float3x2_csubm( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		float2_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float3x2 float3x2_cmuls( const float3x2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_cmuls( &lhs->rows[0], rhs ),
		float2_cmuls( &lhs->rows[1], rhs ),
		float2_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float3x2 float3x2_cmulm( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float3x2 float3x2_cdivs( const float3x2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_cdivs( &lhs->rows[0], rhs ),
		float2_cdivs( &lhs->rows[1], rhs ),
		float2_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float3x2 float3x2_cdivm( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		float2_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE float3x2 float3x2_negate( const float3x2* x )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		float2_negate( &x->rows[0] ),
		float2_negate( &x->rows[1] ),
		float2_negate( &x->rows[2] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void float3x2_identity( float3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
	mat->rows[2] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float2x3 float3x2_transpose( const float3x2* mat )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float3x3 float3x2_mulm( const float3x2* lhs, const float2x3* rhs )
{
	float2 row0 = lhs->rows[0];
	float2 row1 = lhs->rows[1];
	float2 row2 = lhs->rows[2];

	float2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	float2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	float2 col2 = { rhs->rows[0].z, rhs->rows[1].z };

	return HLML_CONSTRUCT( float3x3 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

// float3x3
// Performs a float3x3_sign function on each row of the matrix.
HLML_INLINE int3x3 float3x3_sign( const float3x3* x )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		float3_sign( &x->rows[0] ),
		float3_sign( &x->rows[1] ),
		float3_sign( &x->rows[2] )
	};
}

// Performs a float3x3_min function on each row of the matrix.
HLML_INLINE float3x3 float3x3_min( const float3x3* x, const float3x3* y )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_min( &x->rows[0], &y->rows[0] ),
		float3_min( &x->rows[1], &y->rows[1] ),
		float3_min( &x->rows[2], &y->rows[2] )
	};
}

// Performs a float3x3_max function on each row of the matrix.
HLML_INLINE float3x3 float3x3_max( const float3x3* x, const float3x3* y )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_max( &x->rows[0], &y->rows[0] ),
		float3_max( &x->rows[1], &y->rows[1] ),
		float3_max( &x->rows[2], &y->rows[2] )
	};
}

// Performs a float3x3_clamp function on each row of the matrix.
HLML_INLINE float3x3 float3x3_clamp( const float3x3* x, const float3x3* low, const float3x3* high )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		float3_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		float3_clamp( &x->rows[2], &low->rows[2], &high->rows[2] )
	};
}

// Performs a float3x3_saturate function on each row of the matrix.
HLML_INLINE float3x3 float3x3_saturate( const float3x3* x )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_saturate( &x->rows[0] ),
		float3_saturate( &x->rows[1] ),
		float3_saturate( &x->rows[2] )
	};
}

// Performs a float3x3_lerp function on each row of the matrix.
HLML_INLINE float3x3 float3x3_lerp( const float3x3* lhs, const float3x3* rhs, const float t )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		float3_lerp( &lhs->rows[1], &rhs->rows[1], t ),
		float3_lerp( &lhs->rows[2], &rhs->rows[2], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float3x3_equals( const float3x3* lhs, const float3x3* rhs )
{
	return
		float3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		float3_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		float3_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float3x3_not_equals( const float3x3* lhs, const float3x3* rhs )
{
	return !float3x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x3 float3x3_less_than( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		float3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		float3_less_than( &lhs->rows[1], &rhs->rows[1] ),
		float3_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 float3x3_less_than_equal( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		float3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float3_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		float3_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x3 float3x3_greater_than( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		float3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		float3_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		float3_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 float3x3_greater_than_equal( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		float3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		float3_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float3x3 float3x3_cadds( const float3x3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_cadds( &lhs->rows[0], rhs ),
		float3_cadds( &lhs->rows[1], rhs ),
		float3_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float3x3 float3x3_caddm( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		float3_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float3x3 float3x3_csubs( const float3x3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_csubs( &lhs->rows[0], rhs ),
		float3_csubs( &lhs->rows[1], rhs ),
		float3_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float3x3 float3x3_csubm( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		float3_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float3x3 float3x3_cmuls( const float3x3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_cmuls( &lhs->rows[0], rhs ),
		float3_cmuls( &lhs->rows[1], rhs ),
		float3_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float3x3 float3x3_cmulm( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float3x3 float3x3_cdivs( const float3x3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_cdivs( &lhs->rows[0], rhs ),
		float3_cdivs( &lhs->rows[1], rhs ),
		float3_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float3x3 float3x3_cdivm( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		float3_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE float3x3 float3x3_negate( const float3x3* x )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		float3_negate( &x->rows[0] ),
		float3_negate( &x->rows[1] ),
		float3_negate( &x->rows[2] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void float3x3_identity( float3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
	mat->rows[2] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 1.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float3x3 float3x3_transpose( const float3x3* mat )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

// Returns the determinant of the matrix.
HLML_INLINE float float3x3_determinant( const float3x3* mat )
{
	return
		+ mat->rows[0].x * ( mat->rows[1].y * mat->rows[2].z - mat->rows[2].y * mat->rows[1].z ) 
		- mat->rows[0].y * ( mat->rows[1].x * mat->rows[2].z - mat->rows[2].x * mat->rows[1].z ) 
		+ mat->rows[0].z * ( mat->rows[1].x * mat->rows[2].y - mat->rows[2].x * mat->rows[1].y );
}

// Returns a copy of the matrix that is inversed.
// This is only applicable for square matrices.
HLML_INLINE float3x3 float3x3_inverse( const float3x3* mat )
{
	const float invdet = 1.0f / float3x3_determinant( mat );
	return HLML_CONSTRUCT( float3x3 )
	{
		 ( mat->rows[1].y * mat->rows[2].z - mat->rows[1].z * mat->rows[2].y ) * invdet,
		-( mat->rows[0].y * mat->rows[2].z - mat->rows[0].z * mat->rows[2].y ) * invdet,
		 ( mat->rows[0].y * mat->rows[1].z - mat->rows[0].z * mat->rows[1].y ) * invdet,

		-( mat->rows[1].x * mat->rows[2].z - mat->rows[1].z * mat->rows[2].x ) * invdet,
		 ( mat->rows[0].x * mat->rows[2].z - mat->rows[0].z * mat->rows[2].x ) * invdet,
		-( mat->rows[0].x * mat->rows[1].z - mat->rows[0].z * mat->rows[1].x ) * invdet,

		 ( mat->rows[1].x * mat->rows[2].y - mat->rows[1].y * mat->rows[2].x ) * invdet,
		-( mat->rows[0].x * mat->rows[2].y - mat->rows[0].y * mat->rows[2].x ) * invdet,
		 ( mat->rows[0].x * mat->rows[1].y - mat->rows[0].y * mat->rows[1].x ) * invdet
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float3x3 float3x3_mulm( const float3x3* lhs, const float3x3* rhs )
{
	float3 row0 = lhs->rows[0];
	float3 row1 = lhs->rows[1];
	float3 row2 = lhs->rows[2];

	float3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	float3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	float3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };

	return HLML_CONSTRUCT( float3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE float3 float3x3_mulv( const float3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3 )
	{
		( lhs->x * rhs->rows[0].x ) + ( lhs->y * rhs->rows[1].x ) + ( lhs->z * rhs->rows[2].x ),
		( lhs->x * rhs->rows[0].y ) + ( lhs->y * rhs->rows[1].y ) + ( lhs->z * rhs->rows[2].y ),
		( lhs->x * rhs->rows[0].z ) + ( lhs->y * rhs->rows[1].z ) + ( lhs->z * rhs->rows[2].z )
	};
}

// float3x4
// Performs a float3x4_sign function on each row of the matrix.
HLML_INLINE int3x4 float3x4_sign( const float3x4* x )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		float4_sign( &x->rows[0] ),
		float4_sign( &x->rows[1] ),
		float4_sign( &x->rows[2] )
	};
}

// Performs a float3x4_min function on each row of the matrix.
HLML_INLINE float3x4 float3x4_min( const float3x4* x, const float3x4* y )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_min( &x->rows[0], &y->rows[0] ),
		float4_min( &x->rows[1], &y->rows[1] ),
		float4_min( &x->rows[2], &y->rows[2] )
	};
}

// Performs a float3x4_max function on each row of the matrix.
HLML_INLINE float3x4 float3x4_max( const float3x4* x, const float3x4* y )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_max( &x->rows[0], &y->rows[0] ),
		float4_max( &x->rows[1], &y->rows[1] ),
		float4_max( &x->rows[2], &y->rows[2] )
	};
}

// Performs a float3x4_clamp function on each row of the matrix.
HLML_INLINE float3x4 float3x4_clamp( const float3x4* x, const float3x4* low, const float3x4* high )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		float4_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		float4_clamp( &x->rows[2], &low->rows[2], &high->rows[2] )
	};
}

// Performs a float3x4_saturate function on each row of the matrix.
HLML_INLINE float3x4 float3x4_saturate( const float3x4* x )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_saturate( &x->rows[0] ),
		float4_saturate( &x->rows[1] ),
		float4_saturate( &x->rows[2] )
	};
}

// Performs a float3x4_lerp function on each row of the matrix.
HLML_INLINE float3x4 float3x4_lerp( const float3x4* lhs, const float3x4* rhs, const float t )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		float4_lerp( &lhs->rows[1], &rhs->rows[1], t ),
		float4_lerp( &lhs->rows[2], &rhs->rows[2], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float3x4_equals( const float3x4* lhs, const float3x4* rhs )
{
	return
		float4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		float4_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		float4_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float3x4_not_equals( const float3x4* lhs, const float3x4* rhs )
{
	return !float3x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x4 float3x4_less_than( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		float4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		float4_less_than( &lhs->rows[1], &rhs->rows[1] ),
		float4_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 float3x4_less_than_equal( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		float4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float4_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		float4_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x4 float3x4_greater_than( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		float4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		float4_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		float4_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 float3x4_greater_than_equal( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		float4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		float4_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float3x4 float3x4_cadds( const float3x4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_cadds( &lhs->rows[0], rhs ),
		float4_cadds( &lhs->rows[1], rhs ),
		float4_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float3x4 float3x4_caddm( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		float4_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float3x4 float3x4_csubs( const float3x4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_csubs( &lhs->rows[0], rhs ),
		float4_csubs( &lhs->rows[1], rhs ),
		float4_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float3x4 float3x4_csubm( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		float4_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float3x4 float3x4_cmuls( const float3x4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_cmuls( &lhs->rows[0], rhs ),
		float4_cmuls( &lhs->rows[1], rhs ),
		float4_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float3x4 float3x4_cmulm( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float3x4 float3x4_cdivs( const float3x4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_cdivs( &lhs->rows[0], rhs ),
		float4_cdivs( &lhs->rows[1], rhs ),
		float4_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float3x4 float3x4_cdivm( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		float4_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE float3x4 float3x4_negate( const float3x4* x )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		float4_negate( &x->rows[0] ),
		float4_negate( &x->rows[1] ),
		float4_negate( &x->rows[2] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void float3x4_identity( float3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
	mat->rows[2] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 1.0f, 0.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float4x3 float3x4_transpose( const float3x4* mat )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float3x3 float3x4_mulm( const float3x4* lhs, const float4x3* rhs )
{
	float4 row0 = lhs->rows[0];
	float4 row1 = lhs->rows[1];
	float4 row2 = lhs->rows[2];

	float4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	float4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	float4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };

	return HLML_CONSTRUCT( float3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

// float4x2
// Performs a float4x2_sign function on each row of the matrix.
HLML_INLINE int4x2 float4x2_sign( const float4x2* x )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		float2_sign( &x->rows[0] ),
		float2_sign( &x->rows[1] ),
		float2_sign( &x->rows[2] ),
		float2_sign( &x->rows[3] )
	};
}

// Performs a float4x2_min function on each row of the matrix.
HLML_INLINE float4x2 float4x2_min( const float4x2* x, const float4x2* y )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_min( &x->rows[0], &y->rows[0] ),
		float2_min( &x->rows[1], &y->rows[1] ),
		float2_min( &x->rows[2], &y->rows[2] ),
		float2_min( &x->rows[3], &y->rows[3] )
	};
}

// Performs a float4x2_max function on each row of the matrix.
HLML_INLINE float4x2 float4x2_max( const float4x2* x, const float4x2* y )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_max( &x->rows[0], &y->rows[0] ),
		float2_max( &x->rows[1], &y->rows[1] ),
		float2_max( &x->rows[2], &y->rows[2] ),
		float2_max( &x->rows[3], &y->rows[3] )
	};
}

// Performs a float4x2_clamp function on each row of the matrix.
HLML_INLINE float4x2 float4x2_clamp( const float4x2* x, const float4x2* low, const float4x2* high )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		float2_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		float2_clamp( &x->rows[2], &low->rows[2], &high->rows[2] ),
		float2_clamp( &x->rows[3], &low->rows[3], &high->rows[3] )
	};
}

// Performs a float4x2_saturate function on each row of the matrix.
HLML_INLINE float4x2 float4x2_saturate( const float4x2* x )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_saturate( &x->rows[0] ),
		float2_saturate( &x->rows[1] ),
		float2_saturate( &x->rows[2] ),
		float2_saturate( &x->rows[3] )
	};
}

// Performs a float4x2_lerp function on each row of the matrix.
HLML_INLINE float4x2 float4x2_lerp( const float4x2* lhs, const float4x2* rhs, const float t )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		float2_lerp( &lhs->rows[1], &rhs->rows[1], t ),
		float2_lerp( &lhs->rows[2], &rhs->rows[2], t ),
		float2_lerp( &lhs->rows[3], &rhs->rows[3], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float4x2_equals( const float4x2* lhs, const float4x2* rhs )
{
	return
		float2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		float2_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		float2_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		float2_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float4x2_not_equals( const float4x2* lhs, const float4x2* rhs )
{
	return !float4x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x2 float4x2_less_than( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		float2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		float2_less_than( &lhs->rows[1], &rhs->rows[1] ),
		float2_less_than( &lhs->rows[2], &rhs->rows[2] ),
		float2_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 float4x2_less_than_equal( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		float2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float2_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		float2_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		float2_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x2 float4x2_greater_than( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		float2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		float2_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		float2_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		float2_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 float4x2_greater_than_equal( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		float2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		float2_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		float2_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float4x2 float4x2_cadds( const float4x2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_cadds( &lhs->rows[0], rhs ),
		float2_cadds( &lhs->rows[1], rhs ),
		float2_cadds( &lhs->rows[2], rhs ),
		float2_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float4x2 float4x2_caddm( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		float2_caddv( &lhs->rows[2], &rhs->rows[2] ),
		float2_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float4x2 float4x2_csubs( const float4x2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_csubs( &lhs->rows[0], rhs ),
		float2_csubs( &lhs->rows[1], rhs ),
		float2_csubs( &lhs->rows[2], rhs ),
		float2_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float4x2 float4x2_csubm( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		float2_csubv( &lhs->rows[2], &rhs->rows[2] ),
		float2_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float4x2 float4x2_cmuls( const float4x2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_cmuls( &lhs->rows[0], rhs ),
		float2_cmuls( &lhs->rows[1], rhs ),
		float2_cmuls( &lhs->rows[2], rhs ),
		float2_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float4x2 float4x2_cmulm( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		float2_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float4x2 float4x2_cdivs( const float4x2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_cdivs( &lhs->rows[0], rhs ),
		float2_cdivs( &lhs->rows[1], rhs ),
		float2_cdivs( &lhs->rows[2], rhs ),
		float2_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float4x2 float4x2_cdivm( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		float2_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		float2_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE float4x2 float4x2_negate( const float4x2* x )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		float2_negate( &x->rows[0] ),
		float2_negate( &x->rows[1] ),
		float2_negate( &x->rows[2] ),
		float2_negate( &x->rows[3] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void float4x2_identity( float4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
	mat->rows[2] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
	mat->rows[3] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float2x4 float4x2_transpose( const float4x2* mat )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float4x4 float4x2_mulm( const float4x2* lhs, const float2x4* rhs )
{
	float2 row0 = lhs->rows[0];
	float2 row1 = lhs->rows[1];
	float2 row2 = lhs->rows[2];
	float2 row3 = lhs->rows[3];

	float2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	float2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	float2 col2 = { rhs->rows[0].z, rhs->rows[1].z };
	float2 col3 = { rhs->rows[0].w, rhs->rows[1].w };

	return HLML_CONSTRUCT( float4x4 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

// float4x3
// Performs a float4x3_sign function on each row of the matrix.
HLML_INLINE int4x3 float4x3_sign( const float4x3* x )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		float3_sign( &x->rows[0] ),
		float3_sign( &x->rows[1] ),
		float3_sign( &x->rows[2] ),
		float3_sign( &x->rows[3] )
	};
}

// Performs a float4x3_min function on each row of the matrix.
HLML_INLINE float4x3 float4x3_min( const float4x3* x, const float4x3* y )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_min( &x->rows[0], &y->rows[0] ),
		float3_min( &x->rows[1], &y->rows[1] ),
		float3_min( &x->rows[2], &y->rows[2] ),
		float3_min( &x->rows[3], &y->rows[3] )
	};
}

// Performs a float4x3_max function on each row of the matrix.
HLML_INLINE float4x3 float4x3_max( const float4x3* x, const float4x3* y )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_max( &x->rows[0], &y->rows[0] ),
		float3_max( &x->rows[1], &y->rows[1] ),
		float3_max( &x->rows[2], &y->rows[2] ),
		float3_max( &x->rows[3], &y->rows[3] )
	};
}

// Performs a float4x3_clamp function on each row of the matrix.
HLML_INLINE float4x3 float4x3_clamp( const float4x3* x, const float4x3* low, const float4x3* high )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		float3_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		float3_clamp( &x->rows[2], &low->rows[2], &high->rows[2] ),
		float3_clamp( &x->rows[3], &low->rows[3], &high->rows[3] )
	};
}

// Performs a float4x3_saturate function on each row of the matrix.
HLML_INLINE float4x3 float4x3_saturate( const float4x3* x )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_saturate( &x->rows[0] ),
		float3_saturate( &x->rows[1] ),
		float3_saturate( &x->rows[2] ),
		float3_saturate( &x->rows[3] )
	};
}

// Performs a float4x3_lerp function on each row of the matrix.
HLML_INLINE float4x3 float4x3_lerp( const float4x3* lhs, const float4x3* rhs, const float t )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		float3_lerp( &lhs->rows[1], &rhs->rows[1], t ),
		float3_lerp( &lhs->rows[2], &rhs->rows[2], t ),
		float3_lerp( &lhs->rows[3], &rhs->rows[3], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float4x3_equals( const float4x3* lhs, const float4x3* rhs )
{
	return
		float3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		float3_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		float3_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		float3_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float4x3_not_equals( const float4x3* lhs, const float4x3* rhs )
{
	return !float4x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x3 float4x3_less_than( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		float3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		float3_less_than( &lhs->rows[1], &rhs->rows[1] ),
		float3_less_than( &lhs->rows[2], &rhs->rows[2] ),
		float3_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 float4x3_less_than_equal( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		float3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float3_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		float3_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		float3_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x3 float4x3_greater_than( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		float3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		float3_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		float3_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		float3_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 float4x3_greater_than_equal( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		float3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		float3_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		float3_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float4x3 float4x3_cadds( const float4x3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_cadds( &lhs->rows[0], rhs ),
		float3_cadds( &lhs->rows[1], rhs ),
		float3_cadds( &lhs->rows[2], rhs ),
		float3_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float4x3 float4x3_caddm( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		float3_caddv( &lhs->rows[2], &rhs->rows[2] ),
		float3_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float4x3 float4x3_csubs( const float4x3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_csubs( &lhs->rows[0], rhs ),
		float3_csubs( &lhs->rows[1], rhs ),
		float3_csubs( &lhs->rows[2], rhs ),
		float3_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float4x3 float4x3_csubm( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		float3_csubv( &lhs->rows[2], &rhs->rows[2] ),
		float3_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float4x3 float4x3_cmuls( const float4x3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_cmuls( &lhs->rows[0], rhs ),
		float3_cmuls( &lhs->rows[1], rhs ),
		float3_cmuls( &lhs->rows[2], rhs ),
		float3_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float4x3 float4x3_cmulm( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		float3_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float4x3 float4x3_cdivs( const float4x3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_cdivs( &lhs->rows[0], rhs ),
		float3_cdivs( &lhs->rows[1], rhs ),
		float3_cdivs( &lhs->rows[2], rhs ),
		float3_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float4x3 float4x3_cdivm( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		float3_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		float3_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE float4x3 float4x3_negate( const float4x3* x )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		float3_negate( &x->rows[0] ),
		float3_negate( &x->rows[1] ),
		float3_negate( &x->rows[2] ),
		float3_negate( &x->rows[3] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void float4x3_identity( float4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
	mat->rows[2] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 1.0f };
	mat->rows[3] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 0.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float3x4 float4x3_transpose( const float4x3* mat )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float4x4 float4x3_mulm( const float4x3* lhs, const float3x4* rhs )
{
	float3 row0 = lhs->rows[0];
	float3 row1 = lhs->rows[1];
	float3 row2 = lhs->rows[2];
	float3 row3 = lhs->rows[3];

	float3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	float3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	float3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };
	float3 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w };

	return HLML_CONSTRUCT( float4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

// float4x4
// Performs a float4x4_sign function on each row of the matrix.
HLML_INLINE int4x4 float4x4_sign( const float4x4* x )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		float4_sign( &x->rows[0] ),
		float4_sign( &x->rows[1] ),
		float4_sign( &x->rows[2] ),
		float4_sign( &x->rows[3] )
	};
}

// Performs a float4x4_min function on each row of the matrix.
HLML_INLINE float4x4 float4x4_min( const float4x4* x, const float4x4* y )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_min( &x->rows[0], &y->rows[0] ),
		float4_min( &x->rows[1], &y->rows[1] ),
		float4_min( &x->rows[2], &y->rows[2] ),
		float4_min( &x->rows[3], &y->rows[3] )
	};
}

// Performs a float4x4_max function on each row of the matrix.
HLML_INLINE float4x4 float4x4_max( const float4x4* x, const float4x4* y )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_max( &x->rows[0], &y->rows[0] ),
		float4_max( &x->rows[1], &y->rows[1] ),
		float4_max( &x->rows[2], &y->rows[2] ),
		float4_max( &x->rows[3], &y->rows[3] )
	};
}

// Performs a float4x4_clamp function on each row of the matrix.
HLML_INLINE float4x4 float4x4_clamp( const float4x4* x, const float4x4* low, const float4x4* high )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		float4_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		float4_clamp( &x->rows[2], &low->rows[2], &high->rows[2] ),
		float4_clamp( &x->rows[3], &low->rows[3], &high->rows[3] )
	};
}

// Performs a float4x4_saturate function on each row of the matrix.
HLML_INLINE float4x4 float4x4_saturate( const float4x4* x )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_saturate( &x->rows[0] ),
		float4_saturate( &x->rows[1] ),
		float4_saturate( &x->rows[2] ),
		float4_saturate( &x->rows[3] )
	};
}

// Performs a float4x4_lerp function on each row of the matrix.
HLML_INLINE float4x4 float4x4_lerp( const float4x4* lhs, const float4x4* rhs, const float t )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		float4_lerp( &lhs->rows[1], &rhs->rows[1], t ),
		float4_lerp( &lhs->rows[2], &rhs->rows[2], t ),
		float4_lerp( &lhs->rows[3], &rhs->rows[3], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float4x4_equals( const float4x4* lhs, const float4x4* rhs )
{
	return
		float4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		float4_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		float4_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		float4_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float4x4_not_equals( const float4x4* lhs, const float4x4* rhs )
{
	return !float4x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x4 float4x4_less_than( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		float4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		float4_less_than( &lhs->rows[1], &rhs->rows[1] ),
		float4_less_than( &lhs->rows[2], &rhs->rows[2] ),
		float4_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 float4x4_less_than_equal( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		float4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float4_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		float4_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		float4_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x4 float4x4_greater_than( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		float4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		float4_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		float4_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		float4_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 float4x4_greater_than_equal( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		float4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		float4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		float4_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		float4_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float4x4 float4x4_cadds( const float4x4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_cadds( &lhs->rows[0], rhs ),
		float4_cadds( &lhs->rows[1], rhs ),
		float4_cadds( &lhs->rows[2], rhs ),
		float4_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float4x4 float4x4_caddm( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		float4_caddv( &lhs->rows[2], &rhs->rows[2] ),
		float4_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float4x4 float4x4_csubs( const float4x4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_csubs( &lhs->rows[0], rhs ),
		float4_csubs( &lhs->rows[1], rhs ),
		float4_csubs( &lhs->rows[2], rhs ),
		float4_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float4x4 float4x4_csubm( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		float4_csubv( &lhs->rows[2], &rhs->rows[2] ),
		float4_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float4x4 float4x4_cmuls( const float4x4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_cmuls( &lhs->rows[0], rhs ),
		float4_cmuls( &lhs->rows[1], rhs ),
		float4_cmuls( &lhs->rows[2], rhs ),
		float4_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float4x4 float4x4_cmulm( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		float4_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float4x4 float4x4_cdivs( const float4x4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_cdivs( &lhs->rows[0], rhs ),
		float4_cdivs( &lhs->rows[1], rhs ),
		float4_cdivs( &lhs->rows[2], rhs ),
		float4_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float4x4 float4x4_cdivm( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		float4_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		float4_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE float4x4 float4x4_negate( const float4x4* x )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		float4_negate( &x->rows[0] ),
		float4_negate( &x->rows[1] ),
		float4_negate( &x->rows[2] ),
		float4_negate( &x->rows[3] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void float4x4_identity( float4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
	mat->rows[2] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 1.0f, 0.0f };
	mat->rows[3] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 0.0f, 1.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float4x4 float4x4_transpose( const float4x4* mat )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

// Returns the determinant of the matrix.
HLML_INLINE float float4x4_determinant( const float4x4* mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	float sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	float sub01 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	float sub02 = mat->rows[2].y * mat->rows[3].z - mat->rows[3].y * mat->rows[2].z;
	float sub03 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	float sub04 = mat->rows[2].x * mat->rows[3].z - mat->rows[3].x * mat->rows[2].z;
	float sub05 = mat->rows[2].x * mat->rows[3].y - mat->rows[3].x * mat->rows[2].y;

	float4 cofactor = HLML_CONSTRUCT( float4 )
	{
		 ( ( ( mat->rows[1].y * sub00 ) - ( mat->rows[1].z * sub01 ) ) + ( mat->rows[1].w * sub02 ) ),
		-( ( ( mat->rows[1].x * sub00 ) - ( mat->rows[1].z * sub03 ) ) + ( mat->rows[1].w * sub04 ) ),
		 ( ( ( mat->rows[1].x * sub01 ) - ( mat->rows[1].y * sub03 ) ) + ( mat->rows[1].w * sub05 ) ),
		-( ( ( mat->rows[1].x * sub02 ) - ( mat->rows[1].y * sub04 ) ) + ( mat->rows[1].z * sub05 ) ) 
	};

	return
		mat->rows[0].x * cofactor.x + mat->rows[0].y * cofactor.y +
		mat->rows[0].z * cofactor.z + mat->rows[0].w * cofactor.w; 
}

// Returns a copy of the matrix that is inversed.
// This is only applicable for square matrices.
HLML_INLINE float4x4 float4x4_inverse( const float4x4* mat )
{
	// uses the glm version, which is basically just an optimised version of the adjugate formula
	float sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	float sub01 = mat->rows[1].z * mat->rows[3].w - mat->rows[1].w * mat->rows[2].w;
	float sub02 = mat->rows[1].z * mat->rows[2].w - mat->rows[1].w * mat->rows[2].z;

	float sub03 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	float sub04 = mat->rows[1].y * mat->rows[3].w - mat->rows[1].w * mat->rows[3].y;
	float sub05 = mat->rows[1].y * mat->rows[2].w - mat->rows[1].w * mat->rows[2].y;

	float sub06 = mat->rows[2].y * mat->rows[3].z - mat->rows[2].z * mat->rows[3].y;
	float sub07 = mat->rows[1].y * mat->rows[3].z - mat->rows[1].z * mat->rows[3].y;
	float sub08 = mat->rows[1].y * mat->rows[2].z - mat->rows[1].z * mat->rows[2].y;

	float sub09 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	float sub10 = mat->rows[1].x * mat->rows[3].w - mat->rows[3].x * mat->rows[1].w;
	float sub11 = mat->rows[1].x * mat->rows[2].w - mat->rows[2].x * mat->rows[1].w;

	float sub12 = mat->rows[2].x * mat->rows[3].z - mat->rows[2].z * mat->rows[3].x;
	float sub13 = mat->rows[1].x * mat->rows[3].z - mat->rows[1].z * mat->rows[3].x;
	float sub14 = mat->rows[1].x * mat->rows[2].z - mat->rows[1].z * mat->rows[2].x;

	float sub15 = mat->rows[2].x * mat->rows[3].y - mat->rows[2].y * mat->rows[3].x;
	float sub16 = mat->rows[1].x * mat->rows[3].y - mat->rows[1].y * mat->rows[3].x;
	float sub17 = mat->rows[1].x * mat->rows[2].y - mat->rows[1].y * mat->rows[2].x;

	float4 fac0 = { sub00, sub00, sub01, sub02 };
	float4 fac1 = { sub03, sub03, sub04, sub05 };
	float4 fac2 = { sub06, sub06, sub07, sub08 };
	float4 fac3 = { sub09, sub09, sub10, sub11 };
	float4 fac4 = { sub12, sub12, sub13, sub14 };
	float4 fac5 = { sub15, sub15, sub16, sub17 };

	float4 vec0 = { mat->rows[1].x, mat->rows[0].x, mat->rows[0].x, mat->rows[0].x };
	float4 vec1 = { mat->rows[1].y, mat->rows[0].y, mat->rows[0].y, mat->rows[0].y };
	float4 vec2 = { mat->rows[1].z, mat->rows[0].z, mat->rows[0].z, mat->rows[0].z };
	float4 vec3 = { mat->rows[1].w, mat->rows[0].w, mat->rows[0].w, mat->rows[0].w };

	float4 inv0mula = float4_cmulv( &vec1, &fac0 );
	float4 inv0mulb = float4_cmulv( &vec2, &fac1 );
	float4 inv0mulc = float4_cmulv( &vec3, &fac2 );
	float4 inv0     = float4_csubv( &inv0mula, &inv0mulb );
	inv0 = float4_caddv( &inv0, &inv0mulc );

	float4 inv1mula = float4_cmulv( &vec0, &fac0 );
	float4 inv1mulb = float4_cmulv( &vec2, &fac3 );
	float4 inv1mulc = float4_cmulv( &vec3, &fac4 );
	float4 inv1     = float4_csubv( &inv1mula, &inv1mulb );
	inv1 = float4_caddv( &inv1, &inv1mulc );

	float4 inv2mula = float4_cmulv( &vec0, &fac1 );
	float4 inv2mulb = float4_cmulv( &vec1, &fac3 );
	float4 inv2mulc = float4_cmulv( &vec3, &fac5 );
	float4 inv2     = float4_csubv( &inv2mula, &inv2mulb );
	inv2 = float4_caddv( &inv2, &inv2mulc );

	float4 inv3mula = float4_cmulv( &vec0, &fac2 );
	float4 inv3mulb = float4_cmulv( &vec1, &fac4 );
	float4 inv3mulc = float4_cmulv( &vec2, &fac5 );
	float4 inv3     = float4_csubv( &inv3mula, &inv3mulb );
	inv3 = float4_caddv( &inv3, &inv3mulc );


	float4 sign0 = {  1, -1,  1, -1 };
	float4 sign1 = { -1,  1, -1,  1 };

	float4x4 result = {
		float4_cmulv( &inv0, &sign0 ),
		float4_cmulv( &inv1, &sign1 ),
		float4_cmulv( &inv2, &sign0 ),
		float4_cmulv( &inv3, &sign1 )
	};

	float4 col0 = { result.rows[0].x, result.rows[1].x, result.rows[2].x, result.rows[3].x };
	float4 dot0 = float4_cmulv( &mat->rows[0], &col0 );

	const float dot1 = ( dot0.x + dot0.y ) + ( dot0.z + dot0.w );

	const float invdet = 1.0f / dot1;

	return float4x4_cmuls( &result, invdet );
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float4x4 float4x4_mulm( const float4x4* lhs, const float4x4* rhs )
{
	float4 row0 = lhs->rows[0];
	float4 row1 = lhs->rows[1];
	float4 row2 = lhs->rows[2];
	float4 row3 = lhs->rows[3];

	float4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	float4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	float4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };
	float4 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w, rhs->rows[3].w };

	return HLML_CONSTRUCT( float4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE float4 float4x4_mulv( const float4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4 )
	{
		( lhs->x * rhs->rows[0].x ) + ( lhs->y * rhs->rows[1].x ) + ( lhs->z * rhs->rows[2].x ) + ( lhs->w * rhs->rows[3].x ),
		( lhs->x * rhs->rows[0].y ) + ( lhs->y * rhs->rows[1].y ) + ( lhs->z * rhs->rows[2].y ) + ( lhs->w * rhs->rows[3].y ),
		( lhs->x * rhs->rows[0].z ) + ( lhs->y * rhs->rows[1].z ) + ( lhs->z * rhs->rows[2].z ) + ( lhs->w * rhs->rows[3].z ),
		( lhs->x * rhs->rows[0].w ) + ( lhs->y * rhs->rows[1].w ) + ( lhs->z * rhs->rows[2].w ) + ( lhs->w * rhs->rows[3].w )
	};
}

// "Translates" the matrix.  Adds the last column of 'mat' by the position vector 'vec'.
HLML_INLINE float4x4 float4x4_translate( const float4x4* mat, const float3* vec )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z,
		mat->rows[3].x, mat->rows[3].y, mat->rows[3].z, mat->rows[3].w
	};
}

// Rotates the matrix by the given axis-angle (in radians) and returns the result.
HLML_INLINE float4x4 float4x4_rotate( const float4x4* mat, const float rad, const float3* axis )
{
	const float c = cosf( rad );
	const float s = sinf( rad );

	float3 u = float3_normalized( axis );
	float ic = 1.0f - c;

	float4x4 rotation = *mat;
	rotation.rows[0].x = c + u.x * ic;
	rotation.rows[0].y = u.x * u.y * ic - u.z * s;
	rotation.rows[0].z = u.x * u.z * ic + u.y * s;

	rotation.rows[1].x = u.y * u.x * ic + u.z * s;
	rotation.rows[1].y = c + u.y * ic;
	rotation.rows[1].z = u.y * u.z * ic - u.x * s;

	rotation.rows[2].x = u.z * u.x * ic - u.y * s;
	rotation.rows[2].y = u.z * u.y * ic + u.x * s;
	rotation.rows[2].z = c + u.z * ic;

	return float4x4_mulm( mat, &rotation );
}

// Applies a non-uniform scale to the matrix and returns the result.
HLML_INLINE float4x4 float4x4_scale( const float4x4* mat, const float3* scale )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		mat->rows[0].x * scale->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * scale->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z * scale->z,
		mat->rows[2].w,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z,
		mat->rows[3].w
	};
}

// Returns an left-handed orthographic projection matrix with the clip-space range 0 to 1.
HLML_INLINE float4x4 float4x4_ortho_lh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// left-handed, clip space range: zero-to-one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( float4x4 )
	{
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, 1.0f / far_minus_near, -znear / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

// Returns an left-handed orthographic projection matrix with the clip-space range -1 to 1.
HLML_INLINE float4x4 float4x4_ortho_lh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// left-handed, clip space range: minus-one-to-one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( float4x4 )
	{
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, 2.0f / far_minus_near, -far_plus_near / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

// Returns an right-handed orthographic projection matrix with the clip-space range 0 to 1.
HLML_INLINE float4x4 float4x4_ortho_rh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// right-handed, clip space range: zero-to-one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( float4x4 )
	{
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, -1.0f / far_minus_near, -znear / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

// Returns an right-handed orthographic projection matrix with the clip-space range -1 to 1.
HLML_INLINE float4x4 float4x4_ortho_rh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// right-handed, clip space range: minus-one-to-one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( float4x4 )
	{
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, -2.0f / far_minus_near, -far_plus_near / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

// Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of 0 to 1.
HLML_INLINE float4x4 float4x4_perspective_lh_zo( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// left-handed, clip space range: zero-to-one
	const float far_minus_near = zfar - znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 )
	{
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, zfar / far_minus_near, -( zfar * znear ) / far_minus_near,
		0.0f, 0.0f, 1.0f, 0.0f
	};
}

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of -1 to 1.
HLML_INLINE float4x4 float4x4_perspective_lh_no( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// left-handed, clip space range: minus-one-to-one
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 )
	{
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, far_plus_near / far_minus_near, -( 2.0f * zfar * znear ) / far_minus_near,
		0.0f, 0.0f, 1.0f, 0.0f
	};
}

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of 0 to 1.
HLML_INLINE float4x4 float4x4_perspective_rh_zo( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// right-handed, clip space range: zero-to-one
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 )
	{
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, zfar / ( znear - zfar ), -( zfar * znear ) / ( zfar - znear ),
		0.0f, 0.0f, -1.0f, 0.0f
	};
}

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of -1 to 1.
HLML_INLINE float4x4 float4x4_perspective_rh_no( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// right-handed, clip space range: minus-one-to-one
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 )
	{
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, -far_plus_near / far_minus_near, -( 2.0f * zfar * znear ) / far_minus_near,
		0.0f, 0.0f, -1.0f, 0.0f
	};
}

// Returns a left-handed orthonormal matrix that is oriented at position 'eye' to look at position 'target'.
HLML_INLINE float4x4 float4x4_look_at_lh( const float3* eye, const float3* target, const float3* up )
{
	// left handed
	const float3 eye_to_target = float3_csubv( target, eye );
	const float3 forward = float3_normalized( &eye_to_target );
	const float3 up_cross_forward = float3_cross( up, &forward );
	const float3 right = float3_normalized( &up_cross_forward );
	const float3 up1 = float3_cross( &forward, &right );

	return HLML_CONSTRUCT( float4x4 )
	{
		right.x,   right.y,   right.z,   -float3_dot( &right, eye ),
		up1.x,     up1.y,     up1.z,     -float3_dot( &up1, eye ),
		forward.x, forward.y, forward.z, -float3_dot( &forward, eye ),
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

// Returns a right-handed orthonormal matrix that is oriented at position 'eye' to look at position 'target'.
HLML_INLINE float4x4 float4x4_look_at_rh( const float3* eye, const float3* target, const float3* up )
{
	// right handed
	const float3 eye_to_target = float3_csubv( target, eye );
	const float3 forward = float3_normalized( &eye_to_target );
	const float3 forward_cross_up = float3_cross( &forward, up );
	const float3 right = float3_normalized( &forward_cross_up );
	const float3 up1 = float3_cross( &right, &forward );

	return HLML_CONSTRUCT( float4x4 )
	{
		 right.x,    right.y,    right.z,   -float3_dot( &right, eye ),
		 up1.x,      up1.y,      up1.z,     -float3_dot( &up1, eye ),
		-forward.x, -forward.y, -forward.z,  float3_dot( &forward, eye ),
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

// double2x2
// Performs a double2x2_sign function on each row of the matrix.
HLML_INLINE int2x2 double2x2_sign( const double2x2* x )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		double2_sign( &x->rows[0] ),
		double2_sign( &x->rows[1] )
	};
}

// Performs a double2x2_min function on each row of the matrix.
HLML_INLINE double2x2 double2x2_min( const double2x2* x, const double2x2* y )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_min( &x->rows[0], &y->rows[0] ),
		double2_min( &x->rows[1], &y->rows[1] )
	};
}

// Performs a double2x2_max function on each row of the matrix.
HLML_INLINE double2x2 double2x2_max( const double2x2* x, const double2x2* y )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_max( &x->rows[0], &y->rows[0] ),
		double2_max( &x->rows[1], &y->rows[1] )
	};
}

// Performs a double2x2_clamp function on each row of the matrix.
HLML_INLINE double2x2 double2x2_clamp( const double2x2* x, const double2x2* low, const double2x2* high )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		double2_clamp( &x->rows[1], &low->rows[1], &high->rows[1] )
	};
}

// Performs a double2x2_saturate function on each row of the matrix.
HLML_INLINE double2x2 double2x2_saturate( const double2x2* x )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_saturate( &x->rows[0] ),
		double2_saturate( &x->rows[1] )
	};
}

// Performs a double2x2_lerp function on each row of the matrix.
HLML_INLINE double2x2 double2x2_lerp( const double2x2* lhs, const double2x2* rhs, const double t )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		double2_lerp( &lhs->rows[1], &rhs->rows[1], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double2x2_equals( const double2x2* lhs, const double2x2* rhs )
{
	return
		double2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		double2_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double2x2_not_equals( const double2x2* lhs, const double2x2* rhs )
{
	return !double2x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x2 double2x2_less_than( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		double2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		double2_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 double2x2_less_than_equal( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		double2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double2_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x2 double2x2_greater_than( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		double2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		double2_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 double2x2_greater_than_equal( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		double2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double2x2 double2x2_cadds( const double2x2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_cadds( &lhs->rows[0], rhs ),
		double2_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double2x2 double2x2_caddm( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double2_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double2x2 double2x2_csubs( const double2x2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_csubs( &lhs->rows[0], rhs ),
		double2_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double2x2 double2x2_csubm( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double2_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double2x2 double2x2_cmuls( const double2x2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_cmuls( &lhs->rows[0], rhs ),
		double2_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double2x2 double2x2_cmulm( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double2x2 double2x2_cdivs( const double2x2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_cdivs( &lhs->rows[0], rhs ),
		double2_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double2x2 double2x2_cdivm( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double2_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE double2x2 double2x2_negate( const double2x2* x )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		double2_negate( &x->rows[0] ),
		double2_negate( &x->rows[1] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void double2x2_identity( double2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double2x2 double2x2_transpose( const double2x2* mat )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

// Returns the determinant of the matrix.
HLML_INLINE double double2x2_determinant( const double2x2* mat )
{
	return mat->rows[0].x * mat->rows[1].y - mat->rows[1].x * mat->rows[0].y;
}

// Returns a copy of the matrix that is inversed.
// This is only applicable for square matrices.
HLML_INLINE double2x2 double2x2_inverse( const double2x2* mat )
{
	const double invdet = 1.0 / double2x2_determinant( mat );
	return HLML_CONSTRUCT( double2x2 )
	{
		 mat->rows[1].y * invdet, -mat->rows[0].y * invdet,
		-mat->rows[1].x * invdet,  mat->rows[0].x * invdet
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double2x2 double2x2_mulm( const double2x2* lhs, const double2x2* rhs )
{
	double2 row0 = lhs->rows[0];
	double2 row1 = lhs->rows[1];

	double2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	double2 col1 = { rhs->rows[0].y, rhs->rows[1].y };

	return HLML_CONSTRUCT( double2x2 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE double2 double2x2_mulv( const double2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2 )
	{
		( lhs->x * rhs->rows[0].x ) + ( lhs->y * rhs->rows[1].x ),
		( lhs->x * rhs->rows[0].y ) + ( lhs->y * rhs->rows[1].y )
	};
}

// double2x3
// Performs a double2x3_sign function on each row of the matrix.
HLML_INLINE int2x3 double2x3_sign( const double2x3* x )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		double3_sign( &x->rows[0] ),
		double3_sign( &x->rows[1] )
	};
}

// Performs a double2x3_min function on each row of the matrix.
HLML_INLINE double2x3 double2x3_min( const double2x3* x, const double2x3* y )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_min( &x->rows[0], &y->rows[0] ),
		double3_min( &x->rows[1], &y->rows[1] )
	};
}

// Performs a double2x3_max function on each row of the matrix.
HLML_INLINE double2x3 double2x3_max( const double2x3* x, const double2x3* y )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_max( &x->rows[0], &y->rows[0] ),
		double3_max( &x->rows[1], &y->rows[1] )
	};
}

// Performs a double2x3_clamp function on each row of the matrix.
HLML_INLINE double2x3 double2x3_clamp( const double2x3* x, const double2x3* low, const double2x3* high )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		double3_clamp( &x->rows[1], &low->rows[1], &high->rows[1] )
	};
}

// Performs a double2x3_saturate function on each row of the matrix.
HLML_INLINE double2x3 double2x3_saturate( const double2x3* x )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_saturate( &x->rows[0] ),
		double3_saturate( &x->rows[1] )
	};
}

// Performs a double2x3_lerp function on each row of the matrix.
HLML_INLINE double2x3 double2x3_lerp( const double2x3* lhs, const double2x3* rhs, const double t )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		double3_lerp( &lhs->rows[1], &rhs->rows[1], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double2x3_equals( const double2x3* lhs, const double2x3* rhs )
{
	return
		double3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		double3_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double2x3_not_equals( const double2x3* lhs, const double2x3* rhs )
{
	return !double2x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x3 double2x3_less_than( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		double3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		double3_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 double2x3_less_than_equal( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		double3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double3_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x3 double2x3_greater_than( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		double3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		double3_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 double2x3_greater_than_equal( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		double3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double2x3 double2x3_cadds( const double2x3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_cadds( &lhs->rows[0], rhs ),
		double3_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double2x3 double2x3_caddm( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double3_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double2x3 double2x3_csubs( const double2x3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_csubs( &lhs->rows[0], rhs ),
		double3_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double2x3 double2x3_csubm( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double3_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double2x3 double2x3_cmuls( const double2x3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_cmuls( &lhs->rows[0], rhs ),
		double3_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double2x3 double2x3_cmulm( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double2x3 double2x3_cdivs( const double2x3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_cdivs( &lhs->rows[0], rhs ),
		double3_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double2x3 double2x3_cdivm( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double3_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE double2x3 double2x3_negate( const double2x3* x )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		double3_negate( &x->rows[0] ),
		double3_negate( &x->rows[1] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void double2x3_identity( double2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double3x2 double2x3_transpose( const double2x3* mat )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double2x2 double2x3_mulm( const double2x3* lhs, const double3x2* rhs )
{
	double3 row0 = lhs->rows[0];
	double3 row1 = lhs->rows[1];

	double3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	double3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };

	return HLML_CONSTRUCT( double2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

// double2x4
// Performs a double2x4_sign function on each row of the matrix.
HLML_INLINE int2x4 double2x4_sign( const double2x4* x )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		double4_sign( &x->rows[0] ),
		double4_sign( &x->rows[1] )
	};
}

// Performs a double2x4_min function on each row of the matrix.
HLML_INLINE double2x4 double2x4_min( const double2x4* x, const double2x4* y )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_min( &x->rows[0], &y->rows[0] ),
		double4_min( &x->rows[1], &y->rows[1] )
	};
}

// Performs a double2x4_max function on each row of the matrix.
HLML_INLINE double2x4 double2x4_max( const double2x4* x, const double2x4* y )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_max( &x->rows[0], &y->rows[0] ),
		double4_max( &x->rows[1], &y->rows[1] )
	};
}

// Performs a double2x4_clamp function on each row of the matrix.
HLML_INLINE double2x4 double2x4_clamp( const double2x4* x, const double2x4* low, const double2x4* high )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		double4_clamp( &x->rows[1], &low->rows[1], &high->rows[1] )
	};
}

// Performs a double2x4_saturate function on each row of the matrix.
HLML_INLINE double2x4 double2x4_saturate( const double2x4* x )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_saturate( &x->rows[0] ),
		double4_saturate( &x->rows[1] )
	};
}

// Performs a double2x4_lerp function on each row of the matrix.
HLML_INLINE double2x4 double2x4_lerp( const double2x4* lhs, const double2x4* rhs, const double t )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		double4_lerp( &lhs->rows[1], &rhs->rows[1], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double2x4_equals( const double2x4* lhs, const double2x4* rhs )
{
	return
		double4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		double4_equals( &lhs->rows[1], &rhs->rows[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double2x4_not_equals( const double2x4* lhs, const double2x4* rhs )
{
	return !double2x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x4 double2x4_less_than( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		double4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		double4_less_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 double2x4_less_than_equal( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		double4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double4_less_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x4 double2x4_greater_than( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		double4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		double4_greater_than( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 double2x4_greater_than_equal( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		double4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double2x4 double2x4_cadds( const double2x4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_cadds( &lhs->rows[0], rhs ),
		double4_cadds( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double2x4 double2x4_caddm( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double4_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double2x4 double2x4_csubs( const double2x4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_csubs( &lhs->rows[0], rhs ),
		double4_csubs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double2x4 double2x4_csubm( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double4_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double2x4 double2x4_cmuls( const double2x4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_cmuls( &lhs->rows[0], rhs ),
		double4_cmuls( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double2x4 double2x4_cmulm( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double2x4 double2x4_cdivs( const double2x4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_cdivs( &lhs->rows[0], rhs ),
		double4_cdivs( &lhs->rows[1], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double2x4 double2x4_cdivm( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double4_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE double2x4 double2x4_negate( const double2x4* x )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		double4_negate( &x->rows[0] ),
		double4_negate( &x->rows[1] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void double2x4_identity( double2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double4x2 double2x4_transpose( const double2x4* mat )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double2x2 double2x4_mulm( const double2x4* lhs, const double4x2* rhs )
{
	double4 row0 = lhs->rows[0];
	double4 row1 = lhs->rows[1];

	double4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	double4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };

	return HLML_CONSTRUCT( double2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

// double3x2
// Performs a double3x2_sign function on each row of the matrix.
HLML_INLINE int3x2 double3x2_sign( const double3x2* x )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		double2_sign( &x->rows[0] ),
		double2_sign( &x->rows[1] ),
		double2_sign( &x->rows[2] )
	};
}

// Performs a double3x2_min function on each row of the matrix.
HLML_INLINE double3x2 double3x2_min( const double3x2* x, const double3x2* y )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_min( &x->rows[0], &y->rows[0] ),
		double2_min( &x->rows[1], &y->rows[1] ),
		double2_min( &x->rows[2], &y->rows[2] )
	};
}

// Performs a double3x2_max function on each row of the matrix.
HLML_INLINE double3x2 double3x2_max( const double3x2* x, const double3x2* y )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_max( &x->rows[0], &y->rows[0] ),
		double2_max( &x->rows[1], &y->rows[1] ),
		double2_max( &x->rows[2], &y->rows[2] )
	};
}

// Performs a double3x2_clamp function on each row of the matrix.
HLML_INLINE double3x2 double3x2_clamp( const double3x2* x, const double3x2* low, const double3x2* high )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		double2_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		double2_clamp( &x->rows[2], &low->rows[2], &high->rows[2] )
	};
}

// Performs a double3x2_saturate function on each row of the matrix.
HLML_INLINE double3x2 double3x2_saturate( const double3x2* x )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_saturate( &x->rows[0] ),
		double2_saturate( &x->rows[1] ),
		double2_saturate( &x->rows[2] )
	};
}

// Performs a double3x2_lerp function on each row of the matrix.
HLML_INLINE double3x2 double3x2_lerp( const double3x2* lhs, const double3x2* rhs, const double t )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		double2_lerp( &lhs->rows[1], &rhs->rows[1], t ),
		double2_lerp( &lhs->rows[2], &rhs->rows[2], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double3x2_equals( const double3x2* lhs, const double3x2* rhs )
{
	return
		double2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		double2_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		double2_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double3x2_not_equals( const double3x2* lhs, const double3x2* rhs )
{
	return !double3x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x2 double3x2_less_than( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		double2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		double2_less_than( &lhs->rows[1], &rhs->rows[1] ),
		double2_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 double3x2_less_than_equal( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		double2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double2_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		double2_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x2 double3x2_greater_than( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		double2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		double2_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		double2_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 double3x2_greater_than_equal( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		double2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		double2_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double3x2 double3x2_cadds( const double3x2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_cadds( &lhs->rows[0], rhs ),
		double2_cadds( &lhs->rows[1], rhs ),
		double2_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double3x2 double3x2_caddm( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		double2_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double3x2 double3x2_csubs( const double3x2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_csubs( &lhs->rows[0], rhs ),
		double2_csubs( &lhs->rows[1], rhs ),
		double2_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double3x2 double3x2_csubm( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		double2_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double3x2 double3x2_cmuls( const double3x2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_cmuls( &lhs->rows[0], rhs ),
		double2_cmuls( &lhs->rows[1], rhs ),
		double2_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double3x2 double3x2_cmulm( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double3x2 double3x2_cdivs( const double3x2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_cdivs( &lhs->rows[0], rhs ),
		double2_cdivs( &lhs->rows[1], rhs ),
		double2_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double3x2 double3x2_cdivm( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		double2_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE double3x2 double3x2_negate( const double3x2* x )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		double2_negate( &x->rows[0] ),
		double2_negate( &x->rows[1] ),
		double2_negate( &x->rows[2] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void double3x2_identity( double3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
	mat->rows[2] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double2x3 double3x2_transpose( const double3x2* mat )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double3x3 double3x2_mulm( const double3x2* lhs, const double2x3* rhs )
{
	double2 row0 = lhs->rows[0];
	double2 row1 = lhs->rows[1];
	double2 row2 = lhs->rows[2];

	double2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	double2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	double2 col2 = { rhs->rows[0].z, rhs->rows[1].z };

	return HLML_CONSTRUCT( double3x3 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

// double3x3
// Performs a double3x3_sign function on each row of the matrix.
HLML_INLINE int3x3 double3x3_sign( const double3x3* x )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		double3_sign( &x->rows[0] ),
		double3_sign( &x->rows[1] ),
		double3_sign( &x->rows[2] )
	};
}

// Performs a double3x3_min function on each row of the matrix.
HLML_INLINE double3x3 double3x3_min( const double3x3* x, const double3x3* y )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_min( &x->rows[0], &y->rows[0] ),
		double3_min( &x->rows[1], &y->rows[1] ),
		double3_min( &x->rows[2], &y->rows[2] )
	};
}

// Performs a double3x3_max function on each row of the matrix.
HLML_INLINE double3x3 double3x3_max( const double3x3* x, const double3x3* y )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_max( &x->rows[0], &y->rows[0] ),
		double3_max( &x->rows[1], &y->rows[1] ),
		double3_max( &x->rows[2], &y->rows[2] )
	};
}

// Performs a double3x3_clamp function on each row of the matrix.
HLML_INLINE double3x3 double3x3_clamp( const double3x3* x, const double3x3* low, const double3x3* high )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		double3_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		double3_clamp( &x->rows[2], &low->rows[2], &high->rows[2] )
	};
}

// Performs a double3x3_saturate function on each row of the matrix.
HLML_INLINE double3x3 double3x3_saturate( const double3x3* x )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_saturate( &x->rows[0] ),
		double3_saturate( &x->rows[1] ),
		double3_saturate( &x->rows[2] )
	};
}

// Performs a double3x3_lerp function on each row of the matrix.
HLML_INLINE double3x3 double3x3_lerp( const double3x3* lhs, const double3x3* rhs, const double t )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		double3_lerp( &lhs->rows[1], &rhs->rows[1], t ),
		double3_lerp( &lhs->rows[2], &rhs->rows[2], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double3x3_equals( const double3x3* lhs, const double3x3* rhs )
{
	return
		double3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		double3_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		double3_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double3x3_not_equals( const double3x3* lhs, const double3x3* rhs )
{
	return !double3x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x3 double3x3_less_than( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		double3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		double3_less_than( &lhs->rows[1], &rhs->rows[1] ),
		double3_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 double3x3_less_than_equal( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		double3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double3_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		double3_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x3 double3x3_greater_than( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		double3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		double3_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		double3_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 double3x3_greater_than_equal( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		double3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		double3_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double3x3 double3x3_cadds( const double3x3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_cadds( &lhs->rows[0], rhs ),
		double3_cadds( &lhs->rows[1], rhs ),
		double3_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double3x3 double3x3_caddm( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		double3_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double3x3 double3x3_csubs( const double3x3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_csubs( &lhs->rows[0], rhs ),
		double3_csubs( &lhs->rows[1], rhs ),
		double3_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double3x3 double3x3_csubm( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		double3_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double3x3 double3x3_cmuls( const double3x3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_cmuls( &lhs->rows[0], rhs ),
		double3_cmuls( &lhs->rows[1], rhs ),
		double3_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double3x3 double3x3_cmulm( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double3x3 double3x3_cdivs( const double3x3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_cdivs( &lhs->rows[0], rhs ),
		double3_cdivs( &lhs->rows[1], rhs ),
		double3_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double3x3 double3x3_cdivm( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		double3_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE double3x3 double3x3_negate( const double3x3* x )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		double3_negate( &x->rows[0] ),
		double3_negate( &x->rows[1] ),
		double3_negate( &x->rows[2] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void double3x3_identity( double3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
	mat->rows[2] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 1.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double3x3 double3x3_transpose( const double3x3* mat )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

// Returns the determinant of the matrix.
HLML_INLINE double double3x3_determinant( const double3x3* mat )
{
	return
		+ mat->rows[0].x * ( mat->rows[1].y * mat->rows[2].z - mat->rows[2].y * mat->rows[1].z ) 
		- mat->rows[0].y * ( mat->rows[1].x * mat->rows[2].z - mat->rows[2].x * mat->rows[1].z ) 
		+ mat->rows[0].z * ( mat->rows[1].x * mat->rows[2].y - mat->rows[2].x * mat->rows[1].y );
}

// Returns a copy of the matrix that is inversed.
// This is only applicable for square matrices.
HLML_INLINE double3x3 double3x3_inverse( const double3x3* mat )
{
	const double invdet = 1.0 / double3x3_determinant( mat );
	return HLML_CONSTRUCT( double3x3 )
	{
		 ( mat->rows[1].y * mat->rows[2].z - mat->rows[1].z * mat->rows[2].y ) * invdet,
		-( mat->rows[0].y * mat->rows[2].z - mat->rows[0].z * mat->rows[2].y ) * invdet,
		 ( mat->rows[0].y * mat->rows[1].z - mat->rows[0].z * mat->rows[1].y ) * invdet,

		-( mat->rows[1].x * mat->rows[2].z - mat->rows[1].z * mat->rows[2].x ) * invdet,
		 ( mat->rows[0].x * mat->rows[2].z - mat->rows[0].z * mat->rows[2].x ) * invdet,
		-( mat->rows[0].x * mat->rows[1].z - mat->rows[0].z * mat->rows[1].x ) * invdet,

		 ( mat->rows[1].x * mat->rows[2].y - mat->rows[1].y * mat->rows[2].x ) * invdet,
		-( mat->rows[0].x * mat->rows[2].y - mat->rows[0].y * mat->rows[2].x ) * invdet,
		 ( mat->rows[0].x * mat->rows[1].y - mat->rows[0].y * mat->rows[1].x ) * invdet
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double3x3 double3x3_mulm( const double3x3* lhs, const double3x3* rhs )
{
	double3 row0 = lhs->rows[0];
	double3 row1 = lhs->rows[1];
	double3 row2 = lhs->rows[2];

	double3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	double3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	double3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };

	return HLML_CONSTRUCT( double3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE double3 double3x3_mulv( const double3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3 )
	{
		( lhs->x * rhs->rows[0].x ) + ( lhs->y * rhs->rows[1].x ) + ( lhs->z * rhs->rows[2].x ),
		( lhs->x * rhs->rows[0].y ) + ( lhs->y * rhs->rows[1].y ) + ( lhs->z * rhs->rows[2].y ),
		( lhs->x * rhs->rows[0].z ) + ( lhs->y * rhs->rows[1].z ) + ( lhs->z * rhs->rows[2].z )
	};
}

// double3x4
// Performs a double3x4_sign function on each row of the matrix.
HLML_INLINE int3x4 double3x4_sign( const double3x4* x )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		double4_sign( &x->rows[0] ),
		double4_sign( &x->rows[1] ),
		double4_sign( &x->rows[2] )
	};
}

// Performs a double3x4_min function on each row of the matrix.
HLML_INLINE double3x4 double3x4_min( const double3x4* x, const double3x4* y )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_min( &x->rows[0], &y->rows[0] ),
		double4_min( &x->rows[1], &y->rows[1] ),
		double4_min( &x->rows[2], &y->rows[2] )
	};
}

// Performs a double3x4_max function on each row of the matrix.
HLML_INLINE double3x4 double3x4_max( const double3x4* x, const double3x4* y )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_max( &x->rows[0], &y->rows[0] ),
		double4_max( &x->rows[1], &y->rows[1] ),
		double4_max( &x->rows[2], &y->rows[2] )
	};
}

// Performs a double3x4_clamp function on each row of the matrix.
HLML_INLINE double3x4 double3x4_clamp( const double3x4* x, const double3x4* low, const double3x4* high )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		double4_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		double4_clamp( &x->rows[2], &low->rows[2], &high->rows[2] )
	};
}

// Performs a double3x4_saturate function on each row of the matrix.
HLML_INLINE double3x4 double3x4_saturate( const double3x4* x )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_saturate( &x->rows[0] ),
		double4_saturate( &x->rows[1] ),
		double4_saturate( &x->rows[2] )
	};
}

// Performs a double3x4_lerp function on each row of the matrix.
HLML_INLINE double3x4 double3x4_lerp( const double3x4* lhs, const double3x4* rhs, const double t )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		double4_lerp( &lhs->rows[1], &rhs->rows[1], t ),
		double4_lerp( &lhs->rows[2], &rhs->rows[2], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double3x4_equals( const double3x4* lhs, const double3x4* rhs )
{
	return
		double4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		double4_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		double4_equals( &lhs->rows[2], &rhs->rows[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double3x4_not_equals( const double3x4* lhs, const double3x4* rhs )
{
	return !double3x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x4 double3x4_less_than( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		double4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		double4_less_than( &lhs->rows[1], &rhs->rows[1] ),
		double4_less_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 double3x4_less_than_equal( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		double4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double4_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		double4_less_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x4 double3x4_greater_than( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		double4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		double4_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		double4_greater_than( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 double3x4_greater_than_equal( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		double4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		double4_greater_than_equal( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double3x4 double3x4_cadds( const double3x4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_cadds( &lhs->rows[0], rhs ),
		double4_cadds( &lhs->rows[1], rhs ),
		double4_cadds( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double3x4 double3x4_caddm( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		double4_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double3x4 double3x4_csubs( const double3x4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_csubs( &lhs->rows[0], rhs ),
		double4_csubs( &lhs->rows[1], rhs ),
		double4_csubs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double3x4 double3x4_csubm( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		double4_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double3x4 double3x4_cmuls( const double3x4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_cmuls( &lhs->rows[0], rhs ),
		double4_cmuls( &lhs->rows[1], rhs ),
		double4_cmuls( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double3x4 double3x4_cmulm( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double3x4 double3x4_cdivs( const double3x4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_cdivs( &lhs->rows[0], rhs ),
		double4_cdivs( &lhs->rows[1], rhs ),
		double4_cdivs( &lhs->rows[2], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double3x4 double3x4_cdivm( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		double4_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE double3x4 double3x4_negate( const double3x4* x )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		double4_negate( &x->rows[0] ),
		double4_negate( &x->rows[1] ),
		double4_negate( &x->rows[2] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void double3x4_identity( double3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
	mat->rows[2] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 1.0, 0.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double4x3 double3x4_transpose( const double3x4* mat )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double3x3 double3x4_mulm( const double3x4* lhs, const double4x3* rhs )
{
	double4 row0 = lhs->rows[0];
	double4 row1 = lhs->rows[1];
	double4 row2 = lhs->rows[2];

	double4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	double4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	double4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };

	return HLML_CONSTRUCT( double3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

// double4x2
// Performs a double4x2_sign function on each row of the matrix.
HLML_INLINE int4x2 double4x2_sign( const double4x2* x )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		double2_sign( &x->rows[0] ),
		double2_sign( &x->rows[1] ),
		double2_sign( &x->rows[2] ),
		double2_sign( &x->rows[3] )
	};
}

// Performs a double4x2_min function on each row of the matrix.
HLML_INLINE double4x2 double4x2_min( const double4x2* x, const double4x2* y )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_min( &x->rows[0], &y->rows[0] ),
		double2_min( &x->rows[1], &y->rows[1] ),
		double2_min( &x->rows[2], &y->rows[2] ),
		double2_min( &x->rows[3], &y->rows[3] )
	};
}

// Performs a double4x2_max function on each row of the matrix.
HLML_INLINE double4x2 double4x2_max( const double4x2* x, const double4x2* y )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_max( &x->rows[0], &y->rows[0] ),
		double2_max( &x->rows[1], &y->rows[1] ),
		double2_max( &x->rows[2], &y->rows[2] ),
		double2_max( &x->rows[3], &y->rows[3] )
	};
}

// Performs a double4x2_clamp function on each row of the matrix.
HLML_INLINE double4x2 double4x2_clamp( const double4x2* x, const double4x2* low, const double4x2* high )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		double2_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		double2_clamp( &x->rows[2], &low->rows[2], &high->rows[2] ),
		double2_clamp( &x->rows[3], &low->rows[3], &high->rows[3] )
	};
}

// Performs a double4x2_saturate function on each row of the matrix.
HLML_INLINE double4x2 double4x2_saturate( const double4x2* x )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_saturate( &x->rows[0] ),
		double2_saturate( &x->rows[1] ),
		double2_saturate( &x->rows[2] ),
		double2_saturate( &x->rows[3] )
	};
}

// Performs a double4x2_lerp function on each row of the matrix.
HLML_INLINE double4x2 double4x2_lerp( const double4x2* lhs, const double4x2* rhs, const double t )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		double2_lerp( &lhs->rows[1], &rhs->rows[1], t ),
		double2_lerp( &lhs->rows[2], &rhs->rows[2], t ),
		double2_lerp( &lhs->rows[3], &rhs->rows[3], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double4x2_equals( const double4x2* lhs, const double4x2* rhs )
{
	return
		double2_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		double2_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		double2_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		double2_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double4x2_not_equals( const double4x2* lhs, const double4x2* rhs )
{
	return !double4x2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x2 double4x2_less_than( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		double2_less_than( &lhs->rows[0], &rhs->rows[0] ),
		double2_less_than( &lhs->rows[1], &rhs->rows[1] ),
		double2_less_than( &lhs->rows[2], &rhs->rows[2] ),
		double2_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 double4x2_less_than_equal( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		double2_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double2_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		double2_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		double2_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x2 double4x2_greater_than( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		double2_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		double2_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		double2_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		double2_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 double4x2_greater_than_equal( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		double2_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double2_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		double2_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		double2_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double4x2 double4x2_cadds( const double4x2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_cadds( &lhs->rows[0], rhs ),
		double2_cadds( &lhs->rows[1], rhs ),
		double2_cadds( &lhs->rows[2], rhs ),
		double2_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double4x2 double4x2_caddm( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		double2_caddv( &lhs->rows[2], &rhs->rows[2] ),
		double2_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double4x2 double4x2_csubs( const double4x2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_csubs( &lhs->rows[0], rhs ),
		double2_csubs( &lhs->rows[1], rhs ),
		double2_csubs( &lhs->rows[2], rhs ),
		double2_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double4x2 double4x2_csubm( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		double2_csubv( &lhs->rows[2], &rhs->rows[2] ),
		double2_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double4x2 double4x2_cmuls( const double4x2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_cmuls( &lhs->rows[0], rhs ),
		double2_cmuls( &lhs->rows[1], rhs ),
		double2_cmuls( &lhs->rows[2], rhs ),
		double2_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double4x2 double4x2_cmulm( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		double2_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double4x2 double4x2_cdivs( const double4x2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_cdivs( &lhs->rows[0], rhs ),
		double2_cdivs( &lhs->rows[1], rhs ),
		double2_cdivs( &lhs->rows[2], rhs ),
		double2_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double4x2 double4x2_cdivm( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		double2_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		double2_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE double4x2 double4x2_negate( const double4x2* x )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		double2_negate( &x->rows[0] ),
		double2_negate( &x->rows[1] ),
		double2_negate( &x->rows[2] ),
		double2_negate( &x->rows[3] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void double4x2_identity( double4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
	mat->rows[2] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
	mat->rows[3] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double2x4 double4x2_transpose( const double4x2* mat )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double4x4 double4x2_mulm( const double4x2* lhs, const double2x4* rhs )
{
	double2 row0 = lhs->rows[0];
	double2 row1 = lhs->rows[1];
	double2 row2 = lhs->rows[2];
	double2 row3 = lhs->rows[3];

	double2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	double2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	double2 col2 = { rhs->rows[0].z, rhs->rows[1].z };
	double2 col3 = { rhs->rows[0].w, rhs->rows[1].w };

	return HLML_CONSTRUCT( double4x4 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

// double4x3
// Performs a double4x3_sign function on each row of the matrix.
HLML_INLINE int4x3 double4x3_sign( const double4x3* x )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		double3_sign( &x->rows[0] ),
		double3_sign( &x->rows[1] ),
		double3_sign( &x->rows[2] ),
		double3_sign( &x->rows[3] )
	};
}

// Performs a double4x3_min function on each row of the matrix.
HLML_INLINE double4x3 double4x3_min( const double4x3* x, const double4x3* y )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_min( &x->rows[0], &y->rows[0] ),
		double3_min( &x->rows[1], &y->rows[1] ),
		double3_min( &x->rows[2], &y->rows[2] ),
		double3_min( &x->rows[3], &y->rows[3] )
	};
}

// Performs a double4x3_max function on each row of the matrix.
HLML_INLINE double4x3 double4x3_max( const double4x3* x, const double4x3* y )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_max( &x->rows[0], &y->rows[0] ),
		double3_max( &x->rows[1], &y->rows[1] ),
		double3_max( &x->rows[2], &y->rows[2] ),
		double3_max( &x->rows[3], &y->rows[3] )
	};
}

// Performs a double4x3_clamp function on each row of the matrix.
HLML_INLINE double4x3 double4x3_clamp( const double4x3* x, const double4x3* low, const double4x3* high )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		double3_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		double3_clamp( &x->rows[2], &low->rows[2], &high->rows[2] ),
		double3_clamp( &x->rows[3], &low->rows[3], &high->rows[3] )
	};
}

// Performs a double4x3_saturate function on each row of the matrix.
HLML_INLINE double4x3 double4x3_saturate( const double4x3* x )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_saturate( &x->rows[0] ),
		double3_saturate( &x->rows[1] ),
		double3_saturate( &x->rows[2] ),
		double3_saturate( &x->rows[3] )
	};
}

// Performs a double4x3_lerp function on each row of the matrix.
HLML_INLINE double4x3 double4x3_lerp( const double4x3* lhs, const double4x3* rhs, const double t )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		double3_lerp( &lhs->rows[1], &rhs->rows[1], t ),
		double3_lerp( &lhs->rows[2], &rhs->rows[2], t ),
		double3_lerp( &lhs->rows[3], &rhs->rows[3], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double4x3_equals( const double4x3* lhs, const double4x3* rhs )
{
	return
		double3_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		double3_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		double3_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		double3_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double4x3_not_equals( const double4x3* lhs, const double4x3* rhs )
{
	return !double4x3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x3 double4x3_less_than( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		double3_less_than( &lhs->rows[0], &rhs->rows[0] ),
		double3_less_than( &lhs->rows[1], &rhs->rows[1] ),
		double3_less_than( &lhs->rows[2], &rhs->rows[2] ),
		double3_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 double4x3_less_than_equal( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		double3_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double3_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		double3_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		double3_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x3 double4x3_greater_than( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		double3_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		double3_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		double3_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		double3_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 double4x3_greater_than_equal( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		double3_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double3_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		double3_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		double3_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double4x3 double4x3_cadds( const double4x3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_cadds( &lhs->rows[0], rhs ),
		double3_cadds( &lhs->rows[1], rhs ),
		double3_cadds( &lhs->rows[2], rhs ),
		double3_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double4x3 double4x3_caddm( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		double3_caddv( &lhs->rows[2], &rhs->rows[2] ),
		double3_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double4x3 double4x3_csubs( const double4x3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_csubs( &lhs->rows[0], rhs ),
		double3_csubs( &lhs->rows[1], rhs ),
		double3_csubs( &lhs->rows[2], rhs ),
		double3_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double4x3 double4x3_csubm( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		double3_csubv( &lhs->rows[2], &rhs->rows[2] ),
		double3_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double4x3 double4x3_cmuls( const double4x3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_cmuls( &lhs->rows[0], rhs ),
		double3_cmuls( &lhs->rows[1], rhs ),
		double3_cmuls( &lhs->rows[2], rhs ),
		double3_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double4x3 double4x3_cmulm( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		double3_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double4x3 double4x3_cdivs( const double4x3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_cdivs( &lhs->rows[0], rhs ),
		double3_cdivs( &lhs->rows[1], rhs ),
		double3_cdivs( &lhs->rows[2], rhs ),
		double3_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double4x3 double4x3_cdivm( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		double3_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		double3_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE double4x3 double4x3_negate( const double4x3* x )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		double3_negate( &x->rows[0] ),
		double3_negate( &x->rows[1] ),
		double3_negate( &x->rows[2] ),
		double3_negate( &x->rows[3] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void double4x3_identity( double4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
	mat->rows[2] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 1.0 };
	mat->rows[3] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 0.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double3x4 double4x3_transpose( const double4x3* mat )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double4x4 double4x3_mulm( const double4x3* lhs, const double3x4* rhs )
{
	double3 row0 = lhs->rows[0];
	double3 row1 = lhs->rows[1];
	double3 row2 = lhs->rows[2];
	double3 row3 = lhs->rows[3];

	double3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	double3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	double3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };
	double3 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w };

	return HLML_CONSTRUCT( double4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

// double4x4
// Performs a double4x4_sign function on each row of the matrix.
HLML_INLINE int4x4 double4x4_sign( const double4x4* x )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		double4_sign( &x->rows[0] ),
		double4_sign( &x->rows[1] ),
		double4_sign( &x->rows[2] ),
		double4_sign( &x->rows[3] )
	};
}

// Performs a double4x4_min function on each row of the matrix.
HLML_INLINE double4x4 double4x4_min( const double4x4* x, const double4x4* y )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_min( &x->rows[0], &y->rows[0] ),
		double4_min( &x->rows[1], &y->rows[1] ),
		double4_min( &x->rows[2], &y->rows[2] ),
		double4_min( &x->rows[3], &y->rows[3] )
	};
}

// Performs a double4x4_max function on each row of the matrix.
HLML_INLINE double4x4 double4x4_max( const double4x4* x, const double4x4* y )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_max( &x->rows[0], &y->rows[0] ),
		double4_max( &x->rows[1], &y->rows[1] ),
		double4_max( &x->rows[2], &y->rows[2] ),
		double4_max( &x->rows[3], &y->rows[3] )
	};
}

// Performs a double4x4_clamp function on each row of the matrix.
HLML_INLINE double4x4 double4x4_clamp( const double4x4* x, const double4x4* low, const double4x4* high )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_clamp( &x->rows[0], &low->rows[0], &high->rows[0] ),
		double4_clamp( &x->rows[1], &low->rows[1], &high->rows[1] ),
		double4_clamp( &x->rows[2], &low->rows[2], &high->rows[2] ),
		double4_clamp( &x->rows[3], &low->rows[3], &high->rows[3] )
	};
}

// Performs a double4x4_saturate function on each row of the matrix.
HLML_INLINE double4x4 double4x4_saturate( const double4x4* x )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_saturate( &x->rows[0] ),
		double4_saturate( &x->rows[1] ),
		double4_saturate( &x->rows[2] ),
		double4_saturate( &x->rows[3] )
	};
}

// Performs a double4x4_lerp function on each row of the matrix.
HLML_INLINE double4x4 double4x4_lerp( const double4x4* lhs, const double4x4* rhs, const double t )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_lerp( &lhs->rows[0], &rhs->rows[0], t ),
		double4_lerp( &lhs->rows[1], &rhs->rows[1], t ),
		double4_lerp( &lhs->rows[2], &rhs->rows[2], t ),
		double4_lerp( &lhs->rows[3], &rhs->rows[3], t )
	};
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double4x4_equals( const double4x4* lhs, const double4x4* rhs )
{
	return
		double4_equals( &lhs->rows[0], &rhs->rows[0] ) &&
		double4_equals( &lhs->rows[1], &rhs->rows[1] ) &&
		double4_equals( &lhs->rows[2], &rhs->rows[2] ) &&
		double4_equals( &lhs->rows[3], &rhs->rows[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double4x4_not_equals( const double4x4* lhs, const double4x4* rhs )
{
	return !double4x4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x4 double4x4_less_than( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		double4_less_than( &lhs->rows[0], &rhs->rows[0] ),
		double4_less_than( &lhs->rows[1], &rhs->rows[1] ),
		double4_less_than( &lhs->rows[2], &rhs->rows[2] ),
		double4_less_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 double4x4_less_than_equal( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		double4_less_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double4_less_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		double4_less_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		double4_less_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x4 double4x4_greater_than( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		double4_greater_than( &lhs->rows[0], &rhs->rows[0] ),
		double4_greater_than( &lhs->rows[1], &rhs->rows[1] ),
		double4_greater_than( &lhs->rows[2], &rhs->rows[2] ),
		double4_greater_than( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 double4x4_greater_than_equal( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		double4_greater_than_equal( &lhs->rows[0], &rhs->rows[0] ),
		double4_greater_than_equal( &lhs->rows[1], &rhs->rows[1] ),
		double4_greater_than_equal( &lhs->rows[2], &rhs->rows[2] ),
		double4_greater_than_equal( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double4x4 double4x4_cadds( const double4x4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_cadds( &lhs->rows[0], rhs ),
		double4_cadds( &lhs->rows[1], rhs ),
		double4_cadds( &lhs->rows[2], rhs ),
		double4_cadds( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double4x4 double4x4_caddm( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		double4_caddv( &lhs->rows[2], &rhs->rows[2] ),
		double4_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double4x4 double4x4_csubs( const double4x4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_csubs( &lhs->rows[0], rhs ),
		double4_csubs( &lhs->rows[1], rhs ),
		double4_csubs( &lhs->rows[2], rhs ),
		double4_csubs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double4x4 double4x4_csubm( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		double4_csubv( &lhs->rows[2], &rhs->rows[2] ),
		double4_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double4x4 double4x4_cmuls( const double4x4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_cmuls( &lhs->rows[0], rhs ),
		double4_cmuls( &lhs->rows[1], rhs ),
		double4_cmuls( &lhs->rows[2], rhs ),
		double4_cmuls( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double4x4 double4x4_cmulm( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		double4_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double4x4 double4x4_cdivs( const double4x4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_cdivs( &lhs->rows[0], rhs ),
		double4_cdivs( &lhs->rows[1], rhs ),
		double4_cdivs( &lhs->rows[2], rhs ),
		double4_cdivs( &lhs->rows[3], rhs )
	};
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double4x4 double4x4_cdivm( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		double4_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		double4_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

// Returns a copy of the matrix that has been negated.
HLML_INLINE double4x4 double4x4_negate( const double4x4* x )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		double4_negate( &x->rows[0] ),
		double4_negate( &x->rows[1] ),
		double4_negate( &x->rows[2] ),
		double4_negate( &x->rows[3] )
	};
}

// Sets the matrix to an identity matrix.
HLML_INLINE void double4x4_identity( double4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
	mat->rows[2] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 1.0, 0.0 };
	mat->rows[3] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 0.0, 1.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double4x4 double4x4_transpose( const double4x4* mat )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

// Returns the determinant of the matrix.
HLML_INLINE double double4x4_determinant( const double4x4* mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	double sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	double sub01 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	double sub02 = mat->rows[2].y * mat->rows[3].z - mat->rows[3].y * mat->rows[2].z;
	double sub03 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	double sub04 = mat->rows[2].x * mat->rows[3].z - mat->rows[3].x * mat->rows[2].z;
	double sub05 = mat->rows[2].x * mat->rows[3].y - mat->rows[3].x * mat->rows[2].y;

	double4 cofactor = HLML_CONSTRUCT( double4 )
	{
		 ( ( ( mat->rows[1].y * sub00 ) - ( mat->rows[1].z * sub01 ) ) + ( mat->rows[1].w * sub02 ) ),
		-( ( ( mat->rows[1].x * sub00 ) - ( mat->rows[1].z * sub03 ) ) + ( mat->rows[1].w * sub04 ) ),
		 ( ( ( mat->rows[1].x * sub01 ) - ( mat->rows[1].y * sub03 ) ) + ( mat->rows[1].w * sub05 ) ),
		-( ( ( mat->rows[1].x * sub02 ) - ( mat->rows[1].y * sub04 ) ) + ( mat->rows[1].z * sub05 ) ) 
	};

	return
		mat->rows[0].x * cofactor.x + mat->rows[0].y * cofactor.y +
		mat->rows[0].z * cofactor.z + mat->rows[0].w * cofactor.w; 
}

// Returns a copy of the matrix that is inversed.
// This is only applicable for square matrices.
HLML_INLINE double4x4 double4x4_inverse( const double4x4* mat )
{
	// uses the glm version, which is basically just an optimised version of the adjugate formula
	double sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	double sub01 = mat->rows[1].z * mat->rows[3].w - mat->rows[1].w * mat->rows[2].w;
	double sub02 = mat->rows[1].z * mat->rows[2].w - mat->rows[1].w * mat->rows[2].z;

	double sub03 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	double sub04 = mat->rows[1].y * mat->rows[3].w - mat->rows[1].w * mat->rows[3].y;
	double sub05 = mat->rows[1].y * mat->rows[2].w - mat->rows[1].w * mat->rows[2].y;

	double sub06 = mat->rows[2].y * mat->rows[3].z - mat->rows[2].z * mat->rows[3].y;
	double sub07 = mat->rows[1].y * mat->rows[3].z - mat->rows[1].z * mat->rows[3].y;
	double sub08 = mat->rows[1].y * mat->rows[2].z - mat->rows[1].z * mat->rows[2].y;

	double sub09 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	double sub10 = mat->rows[1].x * mat->rows[3].w - mat->rows[3].x * mat->rows[1].w;
	double sub11 = mat->rows[1].x * mat->rows[2].w - mat->rows[2].x * mat->rows[1].w;

	double sub12 = mat->rows[2].x * mat->rows[3].z - mat->rows[2].z * mat->rows[3].x;
	double sub13 = mat->rows[1].x * mat->rows[3].z - mat->rows[1].z * mat->rows[3].x;
	double sub14 = mat->rows[1].x * mat->rows[2].z - mat->rows[1].z * mat->rows[2].x;

	double sub15 = mat->rows[2].x * mat->rows[3].y - mat->rows[2].y * mat->rows[3].x;
	double sub16 = mat->rows[1].x * mat->rows[3].y - mat->rows[1].y * mat->rows[3].x;
	double sub17 = mat->rows[1].x * mat->rows[2].y - mat->rows[1].y * mat->rows[2].x;

	double4 fac0 = { sub00, sub00, sub01, sub02 };
	double4 fac1 = { sub03, sub03, sub04, sub05 };
	double4 fac2 = { sub06, sub06, sub07, sub08 };
	double4 fac3 = { sub09, sub09, sub10, sub11 };
	double4 fac4 = { sub12, sub12, sub13, sub14 };
	double4 fac5 = { sub15, sub15, sub16, sub17 };

	double4 vec0 = { mat->rows[1].x, mat->rows[0].x, mat->rows[0].x, mat->rows[0].x };
	double4 vec1 = { mat->rows[1].y, mat->rows[0].y, mat->rows[0].y, mat->rows[0].y };
	double4 vec2 = { mat->rows[1].z, mat->rows[0].z, mat->rows[0].z, mat->rows[0].z };
	double4 vec3 = { mat->rows[1].w, mat->rows[0].w, mat->rows[0].w, mat->rows[0].w };

	double4 inv0mula = double4_cmulv( &vec1, &fac0 );
	double4 inv0mulb = double4_cmulv( &vec2, &fac1 );
	double4 inv0mulc = double4_cmulv( &vec3, &fac2 );
	double4 inv0     = double4_csubv( &inv0mula, &inv0mulb );
	inv0 = double4_caddv( &inv0, &inv0mulc );

	double4 inv1mula = double4_cmulv( &vec0, &fac0 );
	double4 inv1mulb = double4_cmulv( &vec2, &fac3 );
	double4 inv1mulc = double4_cmulv( &vec3, &fac4 );
	double4 inv1     = double4_csubv( &inv1mula, &inv1mulb );
	inv1 = double4_caddv( &inv1, &inv1mulc );

	double4 inv2mula = double4_cmulv( &vec0, &fac1 );
	double4 inv2mulb = double4_cmulv( &vec1, &fac3 );
	double4 inv2mulc = double4_cmulv( &vec3, &fac5 );
	double4 inv2     = double4_csubv( &inv2mula, &inv2mulb );
	inv2 = double4_caddv( &inv2, &inv2mulc );

	double4 inv3mula = double4_cmulv( &vec0, &fac2 );
	double4 inv3mulb = double4_cmulv( &vec1, &fac4 );
	double4 inv3mulc = double4_cmulv( &vec2, &fac5 );
	double4 inv3     = double4_csubv( &inv3mula, &inv3mulb );
	inv3 = double4_caddv( &inv3, &inv3mulc );


	double4 sign0 = {  1, -1,  1, -1 };
	double4 sign1 = { -1,  1, -1,  1 };

	double4x4 result = {
		double4_cmulv( &inv0, &sign0 ),
		double4_cmulv( &inv1, &sign1 ),
		double4_cmulv( &inv2, &sign0 ),
		double4_cmulv( &inv3, &sign1 )
	};

	double4 col0 = { result.rows[0].x, result.rows[1].x, result.rows[2].x, result.rows[3].x };
	double4 dot0 = double4_cmulv( &mat->rows[0], &col0 );

	const double dot1 = ( dot0.x + dot0.y ) + ( dot0.z + dot0.w );

	const double invdet = 1.0 / dot1;

	return double4x4_cmuls( &result, invdet );
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double4x4 double4x4_mulm( const double4x4* lhs, const double4x4* rhs )
{
	double4 row0 = lhs->rows[0];
	double4 row1 = lhs->rows[1];
	double4 row2 = lhs->rows[2];
	double4 row3 = lhs->rows[3];

	double4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	double4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	double4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };
	double4 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w, rhs->rows[3].w };

	return HLML_CONSTRUCT( double4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE double4 double4x4_mulv( const double4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4 )
	{
		( lhs->x * rhs->rows[0].x ) + ( lhs->y * rhs->rows[1].x ) + ( lhs->z * rhs->rows[2].x ) + ( lhs->w * rhs->rows[3].x ),
		( lhs->x * rhs->rows[0].y ) + ( lhs->y * rhs->rows[1].y ) + ( lhs->z * rhs->rows[2].y ) + ( lhs->w * rhs->rows[3].y ),
		( lhs->x * rhs->rows[0].z ) + ( lhs->y * rhs->rows[1].z ) + ( lhs->z * rhs->rows[2].z ) + ( lhs->w * rhs->rows[3].z ),
		( lhs->x * rhs->rows[0].w ) + ( lhs->y * rhs->rows[1].w ) + ( lhs->z * rhs->rows[2].w ) + ( lhs->w * rhs->rows[3].w )
	};
}

// "Translates" the matrix.  Adds the last column of 'mat' by the position vector 'vec'.
HLML_INLINE double4x4 double4x4_translate( const double4x4* mat, const double3* vec )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z,
		mat->rows[3].x, mat->rows[3].y, mat->rows[3].z, mat->rows[3].w
	};
}

// Rotates the matrix by the given axis-angle (in radians) and returns the result.
HLML_INLINE double4x4 double4x4_rotate( const double4x4* mat, const double rad, const double3* axis )
{
	const double c = cos( rad );
	const double s = sin( rad );

	double3 u = double3_normalized( axis );
	double ic = 1.0 - c;

	double4x4 rotation = *mat;
	rotation.rows[0].x = c + u.x * ic;
	rotation.rows[0].y = u.x * u.y * ic - u.z * s;
	rotation.rows[0].z = u.x * u.z * ic + u.y * s;

	rotation.rows[1].x = u.y * u.x * ic + u.z * s;
	rotation.rows[1].y = c + u.y * ic;
	rotation.rows[1].z = u.y * u.z * ic - u.x * s;

	rotation.rows[2].x = u.z * u.x * ic - u.y * s;
	rotation.rows[2].y = u.z * u.y * ic + u.x * s;
	rotation.rows[2].z = c + u.z * ic;

	return double4x4_mulm( mat, &rotation );
}

// Applies a non-uniform scale to the matrix and returns the result.
HLML_INLINE double4x4 double4x4_scale( const double4x4* mat, const double3* scale )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		mat->rows[0].x * scale->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * scale->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z * scale->z,
		mat->rows[2].w,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z,
		mat->rows[3].w
	};
}

// Returns an left-handed orthographic projection matrix with the clip-space range 0 to 1.
HLML_INLINE double4x4 double4x4_ortho_lh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// left-handed, clip space range: zero-to-one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( double4x4 )
	{
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, 1.0 / far_minus_near, -znear / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

// Returns an left-handed orthographic projection matrix with the clip-space range -1 to 1.
HLML_INLINE double4x4 double4x4_ortho_lh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// left-handed, clip space range: minus-one-to-one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( double4x4 )
	{
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, 2.0 / far_minus_near, -far_plus_near / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

// Returns an right-handed orthographic projection matrix with the clip-space range 0 to 1.
HLML_INLINE double4x4 double4x4_ortho_rh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// right-handed, clip space range: zero-to-one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( double4x4 )
	{
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, -1.0 / far_minus_near, -znear / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

// Returns an right-handed orthographic projection matrix with the clip-space range -1 to 1.
HLML_INLINE double4x4 double4x4_ortho_rh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// right-handed, clip space range: minus-one-to-one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( double4x4 )
	{
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, -2.0 / far_minus_near, -far_plus_near / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

// Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of 0 to 1.
HLML_INLINE double4x4 double4x4_perspective_lh_zo( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// left-handed, clip space range: zero-to-one
	const double far_minus_near = zfar - znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 )
	{
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, zfar / far_minus_near, -( zfar * znear ) / far_minus_near,
		0.0, 0.0, 1.0, 0.0
	};
}

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of -1 to 1.
HLML_INLINE double4x4 double4x4_perspective_lh_no( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// left-handed, clip space range: minus-one-to-one
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 )
	{
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, far_plus_near / far_minus_near, -( 2.0 * zfar * znear ) / far_minus_near,
		0.0, 0.0, 1.0, 0.0
	};
}

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of 0 to 1.
HLML_INLINE double4x4 double4x4_perspective_rh_zo( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// right-handed, clip space range: zero-to-one
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 )
	{
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, zfar / ( znear - zfar ), -( zfar * znear ) / ( zfar - znear ),
		0.0, 0.0, -1.0, 0.0
	};
}

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of -1 to 1.
HLML_INLINE double4x4 double4x4_perspective_rh_no( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// right-handed, clip space range: minus-one-to-one
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 )
	{
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, -far_plus_near / far_minus_near, -( 2.0 * zfar * znear ) / far_minus_near,
		0.0, 0.0, -1.0, 0.0
	};
}

// Returns a left-handed orthonormal matrix that is oriented at position 'eye' to look at position 'target'.
HLML_INLINE double4x4 double4x4_look_at_lh( const double3* eye, const double3* target, const double3* up )
{
	// left handed
	const double3 eye_to_target = double3_csubv( target, eye );
	const double3 forward = double3_normalized( &eye_to_target );
	const double3 up_cross_forward = double3_cross( up, &forward );
	const double3 right = double3_normalized( &up_cross_forward );
	const double3 up1 = double3_cross( &forward, &right );

	return HLML_CONSTRUCT( double4x4 )
	{
		right.x,   right.y,   right.z,   -double3_dot( &right, eye ),
		up1.x,     up1.y,     up1.z,     -double3_dot( &up1, eye ),
		forward.x, forward.y, forward.z, -double3_dot( &forward, eye ),
		0.0, 0.0, 0.0, 1.0
	};
}

// Returns a right-handed orthonormal matrix that is oriented at position 'eye' to look at position 'target'.
HLML_INLINE double4x4 double4x4_look_at_rh( const double3* eye, const double3* target, const double3* up )
{
	// right handed
	const double3 eye_to_target = double3_csubv( target, eye );
	const double3 forward = double3_normalized( &eye_to_target );
	const double3 forward_cross_up = double3_cross( &forward, up );
	const double3 right = double3_normalized( &forward_cross_up );
	const double3 up1 = double3_cross( &right, &forward );

	return HLML_CONSTRUCT( double4x4 )
	{
		 right.x,    right.y,    right.z,   -double3_dot( &right, eye ),
		 up1.x,      up1.y,      up1.z,     -double3_dot( &up1, eye ),
		-forward.x, -forward.y, -forward.z,  double3_dot( &forward, eye ),
		0.0, 0.0, 0.0, 1.0
	};
}

#ifdef __cplusplus
}
#endif
