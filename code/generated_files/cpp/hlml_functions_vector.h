/*
===========================================================================

HLML.

MIT License

Copyright (c) 2019 Dan Moody

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===========================================================================
*/

// THIS FILE WAS AUTOMATICALLY GENERATED BY A TOOL.
// EDITING THIS FILE MAY CAUSE SIDE EFFECTS.
// DO SO AT YOUR OWN RISK.

#pragma once

#include "hlml_defines.h"

#include "bool2.inl"
#include "bool3.inl"
#include "bool4.inl"
#include "int2.inl"
#include "int3.inl"
#include "int4.inl"
#include "uint2.inl"
#include "uint3.inl"
#include "uint4.inl"
#include "float2.inl"
#include "float3.inl"
#include "float4.inl"
#include "double2.inl"
#include "double3.inl"
#include "double4.inl"

#include "hlml_functions_scalar.h"

// bool2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const bool2& lhs, const bool2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const bool2& lhs, const bool2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool2 operator<( const bool2& lhs, const bool2& rhs )
{
	return bool2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool2 operator<=( const bool2& lhs, const bool2& rhs )
{
	return bool2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool2 operator>( const bool2& lhs, const bool2& rhs )
{
	return bool2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool2 operator>=( const bool2& lhs, const bool2& rhs )
{
	return bool2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE bool2 operator+( const bool2& lhs, const bool32_t rhs )
{
	return bool2(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE bool2 operator+=( bool2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE bool2 operator+( const bool2& lhs, const bool2& rhs )
{
	return bool2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE bool2 operator+=( bool2& lhs, const bool2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE bool2 operator-( const bool2& lhs, const bool32_t rhs )
{
	return bool2(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE bool2 operator-=( bool2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE bool2 operator-( const bool2& lhs, const bool2& rhs )
{
	return bool2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE bool2 operator-=( bool2& lhs, const bool2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE bool2 operator*( const bool2& lhs, const bool32_t rhs )
{
	return bool2(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE bool2 operator*=( bool2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE bool2 operator*( const bool2& lhs, const bool2& rhs )
{
	return bool2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE bool2 operator*=( bool2& lhs, const bool2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE bool2 operator/( const bool2& lhs, const bool32_t rhs )
{
	return bool2(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE bool2 operator/=( bool2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE bool2 operator/( const bool2& lhs, const bool2& rhs )
{
	return bool2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE bool2 operator/=( bool2& lhs, const bool2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE bool2 operator++( bool2& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE bool2 operator++( bool2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE bool2 operator--( bool2& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE bool2 operator--( bool2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool all( const bool2* x )
{
	return x->x && x->y;
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool any( const bool2* x )
{
	return x->x || x->y;
}

// bool3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const bool3& lhs, const bool3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const bool3& lhs, const bool3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool3 operator<( const bool3& lhs, const bool3& rhs )
{
	return bool3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool3 operator<=( const bool3& lhs, const bool3& rhs )
{
	return bool3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool3 operator>( const bool3& lhs, const bool3& rhs )
{
	return bool3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool3 operator>=( const bool3& lhs, const bool3& rhs )
{
	return bool3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE bool3 operator+( const bool3& lhs, const bool32_t rhs )
{
	return bool3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE bool3 operator+=( bool3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE bool3 operator+( const bool3& lhs, const bool3& rhs )
{
	return bool3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE bool3 operator+=( bool3& lhs, const bool3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE bool3 operator-( const bool3& lhs, const bool32_t rhs )
{
	return bool3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE bool3 operator-=( bool3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE bool3 operator-( const bool3& lhs, const bool3& rhs )
{
	return bool3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE bool3 operator-=( bool3& lhs, const bool3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE bool3 operator*( const bool3& lhs, const bool32_t rhs )
{
	return bool3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE bool3 operator*=( bool3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE bool3 operator*( const bool3& lhs, const bool3& rhs )
{
	return bool3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE bool3 operator*=( bool3& lhs, const bool3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE bool3 operator/( const bool3& lhs, const bool32_t rhs )
{
	return bool3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE bool3 operator/=( bool3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE bool3 operator/( const bool3& lhs, const bool3& rhs )
{
	return bool3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE bool3 operator/=( bool3& lhs, const bool3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE bool3 operator++( bool3& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE bool3 operator++( bool3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE bool3 operator--( bool3& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE bool3 operator--( bool3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool all( const bool3* x )
{
	return x->x && x->y && x->z;
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool any( const bool3* x )
{
	return x->x || x->y || x->z;
}

// bool4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const bool4& lhs, const bool4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const bool4& lhs, const bool4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool4 operator<( const bool4& lhs, const bool4& rhs )
{
	return bool4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool4 operator<=( const bool4& lhs, const bool4& rhs )
{
	return bool4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool4 operator>( const bool4& lhs, const bool4& rhs )
{
	return bool4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool4 operator>=( const bool4& lhs, const bool4& rhs )
{
	return bool4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE bool4 operator+( const bool4& lhs, const bool32_t rhs )
{
	return bool4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE bool4 operator+=( bool4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE bool4 operator+( const bool4& lhs, const bool4& rhs )
{
	return bool4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE bool4 operator+=( bool4& lhs, const bool4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE bool4 operator-( const bool4& lhs, const bool32_t rhs )
{
	return bool4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE bool4 operator-=( bool4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE bool4 operator-( const bool4& lhs, const bool4& rhs )
{
	return bool4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE bool4 operator-=( bool4& lhs, const bool4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE bool4 operator*( const bool4& lhs, const bool32_t rhs )
{
	return bool4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE bool4 operator*=( bool4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE bool4 operator*( const bool4& lhs, const bool4& rhs )
{
	return bool4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE bool4 operator*=( bool4& lhs, const bool4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE bool4 operator/( const bool4& lhs, const bool32_t rhs )
{
	return bool4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE bool4 operator/=( bool4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE bool4 operator/( const bool4& lhs, const bool4& rhs )
{
	return bool4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE bool4 operator/=( bool4& lhs, const bool4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE bool4 operator++( bool4& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE bool4 operator++( bool4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE bool4 operator--( bool4& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE bool4 operator--( bool4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool all( const bool4* x )
{
	return x->x && x->y && x->z && x->w;
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool any( const bool4* x )
{
	return x->x || x->y || x->z || x->w;
}

// int2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const int2& lhs, const int2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const int2& lhs, const int2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool2 operator<( const int2& lhs, const int2& rhs )
{
	return bool2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool2 operator<=( const int2& lhs, const int2& rhs )
{
	return bool2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool2 operator>( const int2& lhs, const int2& rhs )
{
	return bool2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool2 operator>=( const int2& lhs, const int2& rhs )
{
	return bool2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE int2 operator+( const int2& lhs, const int32_t rhs )
{
	return int2(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE int2 operator+=( int2& lhs, const int32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE int2 operator+( const int2& lhs, const int2& rhs )
{
	return int2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE int2 operator+=( int2& lhs, const int2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE int2 operator-( const int2& lhs, const int32_t rhs )
{
	return int2(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE int2 operator-=( int2& lhs, const int32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE int2 operator-( const int2& lhs, const int2& rhs )
{
	return int2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE int2 operator-=( int2& lhs, const int2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE int2 operator*( const int2& lhs, const int32_t rhs )
{
	return int2(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE int2 operator*=( int2& lhs, const int32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE int2 operator*( const int2& lhs, const int2& rhs )
{
	return int2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE int2 operator*=( int2& lhs, const int2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE int2 operator/( const int2& lhs, const int32_t rhs )
{
	return int2(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE int2 operator/=( int2& lhs, const int32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE int2 operator/( const int2& lhs, const int2& rhs )
{
	return int2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE int2 operator/=( int2& lhs, const int2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE int2 operator++( int2& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE int2 operator++( int2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE int2 operator--( int2& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE int2 operator--( int2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the vector that has been negated.
// pre-fix
HLML_INLINE int2 operator-( const int2& x )
{
	return int2(
		-x[0],
		-x[1]
	);
}

// Returns a copy of the vector where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE int2 operator~( const int2& x )
{
	return int2(
		~x[0],
		~x[1]
	);
}

// Performs a component-wise bitwise & on the vector by the scalar and returns the result.
HLML_INLINE int2 operator&( const int2& lhs, const int32_t rhs )
{
	return int2(
		lhs[0] & rhs,
		lhs[1] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE int2 operator&=( int2& lhs, const int32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two vectors and returns the result.
HLML_INLINE int2 operator&( const int2& lhs, const int2& rhs )
{
	return int2(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE int2 operator&=( int2& lhs, const int2& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the vector by the scalar and returns the result.
HLML_INLINE int2 operator|( const int2& lhs, const int32_t rhs )
{
	return int2(
		lhs[0] | rhs,
		lhs[1] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE int2 operator|=( int2& lhs, const int32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two vectors and returns the result.
HLML_INLINE int2 operator|( const int2& lhs, const int2& rhs )
{
	return int2(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE int2 operator|=( int2& lhs, const int2& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the vector by the scalar and returns the result.
HLML_INLINE int2 operator^( const int2& lhs, const int32_t rhs )
{
	return int2(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE int2 operator^=( int2& lhs, const int32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two vectors and returns the result.
HLML_INLINE int2 operator^( const int2& lhs, const int2& rhs )
{
	return int2(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE int2 operator^=( int2& lhs, const int2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the vector by the scalar and returns the result.
HLML_INLINE int2 operator<<( const int2& lhs, const int32_t rhs )
{
	return int2(
		lhs[0] << rhs,
		lhs[1] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE int2 operator<<=( int2& lhs, const int32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two vectors and returns the result.
HLML_INLINE int2 operator<<( const int2& lhs, const int2& rhs )
{
	return int2(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE int2 operator<<=( int2& lhs, const int2& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the vector by the scalar and returns the result.
HLML_INLINE int2 operator>>( const int2& lhs, const int32_t rhs )
{
	return int2(
		lhs[0] >> rhs,
		lhs[1] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE int2 operator>>=( int2& lhs, const int32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two vectors and returns the result.
HLML_INLINE int2 operator>>( const int2& lhs, const int2& rhs )
{
	return int2(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE int2 operator>>=( int2& lhs, const int2& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a sign function on each component of the vector.
HLML_INLINE int2 sign( const int2& x )
{
	return int2(
		sign( x[0] ),
		sign( x[1] )
	);
}

// Performs a min function on each component of the vector.
HLML_INLINE int2 min( const int2& x, const int2& y )
{
	return int2(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each component of the vector.
HLML_INLINE int2 max( const int2& x, const int2& y )
{
	return int2(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each component of the vector.
HLML_INLINE int2 clamp( const int2& x, const int2& low, const int2& high )
{
	return int2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each component of the vector.
HLML_INLINE int2 saturate( const int2& x )
{
	return int2(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Returns the magnitude of vector squared.
HLML_INLINE float lengthsq( const int2& vec )
{
	return (float)( ( vec.x * vec.x ) + ( vec.y * vec.y ) );
}

// Returns the magnitude of the vector.
HLML_INLINE float length( const int2& vec )
{
	return sqrtf( lengthsq( vec ) );
}

// Returns the dot product of the two vectors.
HLML_INLINE int32_t dot( const int2& lhs, const int2& rhs )
{
	return ( lhs.x * rhs.x ) + ( lhs.y * rhs.y );
}

// Returns the squared distance between the two vectors.
HLML_INLINE float distancesq( const int2& lhs, const int2& rhs )
{
	return lengthsq( lhs - rhs );
}

// Returns the distance between the two vectors.
HLML_INLINE float distance( const int2& lhs, const int2& rhs )
{
	return length( lhs - rhs );
}

// int3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const int3& lhs, const int3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const int3& lhs, const int3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool3 operator<( const int3& lhs, const int3& rhs )
{
	return bool3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool3 operator<=( const int3& lhs, const int3& rhs )
{
	return bool3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool3 operator>( const int3& lhs, const int3& rhs )
{
	return bool3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool3 operator>=( const int3& lhs, const int3& rhs )
{
	return bool3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE int3 operator+( const int3& lhs, const int32_t rhs )
{
	return int3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE int3 operator+=( int3& lhs, const int32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE int3 operator+( const int3& lhs, const int3& rhs )
{
	return int3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE int3 operator+=( int3& lhs, const int3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE int3 operator-( const int3& lhs, const int32_t rhs )
{
	return int3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE int3 operator-=( int3& lhs, const int32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE int3 operator-( const int3& lhs, const int3& rhs )
{
	return int3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE int3 operator-=( int3& lhs, const int3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE int3 operator*( const int3& lhs, const int32_t rhs )
{
	return int3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE int3 operator*=( int3& lhs, const int32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE int3 operator*( const int3& lhs, const int3& rhs )
{
	return int3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE int3 operator*=( int3& lhs, const int3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE int3 operator/( const int3& lhs, const int32_t rhs )
{
	return int3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE int3 operator/=( int3& lhs, const int32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE int3 operator/( const int3& lhs, const int3& rhs )
{
	return int3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE int3 operator/=( int3& lhs, const int3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE int3 operator++( int3& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE int3 operator++( int3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE int3 operator--( int3& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE int3 operator--( int3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the vector that has been negated.
// pre-fix
HLML_INLINE int3 operator-( const int3& x )
{
	return int3(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Returns a copy of the vector where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE int3 operator~( const int3& x )
{
	return int3(
		~x[0],
		~x[1],
		~x[2]
	);
}

// Performs a component-wise bitwise & on the vector by the scalar and returns the result.
HLML_INLINE int3 operator&( const int3& lhs, const int32_t rhs )
{
	return int3(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE int3 operator&=( int3& lhs, const int32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two vectors and returns the result.
HLML_INLINE int3 operator&( const int3& lhs, const int3& rhs )
{
	return int3(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE int3 operator&=( int3& lhs, const int3& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the vector by the scalar and returns the result.
HLML_INLINE int3 operator|( const int3& lhs, const int32_t rhs )
{
	return int3(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE int3 operator|=( int3& lhs, const int32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two vectors and returns the result.
HLML_INLINE int3 operator|( const int3& lhs, const int3& rhs )
{
	return int3(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE int3 operator|=( int3& lhs, const int3& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the vector by the scalar and returns the result.
HLML_INLINE int3 operator^( const int3& lhs, const int32_t rhs )
{
	return int3(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE int3 operator^=( int3& lhs, const int32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two vectors and returns the result.
HLML_INLINE int3 operator^( const int3& lhs, const int3& rhs )
{
	return int3(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE int3 operator^=( int3& lhs, const int3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the vector by the scalar and returns the result.
HLML_INLINE int3 operator<<( const int3& lhs, const int32_t rhs )
{
	return int3(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE int3 operator<<=( int3& lhs, const int32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two vectors and returns the result.
HLML_INLINE int3 operator<<( const int3& lhs, const int3& rhs )
{
	return int3(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE int3 operator<<=( int3& lhs, const int3& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the vector by the scalar and returns the result.
HLML_INLINE int3 operator>>( const int3& lhs, const int32_t rhs )
{
	return int3(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE int3 operator>>=( int3& lhs, const int32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two vectors and returns the result.
HLML_INLINE int3 operator>>( const int3& lhs, const int3& rhs )
{
	return int3(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE int3 operator>>=( int3& lhs, const int3& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a sign function on each component of the vector.
HLML_INLINE int3 sign( const int3& x )
{
	return int3(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] )
	);
}

// Performs a min function on each component of the vector.
HLML_INLINE int3 min( const int3& x, const int3& y )
{
	return int3(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each component of the vector.
HLML_INLINE int3 max( const int3& x, const int3& y )
{
	return int3(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each component of the vector.
HLML_INLINE int3 clamp( const int3& x, const int3& low, const int3& high )
{
	return int3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each component of the vector.
HLML_INLINE int3 saturate( const int3& x )
{
	return int3(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Returns the magnitude of vector squared.
HLML_INLINE float lengthsq( const int3& vec )
{
	return (float)( ( vec.x * vec.x ) + ( vec.y * vec.y ) + ( vec.z * vec.z ) );
}

// Returns the magnitude of the vector.
HLML_INLINE float length( const int3& vec )
{
	return sqrtf( lengthsq( vec ) );
}

// Returns the dot product of the two vectors.
HLML_INLINE int32_t dot( const int3& lhs, const int3& rhs )
{
	return ( lhs.x * rhs.x ) + ( lhs.y * rhs.y ) + ( lhs.z * rhs.z );
}

// Returns the squared distance between the two vectors.
HLML_INLINE float distancesq( const int3& lhs, const int3& rhs )
{
	return lengthsq( lhs - rhs );
}

// Returns the distance between the two vectors.
HLML_INLINE float distance( const int3& lhs, const int3& rhs )
{
	return length( lhs - rhs );
}

// int4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const int4& lhs, const int4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const int4& lhs, const int4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool4 operator<( const int4& lhs, const int4& rhs )
{
	return bool4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool4 operator<=( const int4& lhs, const int4& rhs )
{
	return bool4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool4 operator>( const int4& lhs, const int4& rhs )
{
	return bool4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool4 operator>=( const int4& lhs, const int4& rhs )
{
	return bool4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE int4 operator+( const int4& lhs, const int32_t rhs )
{
	return int4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE int4 operator+=( int4& lhs, const int32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE int4 operator+( const int4& lhs, const int4& rhs )
{
	return int4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE int4 operator+=( int4& lhs, const int4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE int4 operator-( const int4& lhs, const int32_t rhs )
{
	return int4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE int4 operator-=( int4& lhs, const int32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE int4 operator-( const int4& lhs, const int4& rhs )
{
	return int4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE int4 operator-=( int4& lhs, const int4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE int4 operator*( const int4& lhs, const int32_t rhs )
{
	return int4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE int4 operator*=( int4& lhs, const int32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE int4 operator*( const int4& lhs, const int4& rhs )
{
	return int4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE int4 operator*=( int4& lhs, const int4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE int4 operator/( const int4& lhs, const int32_t rhs )
{
	return int4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE int4 operator/=( int4& lhs, const int32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE int4 operator/( const int4& lhs, const int4& rhs )
{
	return int4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE int4 operator/=( int4& lhs, const int4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE int4 operator++( int4& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE int4 operator++( int4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE int4 operator--( int4& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE int4 operator--( int4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the vector that has been negated.
// pre-fix
HLML_INLINE int4 operator-( const int4& x )
{
	return int4(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Returns a copy of the vector where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE int4 operator~( const int4& x )
{
	return int4(
		~x[0],
		~x[1],
		~x[2],
		~x[3]
	);
}

// Performs a component-wise bitwise & on the vector by the scalar and returns the result.
HLML_INLINE int4 operator&( const int4& lhs, const int32_t rhs )
{
	return int4(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs,
		lhs[3] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE int4 operator&=( int4& lhs, const int32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two vectors and returns the result.
HLML_INLINE int4 operator&( const int4& lhs, const int4& rhs )
{
	return int4(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2],
		lhs[3] & rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE int4 operator&=( int4& lhs, const int4& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the vector by the scalar and returns the result.
HLML_INLINE int4 operator|( const int4& lhs, const int32_t rhs )
{
	return int4(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs,
		lhs[3] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE int4 operator|=( int4& lhs, const int32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two vectors and returns the result.
HLML_INLINE int4 operator|( const int4& lhs, const int4& rhs )
{
	return int4(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2],
		lhs[3] | rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE int4 operator|=( int4& lhs, const int4& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the vector by the scalar and returns the result.
HLML_INLINE int4 operator^( const int4& lhs, const int32_t rhs )
{
	return int4(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs,
		lhs[3] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE int4 operator^=( int4& lhs, const int32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two vectors and returns the result.
HLML_INLINE int4 operator^( const int4& lhs, const int4& rhs )
{
	return int4(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2],
		lhs[3] ^ rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE int4 operator^=( int4& lhs, const int4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the vector by the scalar and returns the result.
HLML_INLINE int4 operator<<( const int4& lhs, const int32_t rhs )
{
	return int4(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs,
		lhs[3] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE int4 operator<<=( int4& lhs, const int32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two vectors and returns the result.
HLML_INLINE int4 operator<<( const int4& lhs, const int4& rhs )
{
	return int4(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2],
		lhs[3] << rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE int4 operator<<=( int4& lhs, const int4& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the vector by the scalar and returns the result.
HLML_INLINE int4 operator>>( const int4& lhs, const int32_t rhs )
{
	return int4(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs,
		lhs[3] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE int4 operator>>=( int4& lhs, const int32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two vectors and returns the result.
HLML_INLINE int4 operator>>( const int4& lhs, const int4& rhs )
{
	return int4(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2],
		lhs[3] >> rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE int4 operator>>=( int4& lhs, const int4& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a sign function on each component of the vector.
HLML_INLINE int4 sign( const int4& x )
{
	return int4(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] ),
		sign( x[3] )
	);
}

// Performs a min function on each component of the vector.
HLML_INLINE int4 min( const int4& x, const int4& y )
{
	return int4(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each component of the vector.
HLML_INLINE int4 max( const int4& x, const int4& y )
{
	return int4(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each component of the vector.
HLML_INLINE int4 clamp( const int4& x, const int4& low, const int4& high )
{
	return int4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each component of the vector.
HLML_INLINE int4 saturate( const int4& x )
{
	return int4(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Returns the magnitude of vector squared.
HLML_INLINE float lengthsq( const int4& vec )
{
	return (float)( ( vec.x * vec.x ) + ( vec.y * vec.y ) + ( vec.z * vec.z ) + ( vec.w * vec.w ) );
}

// Returns the magnitude of the vector.
HLML_INLINE float length( const int4& vec )
{
	return sqrtf( lengthsq( vec ) );
}

// Returns the dot product of the two vectors.
HLML_INLINE int32_t dot( const int4& lhs, const int4& rhs )
{
	return ( lhs.x * rhs.x ) + ( lhs.y * rhs.y ) + ( lhs.z * rhs.z ) + ( lhs.w * rhs.w );
}

// uint2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const uint2& lhs, const uint2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const uint2& lhs, const uint2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool2 operator<( const uint2& lhs, const uint2& rhs )
{
	return bool2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool2 operator<=( const uint2& lhs, const uint2& rhs )
{
	return bool2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool2 operator>( const uint2& lhs, const uint2& rhs )
{
	return bool2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool2 operator>=( const uint2& lhs, const uint2& rhs )
{
	return bool2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE uint2 operator+( const uint2& lhs, const uint32_t rhs )
{
	return uint2(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE uint2 operator+=( uint2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE uint2 operator+( const uint2& lhs, const uint2& rhs )
{
	return uint2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE uint2 operator+=( uint2& lhs, const uint2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE uint2 operator-( const uint2& lhs, const uint32_t rhs )
{
	return uint2(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE uint2 operator-=( uint2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE uint2 operator-( const uint2& lhs, const uint2& rhs )
{
	return uint2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE uint2 operator-=( uint2& lhs, const uint2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE uint2 operator*( const uint2& lhs, const uint32_t rhs )
{
	return uint2(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE uint2 operator*=( uint2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE uint2 operator*( const uint2& lhs, const uint2& rhs )
{
	return uint2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE uint2 operator*=( uint2& lhs, const uint2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE uint2 operator/( const uint2& lhs, const uint32_t rhs )
{
	return uint2(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE uint2 operator/=( uint2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE uint2 operator/( const uint2& lhs, const uint2& rhs )
{
	return uint2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE uint2 operator/=( uint2& lhs, const uint2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE uint2 operator++( uint2& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE uint2 operator++( uint2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE uint2 operator--( uint2& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE uint2 operator--( uint2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the vector that has been negated.
// pre-fix
HLML_INLINE uint2 operator-( const uint2& x )
{
	return uint2(
		-x[0],
		-x[1]
	);
}

// Returns a copy of the vector where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE uint2 operator~( const uint2& x )
{
	return uint2(
		~x[0],
		~x[1]
	);
}

// Performs a component-wise bitwise & on the vector by the scalar and returns the result.
HLML_INLINE uint2 operator&( const uint2& lhs, const uint32_t rhs )
{
	return uint2(
		lhs[0] & rhs,
		lhs[1] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE uint2 operator&=( uint2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two vectors and returns the result.
HLML_INLINE uint2 operator&( const uint2& lhs, const uint2& rhs )
{
	return uint2(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE uint2 operator&=( uint2& lhs, const uint2& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the vector by the scalar and returns the result.
HLML_INLINE uint2 operator|( const uint2& lhs, const uint32_t rhs )
{
	return uint2(
		lhs[0] | rhs,
		lhs[1] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE uint2 operator|=( uint2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two vectors and returns the result.
HLML_INLINE uint2 operator|( const uint2& lhs, const uint2& rhs )
{
	return uint2(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE uint2 operator|=( uint2& lhs, const uint2& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the vector by the scalar and returns the result.
HLML_INLINE uint2 operator^( const uint2& lhs, const uint32_t rhs )
{
	return uint2(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE uint2 operator^=( uint2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two vectors and returns the result.
HLML_INLINE uint2 operator^( const uint2& lhs, const uint2& rhs )
{
	return uint2(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE uint2 operator^=( uint2& lhs, const uint2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the vector by the scalar and returns the result.
HLML_INLINE uint2 operator<<( const uint2& lhs, const uint32_t rhs )
{
	return uint2(
		lhs[0] << rhs,
		lhs[1] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE uint2 operator<<=( uint2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two vectors and returns the result.
HLML_INLINE uint2 operator<<( const uint2& lhs, const uint2& rhs )
{
	return uint2(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE uint2 operator<<=( uint2& lhs, const uint2& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the vector by the scalar and returns the result.
HLML_INLINE uint2 operator>>( const uint2& lhs, const uint32_t rhs )
{
	return uint2(
		lhs[0] >> rhs,
		lhs[1] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE uint2 operator>>=( uint2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two vectors and returns the result.
HLML_INLINE uint2 operator>>( const uint2& lhs, const uint2& rhs )
{
	return uint2(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE uint2 operator>>=( uint2& lhs, const uint2& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a min function on each component of the vector.
HLML_INLINE uint2 min( const uint2& x, const uint2& y )
{
	return uint2(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each component of the vector.
HLML_INLINE uint2 max( const uint2& x, const uint2& y )
{
	return uint2(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each component of the vector.
HLML_INLINE uint2 clamp( const uint2& x, const uint2& low, const uint2& high )
{
	return uint2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each component of the vector.
HLML_INLINE uint2 saturate( const uint2& x )
{
	return uint2(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Returns the magnitude of vector squared.
HLML_INLINE float lengthsq( const uint2& vec )
{
	return (float)( ( vec.x * vec.x ) + ( vec.y * vec.y ) );
}

// Returns the magnitude of the vector.
HLML_INLINE float length( const uint2& vec )
{
	return sqrtf( lengthsq( vec ) );
}

// Returns the dot product of the two vectors.
HLML_INLINE uint32_t dot( const uint2& lhs, const uint2& rhs )
{
	return ( lhs.x * rhs.x ) + ( lhs.y * rhs.y );
}

// Returns the squared distance between the two vectors.
HLML_INLINE float distancesq( const uint2& lhs, const uint2& rhs )
{
	return lengthsq( lhs - rhs );
}

// Returns the distance between the two vectors.
HLML_INLINE float distance( const uint2& lhs, const uint2& rhs )
{
	return length( lhs - rhs );
}

// uint3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const uint3& lhs, const uint3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const uint3& lhs, const uint3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool3 operator<( const uint3& lhs, const uint3& rhs )
{
	return bool3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool3 operator<=( const uint3& lhs, const uint3& rhs )
{
	return bool3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool3 operator>( const uint3& lhs, const uint3& rhs )
{
	return bool3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool3 operator>=( const uint3& lhs, const uint3& rhs )
{
	return bool3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE uint3 operator+( const uint3& lhs, const uint32_t rhs )
{
	return uint3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE uint3 operator+=( uint3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE uint3 operator+( const uint3& lhs, const uint3& rhs )
{
	return uint3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE uint3 operator+=( uint3& lhs, const uint3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE uint3 operator-( const uint3& lhs, const uint32_t rhs )
{
	return uint3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE uint3 operator-=( uint3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE uint3 operator-( const uint3& lhs, const uint3& rhs )
{
	return uint3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE uint3 operator-=( uint3& lhs, const uint3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE uint3 operator*( const uint3& lhs, const uint32_t rhs )
{
	return uint3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE uint3 operator*=( uint3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE uint3 operator*( const uint3& lhs, const uint3& rhs )
{
	return uint3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE uint3 operator*=( uint3& lhs, const uint3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE uint3 operator/( const uint3& lhs, const uint32_t rhs )
{
	return uint3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE uint3 operator/=( uint3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE uint3 operator/( const uint3& lhs, const uint3& rhs )
{
	return uint3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE uint3 operator/=( uint3& lhs, const uint3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE uint3 operator++( uint3& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE uint3 operator++( uint3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE uint3 operator--( uint3& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE uint3 operator--( uint3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the vector that has been negated.
// pre-fix
HLML_INLINE uint3 operator-( const uint3& x )
{
	return uint3(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Returns a copy of the vector where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE uint3 operator~( const uint3& x )
{
	return uint3(
		~x[0],
		~x[1],
		~x[2]
	);
}

// Performs a component-wise bitwise & on the vector by the scalar and returns the result.
HLML_INLINE uint3 operator&( const uint3& lhs, const uint32_t rhs )
{
	return uint3(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE uint3 operator&=( uint3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two vectors and returns the result.
HLML_INLINE uint3 operator&( const uint3& lhs, const uint3& rhs )
{
	return uint3(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE uint3 operator&=( uint3& lhs, const uint3& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the vector by the scalar and returns the result.
HLML_INLINE uint3 operator|( const uint3& lhs, const uint32_t rhs )
{
	return uint3(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE uint3 operator|=( uint3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two vectors and returns the result.
HLML_INLINE uint3 operator|( const uint3& lhs, const uint3& rhs )
{
	return uint3(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE uint3 operator|=( uint3& lhs, const uint3& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the vector by the scalar and returns the result.
HLML_INLINE uint3 operator^( const uint3& lhs, const uint32_t rhs )
{
	return uint3(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE uint3 operator^=( uint3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two vectors and returns the result.
HLML_INLINE uint3 operator^( const uint3& lhs, const uint3& rhs )
{
	return uint3(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE uint3 operator^=( uint3& lhs, const uint3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the vector by the scalar and returns the result.
HLML_INLINE uint3 operator<<( const uint3& lhs, const uint32_t rhs )
{
	return uint3(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE uint3 operator<<=( uint3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two vectors and returns the result.
HLML_INLINE uint3 operator<<( const uint3& lhs, const uint3& rhs )
{
	return uint3(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE uint3 operator<<=( uint3& lhs, const uint3& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the vector by the scalar and returns the result.
HLML_INLINE uint3 operator>>( const uint3& lhs, const uint32_t rhs )
{
	return uint3(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE uint3 operator>>=( uint3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two vectors and returns the result.
HLML_INLINE uint3 operator>>( const uint3& lhs, const uint3& rhs )
{
	return uint3(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE uint3 operator>>=( uint3& lhs, const uint3& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a min function on each component of the vector.
HLML_INLINE uint3 min( const uint3& x, const uint3& y )
{
	return uint3(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each component of the vector.
HLML_INLINE uint3 max( const uint3& x, const uint3& y )
{
	return uint3(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each component of the vector.
HLML_INLINE uint3 clamp( const uint3& x, const uint3& low, const uint3& high )
{
	return uint3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each component of the vector.
HLML_INLINE uint3 saturate( const uint3& x )
{
	return uint3(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Returns the magnitude of vector squared.
HLML_INLINE float lengthsq( const uint3& vec )
{
	return (float)( ( vec.x * vec.x ) + ( vec.y * vec.y ) + ( vec.z * vec.z ) );
}

// Returns the magnitude of the vector.
HLML_INLINE float length( const uint3& vec )
{
	return sqrtf( lengthsq( vec ) );
}

// Returns the dot product of the two vectors.
HLML_INLINE uint32_t dot( const uint3& lhs, const uint3& rhs )
{
	return ( lhs.x * rhs.x ) + ( lhs.y * rhs.y ) + ( lhs.z * rhs.z );
}

// Returns the squared distance between the two vectors.
HLML_INLINE float distancesq( const uint3& lhs, const uint3& rhs )
{
	return lengthsq( lhs - rhs );
}

// Returns the distance between the two vectors.
HLML_INLINE float distance( const uint3& lhs, const uint3& rhs )
{
	return length( lhs - rhs );
}

// uint4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const uint4& lhs, const uint4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const uint4& lhs, const uint4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool4 operator<( const uint4& lhs, const uint4& rhs )
{
	return bool4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool4 operator<=( const uint4& lhs, const uint4& rhs )
{
	return bool4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool4 operator>( const uint4& lhs, const uint4& rhs )
{
	return bool4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool4 operator>=( const uint4& lhs, const uint4& rhs )
{
	return bool4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE uint4 operator+( const uint4& lhs, const uint32_t rhs )
{
	return uint4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE uint4 operator+=( uint4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE uint4 operator+( const uint4& lhs, const uint4& rhs )
{
	return uint4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE uint4 operator+=( uint4& lhs, const uint4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE uint4 operator-( const uint4& lhs, const uint32_t rhs )
{
	return uint4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE uint4 operator-=( uint4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE uint4 operator-( const uint4& lhs, const uint4& rhs )
{
	return uint4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE uint4 operator-=( uint4& lhs, const uint4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE uint4 operator*( const uint4& lhs, const uint32_t rhs )
{
	return uint4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE uint4 operator*=( uint4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE uint4 operator*( const uint4& lhs, const uint4& rhs )
{
	return uint4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE uint4 operator*=( uint4& lhs, const uint4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE uint4 operator/( const uint4& lhs, const uint32_t rhs )
{
	return uint4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE uint4 operator/=( uint4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE uint4 operator/( const uint4& lhs, const uint4& rhs )
{
	return uint4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE uint4 operator/=( uint4& lhs, const uint4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE uint4 operator++( uint4& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE uint4 operator++( uint4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE uint4 operator--( uint4& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE uint4 operator--( uint4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the vector that has been negated.
// pre-fix
HLML_INLINE uint4 operator-( const uint4& x )
{
	return uint4(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Returns a copy of the vector where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE uint4 operator~( const uint4& x )
{
	return uint4(
		~x[0],
		~x[1],
		~x[2],
		~x[3]
	);
}

// Performs a component-wise bitwise & on the vector by the scalar and returns the result.
HLML_INLINE uint4 operator&( const uint4& lhs, const uint32_t rhs )
{
	return uint4(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs,
		lhs[3] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE uint4 operator&=( uint4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two vectors and returns the result.
HLML_INLINE uint4 operator&( const uint4& lhs, const uint4& rhs )
{
	return uint4(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2],
		lhs[3] & rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE uint4 operator&=( uint4& lhs, const uint4& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the vector by the scalar and returns the result.
HLML_INLINE uint4 operator|( const uint4& lhs, const uint32_t rhs )
{
	return uint4(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs,
		lhs[3] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE uint4 operator|=( uint4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two vectors and returns the result.
HLML_INLINE uint4 operator|( const uint4& lhs, const uint4& rhs )
{
	return uint4(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2],
		lhs[3] | rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE uint4 operator|=( uint4& lhs, const uint4& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the vector by the scalar and returns the result.
HLML_INLINE uint4 operator^( const uint4& lhs, const uint32_t rhs )
{
	return uint4(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs,
		lhs[3] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE uint4 operator^=( uint4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two vectors and returns the result.
HLML_INLINE uint4 operator^( const uint4& lhs, const uint4& rhs )
{
	return uint4(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2],
		lhs[3] ^ rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE uint4 operator^=( uint4& lhs, const uint4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the vector by the scalar and returns the result.
HLML_INLINE uint4 operator<<( const uint4& lhs, const uint32_t rhs )
{
	return uint4(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs,
		lhs[3] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE uint4 operator<<=( uint4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two vectors and returns the result.
HLML_INLINE uint4 operator<<( const uint4& lhs, const uint4& rhs )
{
	return uint4(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2],
		lhs[3] << rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE uint4 operator<<=( uint4& lhs, const uint4& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the vector by the scalar and returns the result.
HLML_INLINE uint4 operator>>( const uint4& lhs, const uint32_t rhs )
{
	return uint4(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs,
		lhs[3] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE uint4 operator>>=( uint4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two vectors and returns the result.
HLML_INLINE uint4 operator>>( const uint4& lhs, const uint4& rhs )
{
	return uint4(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2],
		lhs[3] >> rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE uint4 operator>>=( uint4& lhs, const uint4& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a min function on each component of the vector.
HLML_INLINE uint4 min( const uint4& x, const uint4& y )
{
	return uint4(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each component of the vector.
HLML_INLINE uint4 max( const uint4& x, const uint4& y )
{
	return uint4(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each component of the vector.
HLML_INLINE uint4 clamp( const uint4& x, const uint4& low, const uint4& high )
{
	return uint4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each component of the vector.
HLML_INLINE uint4 saturate( const uint4& x )
{
	return uint4(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Returns the magnitude of vector squared.
HLML_INLINE float lengthsq( const uint4& vec )
{
	return (float)( ( vec.x * vec.x ) + ( vec.y * vec.y ) + ( vec.z * vec.z ) + ( vec.w * vec.w ) );
}

// Returns the magnitude of the vector.
HLML_INLINE float length( const uint4& vec )
{
	return sqrtf( lengthsq( vec ) );
}

// Returns the dot product of the two vectors.
HLML_INLINE uint32_t dot( const uint4& lhs, const uint4& rhs )
{
	return ( lhs.x * rhs.x ) + ( lhs.y * rhs.y ) + ( lhs.z * rhs.z ) + ( lhs.w * rhs.w );
}

// Returns a 32 bit integer containing each component of the vector at each byte (where the X component contains the left-most byte).
HLML_INLINE uint32_t pack( const uint4& vec )
{
	return ( vec.x << 24 ) | ( vec.y << 16 ) | ( vec.z << 8 ) | ( vec.w );
}

// Returns a 4-component int vector where each component contains each byte of the integer (where the X component contains the left-most byte).
HLML_INLINE uint4 unpack( const uint32_t x )
{
	return HLML_CONSTRUCT( uint4 )
	{
		( x >> 24 ) & 0xFF,
		( x >> 16 ) & 0xFF,
		( x >> 8 ) & 0xFF,
		( x >> 0 ) & 0xFF
	};
}

// float2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const float2& lhs, const float2& rhs )
{
	return
		floateq( lhs[0], rhs[0] ) &&
		floateq( lhs[1], rhs[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const float2& lhs, const float2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool2 operator<( const float2& lhs, const float2& rhs )
{
	return bool2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool2 operator<=( const float2& lhs, const float2& rhs )
{
	return bool2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool2 operator>( const float2& lhs, const float2& rhs )
{
	return bool2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool2 operator>=( const float2& lhs, const float2& rhs )
{
	return bool2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE float2 operator+( const float2& lhs, const float rhs )
{
	return float2(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE float2 operator+=( float2& lhs, const float rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE float2 operator+( const float2& lhs, const float2& rhs )
{
	return float2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE float2 operator+=( float2& lhs, const float2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE float2 operator-( const float2& lhs, const float rhs )
{
	return float2(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE float2 operator-=( float2& lhs, const float rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE float2 operator-( const float2& lhs, const float2& rhs )
{
	return float2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE float2 operator-=( float2& lhs, const float2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE float2 operator*( const float2& lhs, const float rhs )
{
	return float2(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE float2 operator*=( float2& lhs, const float rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE float2 operator*( const float2& lhs, const float2& rhs )
{
	return float2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE float2 operator*=( float2& lhs, const float2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE float2 operator/( const float2& lhs, const float rhs )
{
	return float2(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE float2 operator/=( float2& lhs, const float rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE float2 operator/( const float2& lhs, const float2& rhs )
{
	return float2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE float2 operator/=( float2& lhs, const float2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE float2 operator++( float2& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE float2 operator++( float2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE float2 operator--( float2& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE float2 operator--( float2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the vector that has been negated.
// pre-fix
HLML_INLINE float2 operator-( const float2& x )
{
	return float2(
		-x[0],
		-x[1]
	);
}

// Performs a sign function on each component of the vector.
HLML_INLINE int2 sign( const float2& x )
{
	return int2(
		sign( x[0] ),
		sign( x[1] )
	);
}

// Performs a min function on each component of the vector.
HLML_INLINE float2 min( const float2& x, const float2& y )
{
	return float2(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each component of the vector.
HLML_INLINE float2 max( const float2& x, const float2& y )
{
	return float2(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each component of the vector.
HLML_INLINE float2 clamp( const float2& x, const float2& low, const float2& high )
{
	return float2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each component of the vector.
HLML_INLINE float2 saturate( const float2& x )
{
	return float2(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Performs a lerp function on each component of the vector.
HLML_INLINE float2 lerp( const float2& lhs, const float2& rhs, const float t )
{
	return float2(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t )
	);
}

// Returns the magnitude of vector squared.
HLML_INLINE float lengthsq( const float2& vec )
{
	return ( vec.x * vec.x ) + ( vec.y * vec.y );
}

// Returns the magnitude of the vector.
HLML_INLINE float length( const float2& vec )
{
	return sqrtf( lengthsq( vec ) );
}

// Normalizes the vector.
HLML_INLINE void normalize( float2& vec )
{
	float invlen = 1.0f / length( vec );

	vec *= invlen;
}

// Returns a normalized copy of the vector.
HLML_INLINE float2 normalized( const float2& vec )
{
	float invlen = 1.0f / length( vec );

	return vec * invlen;
}

// Returns the dot product of the two vectors.
HLML_INLINE float dot( const float2& lhs, const float2& rhs )
{
	return ( lhs.x * rhs.x ) + ( lhs.y * rhs.y );
}

// Returns the angle (in degrees) between the two vectors.
HLML_INLINE float angle( const float2& lhs, const float2& rhs )
{
	return degrees( acosf( dot( normalized( lhs ), normalized( rhs ) ) ) );
}

// Returns the squared distance between the two vectors.
HLML_INLINE float distancesq( const float2& lhs, const float2& rhs )
{
	return lengthsq( lhs - rhs );
}

// Returns the distance between the two vectors.
HLML_INLINE float distance( const float2& lhs, const float2& rhs )
{
	return length( lhs - rhs );
}

// float3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const float3& lhs, const float3& rhs )
{
	return
		floateq( lhs[0], rhs[0] ) &&
		floateq( lhs[1], rhs[1] ) &&
		floateq( lhs[2], rhs[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const float3& lhs, const float3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool3 operator<( const float3& lhs, const float3& rhs )
{
	return bool3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool3 operator<=( const float3& lhs, const float3& rhs )
{
	return bool3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool3 operator>( const float3& lhs, const float3& rhs )
{
	return bool3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool3 operator>=( const float3& lhs, const float3& rhs )
{
	return bool3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE float3 operator+( const float3& lhs, const float rhs )
{
	return float3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE float3 operator+=( float3& lhs, const float rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE float3 operator+( const float3& lhs, const float3& rhs )
{
	return float3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE float3 operator+=( float3& lhs, const float3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE float3 operator-( const float3& lhs, const float rhs )
{
	return float3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE float3 operator-=( float3& lhs, const float rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE float3 operator-( const float3& lhs, const float3& rhs )
{
	return float3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE float3 operator-=( float3& lhs, const float3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE float3 operator*( const float3& lhs, const float rhs )
{
	return float3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE float3 operator*=( float3& lhs, const float rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE float3 operator*( const float3& lhs, const float3& rhs )
{
	return float3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE float3 operator*=( float3& lhs, const float3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE float3 operator/( const float3& lhs, const float rhs )
{
	return float3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE float3 operator/=( float3& lhs, const float rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE float3 operator/( const float3& lhs, const float3& rhs )
{
	return float3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE float3 operator/=( float3& lhs, const float3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE float3 operator++( float3& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE float3 operator++( float3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE float3 operator--( float3& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE float3 operator--( float3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the vector that has been negated.
// pre-fix
HLML_INLINE float3 operator-( const float3& x )
{
	return float3(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Performs a sign function on each component of the vector.
HLML_INLINE int3 sign( const float3& x )
{
	return int3(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] )
	);
}

// Performs a min function on each component of the vector.
HLML_INLINE float3 min( const float3& x, const float3& y )
{
	return float3(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each component of the vector.
HLML_INLINE float3 max( const float3& x, const float3& y )
{
	return float3(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each component of the vector.
HLML_INLINE float3 clamp( const float3& x, const float3& low, const float3& high )
{
	return float3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each component of the vector.
HLML_INLINE float3 saturate( const float3& x )
{
	return float3(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Performs a lerp function on each component of the vector.
HLML_INLINE float3 lerp( const float3& lhs, const float3& rhs, const float t )
{
	return float3(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t )
	);
}

// Returns the magnitude of vector squared.
HLML_INLINE float lengthsq( const float3& vec )
{
	return ( vec.x * vec.x ) + ( vec.y * vec.y ) + ( vec.z * vec.z );
}

// Returns the magnitude of the vector.
HLML_INLINE float length( const float3& vec )
{
	return sqrtf( lengthsq( vec ) );
}

// Normalizes the vector.
HLML_INLINE void normalize( float3& vec )
{
	float invlen = 1.0f / length( vec );

	vec *= invlen;
}

// Returns a normalized copy of the vector.
HLML_INLINE float3 normalized( const float3& vec )
{
	float invlen = 1.0f / length( vec );

	return vec * invlen;
}

// Returns the dot product of the two vectors.
HLML_INLINE float dot( const float3& lhs, const float3& rhs )
{
	return ( lhs.x * rhs.x ) + ( lhs.y * rhs.y ) + ( lhs.z * rhs.z );
}

// Returns a vector perpendicular to the two vectors.
HLML_INLINE float3 cross( const float3& lhs, const float3& rhs )
{
	return HLML_CONSTRUCT( float3 )
	{
		( lhs.y * rhs.z ) - ( lhs.z * rhs.y ),
		( lhs.z * rhs.x ) - ( lhs.x * rhs.z ),
		( lhs.x * rhs.y ) - ( lhs.y * rhs.x )
	};
}

// Returns the angle (in degrees) between the two vectors.
HLML_INLINE float angle( const float3& lhs, const float3& rhs )
{
	return degrees( acosf( dot( normalized( lhs ), normalized( rhs ) ) ) );
}

// Returns the squared distance between the two vectors.
HLML_INLINE float distancesq( const float3& lhs, const float3& rhs )
{
	return lengthsq( lhs - rhs );
}

// Returns the distance between the two vectors.
HLML_INLINE float distance( const float3& lhs, const float3& rhs )
{
	return length( lhs - rhs );
}

// float4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const float4& lhs, const float4& rhs )
{
	return
		floateq( lhs[0], rhs[0] ) &&
		floateq( lhs[1], rhs[1] ) &&
		floateq( lhs[2], rhs[2] ) &&
		floateq( lhs[3], rhs[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const float4& lhs, const float4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool4 operator<( const float4& lhs, const float4& rhs )
{
	return bool4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool4 operator<=( const float4& lhs, const float4& rhs )
{
	return bool4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool4 operator>( const float4& lhs, const float4& rhs )
{
	return bool4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool4 operator>=( const float4& lhs, const float4& rhs )
{
	return bool4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE float4 operator+( const float4& lhs, const float rhs )
{
	return float4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE float4 operator+=( float4& lhs, const float rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE float4 operator+( const float4& lhs, const float4& rhs )
{
	return float4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE float4 operator+=( float4& lhs, const float4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE float4 operator-( const float4& lhs, const float rhs )
{
	return float4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE float4 operator-=( float4& lhs, const float rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE float4 operator-( const float4& lhs, const float4& rhs )
{
	return float4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE float4 operator-=( float4& lhs, const float4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE float4 operator*( const float4& lhs, const float rhs )
{
	return float4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE float4 operator*=( float4& lhs, const float rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE float4 operator*( const float4& lhs, const float4& rhs )
{
	return float4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE float4 operator*=( float4& lhs, const float4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE float4 operator/( const float4& lhs, const float rhs )
{
	return float4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE float4 operator/=( float4& lhs, const float rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE float4 operator/( const float4& lhs, const float4& rhs )
{
	return float4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE float4 operator/=( float4& lhs, const float4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE float4 operator++( float4& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE float4 operator++( float4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE float4 operator--( float4& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE float4 operator--( float4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the vector that has been negated.
// pre-fix
HLML_INLINE float4 operator-( const float4& x )
{
	return float4(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Performs a sign function on each component of the vector.
HLML_INLINE int4 sign( const float4& x )
{
	return int4(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] ),
		sign( x[3] )
	);
}

// Performs a min function on each component of the vector.
HLML_INLINE float4 min( const float4& x, const float4& y )
{
	return float4(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each component of the vector.
HLML_INLINE float4 max( const float4& x, const float4& y )
{
	return float4(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each component of the vector.
HLML_INLINE float4 clamp( const float4& x, const float4& low, const float4& high )
{
	return float4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each component of the vector.
HLML_INLINE float4 saturate( const float4& x )
{
	return float4(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Performs a lerp function on each component of the vector.
HLML_INLINE float4 lerp( const float4& lhs, const float4& rhs, const float t )
{
	return float4(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t ),
		lerp( lhs[3], rhs[3], t )
	);
}

// Returns the magnitude of vector squared.
HLML_INLINE float lengthsq( const float4& vec )
{
	return ( vec.x * vec.x ) + ( vec.y * vec.y ) + ( vec.z * vec.z ) + ( vec.w * vec.w );
}

// Returns the magnitude of the vector.
HLML_INLINE float length( const float4& vec )
{
	return sqrtf( lengthsq( vec ) );
}

// Normalizes the vector.
HLML_INLINE void normalize( float4& vec )
{
	float invlen = 1.0f / length( vec );

	vec *= invlen;
}

// Returns a normalized copy of the vector.
HLML_INLINE float4 normalized( const float4& vec )
{
	float invlen = 1.0f / length( vec );

	return vec * invlen;
}

// Returns the dot product of the two vectors.
HLML_INLINE float dot( const float4& lhs, const float4& rhs )
{
	return ( lhs.x * rhs.x ) + ( lhs.y * rhs.y ) + ( lhs.z * rhs.z ) + ( lhs.w * rhs.w );
}

// Returns the angle (in degrees) between the two vectors.
HLML_INLINE float angle( const float4& lhs, const float4& rhs )
{
	return degrees( acosf( dot( normalized( lhs ), normalized( rhs ) ) ) );
}

// double2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const double2& lhs, const double2& rhs )
{
	return
		doubleeq( lhs[0], rhs[0] ) &&
		doubleeq( lhs[1], rhs[1] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const double2& lhs, const double2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool2 operator<( const double2& lhs, const double2& rhs )
{
	return bool2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool2 operator<=( const double2& lhs, const double2& rhs )
{
	return bool2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool2 operator>( const double2& lhs, const double2& rhs )
{
	return bool2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool2 operator>=( const double2& lhs, const double2& rhs )
{
	return bool2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE double2 operator+( const double2& lhs, const double rhs )
{
	return double2(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE double2 operator+=( double2& lhs, const double rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE double2 operator+( const double2& lhs, const double2& rhs )
{
	return double2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE double2 operator+=( double2& lhs, const double2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE double2 operator-( const double2& lhs, const double rhs )
{
	return double2(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE double2 operator-=( double2& lhs, const double rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE double2 operator-( const double2& lhs, const double2& rhs )
{
	return double2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE double2 operator-=( double2& lhs, const double2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE double2 operator*( const double2& lhs, const double rhs )
{
	return double2(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE double2 operator*=( double2& lhs, const double rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE double2 operator*( const double2& lhs, const double2& rhs )
{
	return double2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE double2 operator*=( double2& lhs, const double2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE double2 operator/( const double2& lhs, const double rhs )
{
	return double2(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE double2 operator/=( double2& lhs, const double rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE double2 operator/( const double2& lhs, const double2& rhs )
{
	return double2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE double2 operator/=( double2& lhs, const double2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE double2 operator++( double2& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE double2 operator++( double2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE double2 operator--( double2& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE double2 operator--( double2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the vector that has been negated.
// pre-fix
HLML_INLINE double2 operator-( const double2& x )
{
	return double2(
		-x[0],
		-x[1]
	);
}

// Performs a sign function on each component of the vector.
HLML_INLINE int2 sign( const double2& x )
{
	return int2(
		sign( x[0] ),
		sign( x[1] )
	);
}

// Performs a min function on each component of the vector.
HLML_INLINE double2 min( const double2& x, const double2& y )
{
	return double2(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each component of the vector.
HLML_INLINE double2 max( const double2& x, const double2& y )
{
	return double2(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each component of the vector.
HLML_INLINE double2 clamp( const double2& x, const double2& low, const double2& high )
{
	return double2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each component of the vector.
HLML_INLINE double2 saturate( const double2& x )
{
	return double2(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Performs a lerp function on each component of the vector.
HLML_INLINE double2 lerp( const double2& lhs, const double2& rhs, const double t )
{
	return double2(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t )
	);
}

// Returns the magnitude of vector squared.
HLML_INLINE double lengthsq( const double2& vec )
{
	return ( vec.x * vec.x ) + ( vec.y * vec.y );
}

// Returns the magnitude of the vector.
HLML_INLINE double length( const double2& vec )
{
	return sqrt( lengthsq( vec ) );
}

// Normalizes the vector.
HLML_INLINE void normalize( double2& vec )
{
	double invlen = 1.0 / length( vec );

	vec *= invlen;
}

// Returns a normalized copy of the vector.
HLML_INLINE double2 normalized( const double2& vec )
{
	double invlen = 1.0 / length( vec );

	return vec * invlen;
}

// Returns the dot product of the two vectors.
HLML_INLINE double dot( const double2& lhs, const double2& rhs )
{
	return ( lhs.x * rhs.x ) + ( lhs.y * rhs.y );
}

// Returns the angle (in degrees) between the two vectors.
HLML_INLINE double angle( const double2& lhs, const double2& rhs )
{
	return degrees( acos( dot( normalized( lhs ), normalized( rhs ) ) ) );
}

// Returns the squared distance between the two vectors.
HLML_INLINE double distancesq( const double2& lhs, const double2& rhs )
{
	return lengthsq( lhs - rhs );
}

// Returns the distance between the two vectors.
HLML_INLINE double distance( const double2& lhs, const double2& rhs )
{
	return length( lhs - rhs );
}

// double3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const double3& lhs, const double3& rhs )
{
	return
		doubleeq( lhs[0], rhs[0] ) &&
		doubleeq( lhs[1], rhs[1] ) &&
		doubleeq( lhs[2], rhs[2] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const double3& lhs, const double3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool3 operator<( const double3& lhs, const double3& rhs )
{
	return bool3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool3 operator<=( const double3& lhs, const double3& rhs )
{
	return bool3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool3 operator>( const double3& lhs, const double3& rhs )
{
	return bool3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool3 operator>=( const double3& lhs, const double3& rhs )
{
	return bool3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE double3 operator+( const double3& lhs, const double rhs )
{
	return double3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE double3 operator+=( double3& lhs, const double rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE double3 operator+( const double3& lhs, const double3& rhs )
{
	return double3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE double3 operator+=( double3& lhs, const double3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE double3 operator-( const double3& lhs, const double rhs )
{
	return double3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE double3 operator-=( double3& lhs, const double rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE double3 operator-( const double3& lhs, const double3& rhs )
{
	return double3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE double3 operator-=( double3& lhs, const double3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE double3 operator*( const double3& lhs, const double rhs )
{
	return double3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE double3 operator*=( double3& lhs, const double rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE double3 operator*( const double3& lhs, const double3& rhs )
{
	return double3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE double3 operator*=( double3& lhs, const double3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE double3 operator/( const double3& lhs, const double rhs )
{
	return double3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE double3 operator/=( double3& lhs, const double rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE double3 operator/( const double3& lhs, const double3& rhs )
{
	return double3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE double3 operator/=( double3& lhs, const double3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE double3 operator++( double3& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE double3 operator++( double3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE double3 operator--( double3& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE double3 operator--( double3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the vector that has been negated.
// pre-fix
HLML_INLINE double3 operator-( const double3& x )
{
	return double3(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Performs a sign function on each component of the vector.
HLML_INLINE int3 sign( const double3& x )
{
	return int3(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] )
	);
}

// Performs a min function on each component of the vector.
HLML_INLINE double3 min( const double3& x, const double3& y )
{
	return double3(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each component of the vector.
HLML_INLINE double3 max( const double3& x, const double3& y )
{
	return double3(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each component of the vector.
HLML_INLINE double3 clamp( const double3& x, const double3& low, const double3& high )
{
	return double3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each component of the vector.
HLML_INLINE double3 saturate( const double3& x )
{
	return double3(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Performs a lerp function on each component of the vector.
HLML_INLINE double3 lerp( const double3& lhs, const double3& rhs, const double t )
{
	return double3(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t )
	);
}

// Returns the magnitude of vector squared.
HLML_INLINE double lengthsq( const double3& vec )
{
	return ( vec.x * vec.x ) + ( vec.y * vec.y ) + ( vec.z * vec.z );
}

// Returns the magnitude of the vector.
HLML_INLINE double length( const double3& vec )
{
	return sqrt( lengthsq( vec ) );
}

// Normalizes the vector.
HLML_INLINE void normalize( double3& vec )
{
	double invlen = 1.0 / length( vec );

	vec *= invlen;
}

// Returns a normalized copy of the vector.
HLML_INLINE double3 normalized( const double3& vec )
{
	double invlen = 1.0 / length( vec );

	return vec * invlen;
}

// Returns the dot product of the two vectors.
HLML_INLINE double dot( const double3& lhs, const double3& rhs )
{
	return ( lhs.x * rhs.x ) + ( lhs.y * rhs.y ) + ( lhs.z * rhs.z );
}

// Returns a vector perpendicular to the two vectors.
HLML_INLINE double3 cross( const double3& lhs, const double3& rhs )
{
	return HLML_CONSTRUCT( double3 )
	{
		( lhs.y * rhs.z ) - ( lhs.z * rhs.y ),
		( lhs.z * rhs.x ) - ( lhs.x * rhs.z ),
		( lhs.x * rhs.y ) - ( lhs.y * rhs.x )
	};
}

// Returns the angle (in degrees) between the two vectors.
HLML_INLINE double angle( const double3& lhs, const double3& rhs )
{
	return degrees( acos( dot( normalized( lhs ), normalized( rhs ) ) ) );
}

// Returns the squared distance between the two vectors.
HLML_INLINE double distancesq( const double3& lhs, const double3& rhs )
{
	return lengthsq( lhs - rhs );
}

// Returns the distance between the two vectors.
HLML_INLINE double distance( const double3& lhs, const double3& rhs )
{
	return length( lhs - rhs );
}

// double4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const double4& lhs, const double4& rhs )
{
	return
		doubleeq( lhs[0], rhs[0] ) &&
		doubleeq( lhs[1], rhs[1] ) &&
		doubleeq( lhs[2], rhs[2] ) &&
		doubleeq( lhs[3], rhs[3] );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const double4& lhs, const double4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool4 operator<( const double4& lhs, const double4& rhs )
{
	return bool4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool4 operator<=( const double4& lhs, const double4& rhs )
{
	return bool4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool4 operator>( const double4& lhs, const double4& rhs )
{
	return bool4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool4 operator>=( const double4& lhs, const double4& rhs )
{
	return bool4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE double4 operator+( const double4& lhs, const double rhs )
{
	return double4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE double4 operator+=( double4& lhs, const double rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE double4 operator+( const double4& lhs, const double4& rhs )
{
	return double4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE double4 operator+=( double4& lhs, const double4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE double4 operator-( const double4& lhs, const double rhs )
{
	return double4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE double4 operator-=( double4& lhs, const double rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE double4 operator-( const double4& lhs, const double4& rhs )
{
	return double4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE double4 operator-=( double4& lhs, const double4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE double4 operator*( const double4& lhs, const double rhs )
{
	return double4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE double4 operator*=( double4& lhs, const double rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE double4 operator*( const double4& lhs, const double4& rhs )
{
	return double4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE double4 operator*=( double4& lhs, const double4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE double4 operator/( const double4& lhs, const double rhs )
{
	return double4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE double4 operator/=( double4& lhs, const double rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE double4 operator/( const double4& lhs, const double4& rhs )
{
	return double4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE double4 operator/=( double4& lhs, const double4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the vector and returns the result.
HLML_INLINE double4 operator++( double4& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the vector and returns the result.
// post-fix
HLML_INLINE double4 operator++( double4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the vector and returns the result.
HLML_INLINE double4 operator--( double4& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the vector and returns the result.
// post-fix
HLML_INLINE double4 operator--( double4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the vector that has been negated.
// pre-fix
HLML_INLINE double4 operator-( const double4& x )
{
	return double4(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Performs a sign function on each component of the vector.
HLML_INLINE int4 sign( const double4& x )
{
	return int4(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] ),
		sign( x[3] )
	);
}

// Performs a min function on each component of the vector.
HLML_INLINE double4 min( const double4& x, const double4& y )
{
	return double4(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each component of the vector.
HLML_INLINE double4 max( const double4& x, const double4& y )
{
	return double4(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each component of the vector.
HLML_INLINE double4 clamp( const double4& x, const double4& low, const double4& high )
{
	return double4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each component of the vector.
HLML_INLINE double4 saturate( const double4& x )
{
	return double4(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Performs a lerp function on each component of the vector.
HLML_INLINE double4 lerp( const double4& lhs, const double4& rhs, const double t )
{
	return double4(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t ),
		lerp( lhs[3], rhs[3], t )
	);
}

// Returns the magnitude of vector squared.
HLML_INLINE double lengthsq( const double4& vec )
{
	return ( vec.x * vec.x ) + ( vec.y * vec.y ) + ( vec.z * vec.z ) + ( vec.w * vec.w );
}

// Returns the magnitude of the vector.
HLML_INLINE double length( const double4& vec )
{
	return sqrt( lengthsq( vec ) );
}

// Normalizes the vector.
HLML_INLINE void normalize( double4& vec )
{
	double invlen = 1.0 / length( vec );

	vec *= invlen;
}

// Returns a normalized copy of the vector.
HLML_INLINE double4 normalized( const double4& vec )
{
	double invlen = 1.0 / length( vec );

	return vec * invlen;
}

// Returns the dot product of the two vectors.
HLML_INLINE double dot( const double4& lhs, const double4& rhs )
{
	return ( lhs.x * rhs.x ) + ( lhs.y * rhs.y ) + ( lhs.z * rhs.z ) + ( lhs.w * rhs.w );
}

// Returns the angle (in degrees) between the two vectors.
HLML_INLINE double angle( const double4& lhs, const double4& rhs )
{
	return degrees( acos( dot( normalized( lhs ), normalized( rhs ) ) ) );
}

