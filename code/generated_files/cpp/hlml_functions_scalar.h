/*
===========================================================================

HLML
v2.2.0

MIT License:

Copyright (c) 2019 Dan Moody (daniel.guy.moody@gmail.com).

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===========================================================================
*/

// THIS FILE WAS AUTOMATICALLY GENERATED BY A TOOL.
// EDITING THIS FILE MAY CAUSE SIDE EFFECTS.
// DO SO AT YOUR OWN RISK.

#pragma once

#include "hlml_constants.h"
#include "hlml_defines.h"

#include <math.h>
#include <stdint.h>

#ifdef HLML_NAMESPACE
namespace hlml
{
#endif

// int32_t
// Returns -1 if 'x' is < 0, 0 if 'x' == 0, or 1 if 'x' > 1.
HLML_INLINE int32_t sign( const int32_t x )
{
	return ( 0 < x ) - ( x < 0 );
}

// Returns 'x' if it's smaller than 'y', otherwise returns 'y'.
HLML_INLINE int32_t min( const int32_t x, const int32_t y )
{
	return ( x < y ) ? x : y;
}

// Returns x if it's larger than 'y', otherwise returns 'y'.
HLML_INLINE int32_t max( const int32_t x, const int32_t y )
{
	return ( x > y ) ? x : y;
}

// If 'x' is lower than 'low' or higher than 'high' then returns 'low' or 'high' respectively, otherwise returns 'x'.
HLML_INLINE int32_t clamp( const int32_t x, const int32_t low, const int32_t high )
{
	return min( max( x, low ), high );
}

// Returns a copy of 'x' that has been clamped between the range 0 and 1.
HLML_INLINE int32_t saturate( const int32_t x )
{
	return clamp( x, 0, 1 );
}

// Returns 1 if 'y' is greater than 'x', otherwise returns 0.
HLML_INLINE int32_t step( const int32_t x, const int32_t y )
{
	return ( y > x ? 1 : 0 );
}

// uint32_t
// Returns 'x' if it's smaller than 'y', otherwise returns 'y'.
HLML_INLINE uint32_t min( const uint32_t x, const uint32_t y )
{
	return ( x < y ) ? x : y;
}

// Returns x if it's larger than 'y', otherwise returns 'y'.
HLML_INLINE uint32_t max( const uint32_t x, const uint32_t y )
{
	return ( x > y ) ? x : y;
}

// If 'x' is lower than 'low' or higher than 'high' then returns 'low' or 'high' respectively, otherwise returns 'x'.
HLML_INLINE uint32_t clamp( const uint32_t x, const uint32_t low, const uint32_t high )
{
	return min( max( x, low ), high );
}

// Returns a copy of 'x' that has been clamped between the range 0 and 1.
HLML_INLINE uint32_t saturate( const uint32_t x )
{
	return clamp( x, 0U, 1U );
}

// Returns 1 if 'y' is greater than 'x', otherwise returns 0.
HLML_INLINE uint32_t step( const uint32_t x, const uint32_t y )
{
	return ( y > x ? 1U : 0U );
}

// float
// Returns true if the two given floating-point numbers are close enough to each other within a user-specified margin of error to be considered equal.
HLML_INLINE bool floateq_eps( const float lhs, const float rhs, const float epsilon )
{
	return fabsf( lhs - rhs ) < epsilon;
}

// Returns true if the two given floating-point numbers are close enough to each other within margin of error `(float)( HLML_EPSILON )` to be considered equal.
HLML_INLINE bool floateq( const float lhs, const float rhs )
{
	return floateq_eps( lhs, rhs, (float)( HLML_EPSILON ) );
}

// Returns the given degrees to radians.
HLML_INLINE float radians( const float deg )
{
	return deg * (float)( HLML_PI ) / 180.0f;
}

// Returns the given radians to degrees.
HLML_INLINE float degrees( const float rad )
{
	return rad * 180.0f / (float)( HLML_PI );
}

// Returns -1 if 'x' is < 0, 0 if 'x' == 0, or 1 if 'x' > 1.
HLML_INLINE int32_t sign( const float x )
{
	return ( 0.0f < x ) - ( x < 0.0f );
}

// Returns 'x' if it's smaller than 'y', otherwise returns 'y'.
HLML_INLINE float min( const float x, const float y )
{
	return ( x < y ) ? x : y;
}

// Returns x if it's larger than 'y', otherwise returns 'y'.
HLML_INLINE float max( const float x, const float y )
{
	return ( x > y ) ? x : y;
}

// If 'x' is lower than 'low' or higher than 'high' then returns 'low' or 'high' respectively, otherwise returns 'x'.
HLML_INLINE float clamp( const float x, const float low, const float high )
{
	return min( max( x, low ), high );
}

// Returns a copy of 'x' that has been clamped between the range 0 and 1.
HLML_INLINE float saturate( const float x )
{
	return clamp( x, 0.0f, 1.0f );
}

// Returns a linearly interpolated float between 'a' and 'b', where 't' is the percentage (between 0 and 1) to interpolate by.
HLML_INLINE float lerp( const float a, const float b, const float t )
{
	return ( 1.0f - t ) * a + t * b;
}

// Returns 1 if 'y' is greater than 'x', otherwise returns 0.
HLML_INLINE float step( const float x, const float y )
{
	return ( y > x ? 1.0f : 0.0f );
}

// Performs a sigmoid-like interpolation and clamp.
HLML_INLINE float smoothstep( const float low, const float high, const float x )
{
	float t = saturate( ( x - low ) / ( high - low ) );
	return t * t * ( 3.0f - 2.0f * t );
}

// Performs a 'smoother' version of smoothstep, as design by Ken Perlin.
// https://en.wikipedia.org/wiki/Smoothstep#Variations
HLML_INLINE float smootherstep( const float low, const float high, const float x )
{
	float t = saturate( ( x - low ) / ( high - low ) );
	return t * t * t * ( t * ( t * 6.0f - 15.0f ) + 10.0f );
}

// double
// Returns true if the two given floating-point numbers are close enough to each other within a user-specified margin of error to be considered equal.
HLML_INLINE bool doubleeq_eps( const double lhs, const double rhs, const double epsilon )
{
	return fabs( lhs - rhs ) < epsilon;
}

// Returns true if the two given floating-point numbers are close enough to each other within margin of error `( HLML_EPSILON )` to be considered equal.
HLML_INLINE bool doubleeq( const double lhs, const double rhs )
{
	return doubleeq_eps( lhs, rhs, ( HLML_EPSILON ) );
}

// Returns the given degrees to radians.
HLML_INLINE double radians( const double deg )
{
	return deg * ( HLML_PI ) / 180.0;
}

// Returns the given radians to degrees.
HLML_INLINE double degrees( const double rad )
{
	return rad * 180.0 / ( HLML_PI );
}

// Returns -1 if 'x' is < 0, 0 if 'x' == 0, or 1 if 'x' > 1.
HLML_INLINE int32_t sign( const double x )
{
	return ( 0.0 < x ) - ( x < 0.0 );
}

// Returns 'x' if it's smaller than 'y', otherwise returns 'y'.
HLML_INLINE double min( const double x, const double y )
{
	return ( x < y ) ? x : y;
}

// Returns x if it's larger than 'y', otherwise returns 'y'.
HLML_INLINE double max( const double x, const double y )
{
	return ( x > y ) ? x : y;
}

// If 'x' is lower than 'low' or higher than 'high' then returns 'low' or 'high' respectively, otherwise returns 'x'.
HLML_INLINE double clamp( const double x, const double low, const double high )
{
	return min( max( x, low ), high );
}

// Returns a copy of 'x' that has been clamped between the range 0 and 1.
HLML_INLINE double saturate( const double x )
{
	return clamp( x, 0.0, 1.0 );
}

// Returns a linearly interpolated float between 'a' and 'b', where 't' is the percentage (between 0 and 1) to interpolate by.
HLML_INLINE double lerp( const double a, const double b, const double t )
{
	return ( 1.0 - t ) * a + t * b;
}

// Returns 1 if 'y' is greater than 'x', otherwise returns 0.
HLML_INLINE double step( const double x, const double y )
{
	return ( y > x ? 1.0 : 0.0 );
}

// Performs a sigmoid-like interpolation and clamp.
HLML_INLINE double smoothstep( const double low, const double high, const double x )
{
	double t = saturate( ( x - low ) / ( high - low ) );
	return t * t * ( 3.0 - 2.0 * t );
}

// Performs a 'smoother' version of smoothstep, as design by Ken Perlin.
// https://en.wikipedia.org/wiki/Smoothstep#Variations
HLML_INLINE double smootherstep( const double low, const double high, const double x )
{
	double t = saturate( ( x - low ) / ( high - low ) );
	return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );
}

#ifdef HLML_NAMESPACE
}
#endif
