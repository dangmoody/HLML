/*
===========================================================================

HLML.

MIT License

Copyright (c) 2019 Dan Moody

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===========================================================================
*/

// THIS FILE WAS AUTOMATICALLY GENERATED BY A TOOL.
// EDITING THIS FILE MAY CAUSE SIDE EFFECTS.
// DO SO AT YOUR OWN RISK.

#ifdef __cplusplus
extern "C" {
#endif

#include "bool2x2.h"
#include "bool2x3.h"
#include "bool2x4.h"
#include "bool3x2.h"
#include "bool3x3.h"
#include "bool3x4.h"
#include "bool4x2.h"
#include "bool4x3.h"
#include "bool4x4.h"

#include "int2x2.h"
#include "int2x3.h"
#include "int2x4.h"
#include "int3x2.h"
#include "int3x3.h"
#include "int3x4.h"
#include "int4x2.h"
#include "int4x3.h"
#include "int4x4.h"

#include "uint2x2.h"
#include "uint2x3.h"
#include "uint2x4.h"
#include "uint3x2.h"
#include "uint3x3.h"
#include "uint3x4.h"
#include "uint4x2.h"
#include "uint4x3.h"
#include "uint4x4.h"

#include "float2x2.h"
#include "float2x3.h"
#include "float2x4.h"
#include "float3x2.h"
#include "float3x3.h"
#include "float3x4.h"
#include "float4x2.h"
#include "float4x3.h"
#include "float4x4.h"

#include "double2x2.h"
#include "double2x3.h"
#include "double2x4.h"
#include "double3x2.h"
#include "double3x3.h"
#include "double3x4.h"
#include "double4x2.h"
#include "double4x3.h"
#include "double4x4.h"

#include "hlml_functions_vector.h"

// bool2x2
// Returns true if all components of the bool2x2 are true, otherwise returns false.
inline bool bool2x2_all( const bool2x2* x );

// Returns true if the all the components of the left-hand-side bool2x2 match the other one, otherwise returns false.
inline bool bool2x2_cmpe( const bool2x2* lhs, const bool2x2* rhs );

// Returns true if not all of the components of the left-hand-side bool2x2 match the other one, otherwise returns false.
inline bool bool2x2_cmpne( const bool2x2* lhs, const bool2x2* rhs );

// Sets the matrix to an identity matrix.
inline void bool2x2_identity( bool2x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool2x2 bool2x2_transpose( const bool2x2* mat );


// bool2x3
// Returns true if all components of the bool2x3 are true, otherwise returns false.
inline bool bool2x3_all( const bool2x3* x );

// Returns true if the all the components of the left-hand-side bool2x3 match the other one, otherwise returns false.
inline bool bool2x3_cmpe( const bool2x3* lhs, const bool2x3* rhs );

// Returns true if not all of the components of the left-hand-side bool2x3 match the other one, otherwise returns false.
inline bool bool2x3_cmpne( const bool2x3* lhs, const bool2x3* rhs );

// Sets the matrix to an identity matrix.
inline void bool2x3_identity( bool2x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool3x2 bool2x3_transpose( const bool2x3* mat );


// bool2x4
// Returns true if all components of the bool2x4 are true, otherwise returns false.
inline bool bool2x4_all( const bool2x4* x );

// Returns true if the all the components of the left-hand-side bool2x4 match the other one, otherwise returns false.
inline bool bool2x4_cmpe( const bool2x4* lhs, const bool2x4* rhs );

// Returns true if not all of the components of the left-hand-side bool2x4 match the other one, otherwise returns false.
inline bool bool2x4_cmpne( const bool2x4* lhs, const bool2x4* rhs );

// Sets the matrix to an identity matrix.
inline void bool2x4_identity( bool2x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool4x2 bool2x4_transpose( const bool2x4* mat );


// bool3x2
// Returns true if all components of the bool3x2 are true, otherwise returns false.
inline bool bool3x2_all( const bool3x2* x );

// Returns true if the all the components of the left-hand-side bool3x2 match the other one, otherwise returns false.
inline bool bool3x2_cmpe( const bool3x2* lhs, const bool3x2* rhs );

// Returns true if not all of the components of the left-hand-side bool3x2 match the other one, otherwise returns false.
inline bool bool3x2_cmpne( const bool3x2* lhs, const bool3x2* rhs );

// Sets the matrix to an identity matrix.
inline void bool3x2_identity( bool3x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool2x3 bool3x2_transpose( const bool3x2* mat );


// bool3x3
// Returns true if all components of the bool3x3 are true, otherwise returns false.
inline bool bool3x3_all( const bool3x3* x );

// Returns true if the all the components of the left-hand-side bool3x3 match the other one, otherwise returns false.
inline bool bool3x3_cmpe( const bool3x3* lhs, const bool3x3* rhs );

// Returns true if not all of the components of the left-hand-side bool3x3 match the other one, otherwise returns false.
inline bool bool3x3_cmpne( const bool3x3* lhs, const bool3x3* rhs );

// Sets the matrix to an identity matrix.
inline void bool3x3_identity( bool3x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool3x3 bool3x3_transpose( const bool3x3* mat );


// bool3x4
// Returns true if all components of the bool3x4 are true, otherwise returns false.
inline bool bool3x4_all( const bool3x4* x );

// Returns true if the all the components of the left-hand-side bool3x4 match the other one, otherwise returns false.
inline bool bool3x4_cmpe( const bool3x4* lhs, const bool3x4* rhs );

// Returns true if not all of the components of the left-hand-side bool3x4 match the other one, otherwise returns false.
inline bool bool3x4_cmpne( const bool3x4* lhs, const bool3x4* rhs );

// Sets the matrix to an identity matrix.
inline void bool3x4_identity( bool3x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool4x3 bool3x4_transpose( const bool3x4* mat );


// bool4x2
// Returns true if all components of the bool4x2 are true, otherwise returns false.
inline bool bool4x2_all( const bool4x2* x );

// Returns true if the all the components of the left-hand-side bool4x2 match the other one, otherwise returns false.
inline bool bool4x2_cmpe( const bool4x2* lhs, const bool4x2* rhs );

// Returns true if not all of the components of the left-hand-side bool4x2 match the other one, otherwise returns false.
inline bool bool4x2_cmpne( const bool4x2* lhs, const bool4x2* rhs );

// Sets the matrix to an identity matrix.
inline void bool4x2_identity( bool4x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool2x4 bool4x2_transpose( const bool4x2* mat );


// bool4x3
// Returns true if all components of the bool4x3 are true, otherwise returns false.
inline bool bool4x3_all( const bool4x3* x );

// Returns true if the all the components of the left-hand-side bool4x3 match the other one, otherwise returns false.
inline bool bool4x3_cmpe( const bool4x3* lhs, const bool4x3* rhs );

// Returns true if not all of the components of the left-hand-side bool4x3 match the other one, otherwise returns false.
inline bool bool4x3_cmpne( const bool4x3* lhs, const bool4x3* rhs );

// Sets the matrix to an identity matrix.
inline void bool4x3_identity( bool4x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool3x4 bool4x3_transpose( const bool4x3* mat );


// bool4x4
// Returns true if all components of the bool4x4 are true, otherwise returns false.
inline bool bool4x4_all( const bool4x4* x );

// Returns true if the all the components of the left-hand-side bool4x4 match the other one, otherwise returns false.
inline bool bool4x4_cmpe( const bool4x4* lhs, const bool4x4* rhs );

// Returns true if not all of the components of the left-hand-side bool4x4 match the other one, otherwise returns false.
inline bool bool4x4_cmpne( const bool4x4* lhs, const bool4x4* rhs );

// Sets the matrix to an identity matrix.
inline void bool4x4_identity( bool4x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool4x4 bool4x4_transpose( const bool4x4* mat );


// int2x2
// Returns true if the all the components of the left-hand-side int2x2 match the other one, otherwise returns false.
inline bool int2x2_cmpe( const int2x2* lhs, const int2x2* rhs );

// Returns true if not all of the components of the left-hand-side int2x2 match the other one, otherwise returns false.
inline bool int2x2_cmpne( const int2x2* lhs, const int2x2* rhs );

// Returns a copy of the int2x2 that has been component-wise added by the given scalar value.
inline int2x2 int2x2_cadds( const int2x2* lhs, const int32_t scalar );

// Returns a copy of the int2x2 that has been component-wise added by the corresponding component of the right-hand int2x2.
inline int2x2 int2x2_caddm( const int2x2* lhs, const int2x2* rhs );

// Returns a copy of the int2x2 that has been component-wise subtracted by the given scalar value.
inline int2x2 int2x2_csubs( const int2x2* lhs, const int32_t scalar );

// Returns a copy of the int2x2 that has been component-wise subtracted by the corresponding component of the right-hand int2x2.
inline int2x2 int2x2_csubm( const int2x2* lhs, const int2x2* rhs );

// Returns a copy of the int2x2 that has been component-wise multiplied by the given scalar value.
inline int2x2 int2x2_cmuls( const int2x2* lhs, const int32_t scalar );

// Returns a copy of the int2x2 that has been component-wise multiplied by the corresponding component of the right-hand int2x2.
inline int2x2 int2x2_cmulm( const int2x2* lhs, const int2x2* rhs );

// Returns a copy of the int2x2 that has been component-wise divided by the given scalar value.
inline int2x2 int2x2_cdivs( const int2x2* lhs, const int32_t scalar );

// Returns a copy of the int2x2 that has been component-wise divided by the corresponding component of the right-hand int2x2.
inline int2x2 int2x2_cdivm( const int2x2* lhs, const int2x2* rhs );

// Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise AND'd against the corresponding component of the right-hand side int2x2.
inline int2x2 int2x2_cand( const int2x2* lhs, const int2x2* rhs );

// Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise OR'd against the corresponding component of the right-hand side int2x2.
inline int2x2 int2x2_cor( const int2x2* lhs, const int2x2* rhs );

// Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise XOR'd against the corresponding component of the right-hand side int2x2.
inline int2x2 int2x2_cxor( const int2x2* lhs, const int2x2* rhs );

// Performs a unary bitwise operation on all components of the given int2x2.
inline int2x2 int2x2_cunary( const int2x2* lhs );

// Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise left-shifted by the corresponding component of the right-hand side int2x2.
inline int2x2 int2x2_cshift_left( const int2x2* lhs, const int2x2* rhs );

// Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise right-shifted by the corresponding component of the right-hand side int2x2.
inline int2x2 int2x2_cshift_right( const int2x2* lhs, const int2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x2 int2x2_cmpl( const int2x2* lhs, const int2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x2 int2x2_cmple( const int2x2* lhs, const int2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x2 int2x2_cmpg( const int2x2* lhs, const int2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x2 int2x2_cmpge( const int2x2* lhs, const int2x2* rhs );

// Sets the matrix to an identity matrix.
inline void int2x2_identity( int2x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int2x2 int2x2_transpose( const int2x2* mat );

// Returns the determinant of the matrix.
inline int32_t int2x2_determinant( const int2x2* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int2x2 int2x2_mulm( const int2x2* lhs, const int2x2* rhs );

// Returns the right-hand vector multiplied by the left-hand matrix.
inline int2 int2x2_mulv( const int2x2* lhs, const int2* rhs );


// int2x3
// Returns true if the all the components of the left-hand-side int2x3 match the other one, otherwise returns false.
inline bool int2x3_cmpe( const int2x3* lhs, const int2x3* rhs );

// Returns true if not all of the components of the left-hand-side int2x3 match the other one, otherwise returns false.
inline bool int2x3_cmpne( const int2x3* lhs, const int2x3* rhs );

// Returns a copy of the int2x3 that has been component-wise added by the given scalar value.
inline int2x3 int2x3_cadds( const int2x3* lhs, const int32_t scalar );

// Returns a copy of the int2x3 that has been component-wise added by the corresponding component of the right-hand int2x3.
inline int2x3 int2x3_caddm( const int2x3* lhs, const int2x3* rhs );

// Returns a copy of the int2x3 that has been component-wise subtracted by the given scalar value.
inline int2x3 int2x3_csubs( const int2x3* lhs, const int32_t scalar );

// Returns a copy of the int2x3 that has been component-wise subtracted by the corresponding component of the right-hand int2x3.
inline int2x3 int2x3_csubm( const int2x3* lhs, const int2x3* rhs );

// Returns a copy of the int2x3 that has been component-wise multiplied by the given scalar value.
inline int2x3 int2x3_cmuls( const int2x3* lhs, const int32_t scalar );

// Returns a copy of the int2x3 that has been component-wise multiplied by the corresponding component of the right-hand int2x3.
inline int2x3 int2x3_cmulm( const int2x3* lhs, const int2x3* rhs );

// Returns a copy of the int2x3 that has been component-wise divided by the given scalar value.
inline int2x3 int2x3_cdivs( const int2x3* lhs, const int32_t scalar );

// Returns a copy of the int2x3 that has been component-wise divided by the corresponding component of the right-hand int2x3.
inline int2x3 int2x3_cdivm( const int2x3* lhs, const int2x3* rhs );

// Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise AND'd against the corresponding component of the right-hand side int2x3.
inline int2x3 int2x3_cand( const int2x3* lhs, const int2x3* rhs );

// Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise OR'd against the corresponding component of the right-hand side int2x3.
inline int2x3 int2x3_cor( const int2x3* lhs, const int2x3* rhs );

// Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise XOR'd against the corresponding component of the right-hand side int2x3.
inline int2x3 int2x3_cxor( const int2x3* lhs, const int2x3* rhs );

// Performs a unary bitwise operation on all components of the given int2x3.
inline int2x3 int2x3_cunary( const int2x3* lhs );

// Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise left-shifted by the corresponding component of the right-hand side int2x3.
inline int2x3 int2x3_cshift_left( const int2x3* lhs, const int2x3* rhs );

// Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise right-shifted by the corresponding component of the right-hand side int2x3.
inline int2x3 int2x3_cshift_right( const int2x3* lhs, const int2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x3 int2x3_cmpl( const int2x3* lhs, const int2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x3 int2x3_cmple( const int2x3* lhs, const int2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x3 int2x3_cmpg( const int2x3* lhs, const int2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x3 int2x3_cmpge( const int2x3* lhs, const int2x3* rhs );

// Sets the matrix to an identity matrix.
inline void int2x3_identity( int2x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int3x2 int2x3_transpose( const int2x3* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int2x2 int2x3_mulm( const int2x3* lhs, const int3x2* rhs );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int2x3 int2x3_scale( const int2x3* mat, const int2* vec );


// int2x4
// Returns true if the all the components of the left-hand-side int2x4 match the other one, otherwise returns false.
inline bool int2x4_cmpe( const int2x4* lhs, const int2x4* rhs );

// Returns true if not all of the components of the left-hand-side int2x4 match the other one, otherwise returns false.
inline bool int2x4_cmpne( const int2x4* lhs, const int2x4* rhs );

// Returns a copy of the int2x4 that has been component-wise added by the given scalar value.
inline int2x4 int2x4_cadds( const int2x4* lhs, const int32_t scalar );

// Returns a copy of the int2x4 that has been component-wise added by the corresponding component of the right-hand int2x4.
inline int2x4 int2x4_caddm( const int2x4* lhs, const int2x4* rhs );

// Returns a copy of the int2x4 that has been component-wise subtracted by the given scalar value.
inline int2x4 int2x4_csubs( const int2x4* lhs, const int32_t scalar );

// Returns a copy of the int2x4 that has been component-wise subtracted by the corresponding component of the right-hand int2x4.
inline int2x4 int2x4_csubm( const int2x4* lhs, const int2x4* rhs );

// Returns a copy of the int2x4 that has been component-wise multiplied by the given scalar value.
inline int2x4 int2x4_cmuls( const int2x4* lhs, const int32_t scalar );

// Returns a copy of the int2x4 that has been component-wise multiplied by the corresponding component of the right-hand int2x4.
inline int2x4 int2x4_cmulm( const int2x4* lhs, const int2x4* rhs );

// Returns a copy of the int2x4 that has been component-wise divided by the given scalar value.
inline int2x4 int2x4_cdivs( const int2x4* lhs, const int32_t scalar );

// Returns a copy of the int2x4 that has been component-wise divided by the corresponding component of the right-hand int2x4.
inline int2x4 int2x4_cdivm( const int2x4* lhs, const int2x4* rhs );

// Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise AND'd against the corresponding component of the right-hand side int2x4.
inline int2x4 int2x4_cand( const int2x4* lhs, const int2x4* rhs );

// Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise OR'd against the corresponding component of the right-hand side int2x4.
inline int2x4 int2x4_cor( const int2x4* lhs, const int2x4* rhs );

// Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise XOR'd against the corresponding component of the right-hand side int2x4.
inline int2x4 int2x4_cxor( const int2x4* lhs, const int2x4* rhs );

// Performs a unary bitwise operation on all components of the given int2x4.
inline int2x4 int2x4_cunary( const int2x4* lhs );

// Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise left-shifted by the corresponding component of the right-hand side int2x4.
inline int2x4 int2x4_cshift_left( const int2x4* lhs, const int2x4* rhs );

// Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise right-shifted by the corresponding component of the right-hand side int2x4.
inline int2x4 int2x4_cshift_right( const int2x4* lhs, const int2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x4 int2x4_cmpl( const int2x4* lhs, const int2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x4 int2x4_cmple( const int2x4* lhs, const int2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x4 int2x4_cmpg( const int2x4* lhs, const int2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x4 int2x4_cmpge( const int2x4* lhs, const int2x4* rhs );

// Sets the matrix to an identity matrix.
inline void int2x4_identity( int2x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int4x2 int2x4_transpose( const int2x4* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int2x2 int2x4_mulm( const int2x4* lhs, const int4x2* rhs );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int2x4 int2x4_scale( const int2x4* mat, const int2* vec );


// int3x2
// Returns true if the all the components of the left-hand-side int3x2 match the other one, otherwise returns false.
inline bool int3x2_cmpe( const int3x2* lhs, const int3x2* rhs );

// Returns true if not all of the components of the left-hand-side int3x2 match the other one, otherwise returns false.
inline bool int3x2_cmpne( const int3x2* lhs, const int3x2* rhs );

// Returns a copy of the int3x2 that has been component-wise added by the given scalar value.
inline int3x2 int3x2_cadds( const int3x2* lhs, const int32_t scalar );

// Returns a copy of the int3x2 that has been component-wise added by the corresponding component of the right-hand int3x2.
inline int3x2 int3x2_caddm( const int3x2* lhs, const int3x2* rhs );

// Returns a copy of the int3x2 that has been component-wise subtracted by the given scalar value.
inline int3x2 int3x2_csubs( const int3x2* lhs, const int32_t scalar );

// Returns a copy of the int3x2 that has been component-wise subtracted by the corresponding component of the right-hand int3x2.
inline int3x2 int3x2_csubm( const int3x2* lhs, const int3x2* rhs );

// Returns a copy of the int3x2 that has been component-wise multiplied by the given scalar value.
inline int3x2 int3x2_cmuls( const int3x2* lhs, const int32_t scalar );

// Returns a copy of the int3x2 that has been component-wise multiplied by the corresponding component of the right-hand int3x2.
inline int3x2 int3x2_cmulm( const int3x2* lhs, const int3x2* rhs );

// Returns a copy of the int3x2 that has been component-wise divided by the given scalar value.
inline int3x2 int3x2_cdivs( const int3x2* lhs, const int32_t scalar );

// Returns a copy of the int3x2 that has been component-wise divided by the corresponding component of the right-hand int3x2.
inline int3x2 int3x2_cdivm( const int3x2* lhs, const int3x2* rhs );

// Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise AND'd against the corresponding component of the right-hand side int3x2.
inline int3x2 int3x2_cand( const int3x2* lhs, const int3x2* rhs );

// Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise OR'd against the corresponding component of the right-hand side int3x2.
inline int3x2 int3x2_cor( const int3x2* lhs, const int3x2* rhs );

// Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise XOR'd against the corresponding component of the right-hand side int3x2.
inline int3x2 int3x2_cxor( const int3x2* lhs, const int3x2* rhs );

// Performs a unary bitwise operation on all components of the given int3x2.
inline int3x2 int3x2_cunary( const int3x2* lhs );

// Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise left-shifted by the corresponding component of the right-hand side int3x2.
inline int3x2 int3x2_cshift_left( const int3x2* lhs, const int3x2* rhs );

// Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise right-shifted by the corresponding component of the right-hand side int3x2.
inline int3x2 int3x2_cshift_right( const int3x2* lhs, const int3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x2 int3x2_cmpl( const int3x2* lhs, const int3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x2 int3x2_cmple( const int3x2* lhs, const int3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x2 int3x2_cmpg( const int3x2* lhs, const int3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x2 int3x2_cmpge( const int3x2* lhs, const int3x2* rhs );

// Sets the matrix to an identity matrix.
inline void int3x2_identity( int3x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int2x3 int3x2_transpose( const int3x2* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int3x3 int3x2_mulm( const int3x2* lhs, const int2x3* rhs );


// int3x3
// Returns true if the all the components of the left-hand-side int3x3 match the other one, otherwise returns false.
inline bool int3x3_cmpe( const int3x3* lhs, const int3x3* rhs );

// Returns true if not all of the components of the left-hand-side int3x3 match the other one, otherwise returns false.
inline bool int3x3_cmpne( const int3x3* lhs, const int3x3* rhs );

// Returns a copy of the int3x3 that has been component-wise added by the given scalar value.
inline int3x3 int3x3_cadds( const int3x3* lhs, const int32_t scalar );

// Returns a copy of the int3x3 that has been component-wise added by the corresponding component of the right-hand int3x3.
inline int3x3 int3x3_caddm( const int3x3* lhs, const int3x3* rhs );

// Returns a copy of the int3x3 that has been component-wise subtracted by the given scalar value.
inline int3x3 int3x3_csubs( const int3x3* lhs, const int32_t scalar );

// Returns a copy of the int3x3 that has been component-wise subtracted by the corresponding component of the right-hand int3x3.
inline int3x3 int3x3_csubm( const int3x3* lhs, const int3x3* rhs );

// Returns a copy of the int3x3 that has been component-wise multiplied by the given scalar value.
inline int3x3 int3x3_cmuls( const int3x3* lhs, const int32_t scalar );

// Returns a copy of the int3x3 that has been component-wise multiplied by the corresponding component of the right-hand int3x3.
inline int3x3 int3x3_cmulm( const int3x3* lhs, const int3x3* rhs );

// Returns a copy of the int3x3 that has been component-wise divided by the given scalar value.
inline int3x3 int3x3_cdivs( const int3x3* lhs, const int32_t scalar );

// Returns a copy of the int3x3 that has been component-wise divided by the corresponding component of the right-hand int3x3.
inline int3x3 int3x3_cdivm( const int3x3* lhs, const int3x3* rhs );

// Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise AND'd against the corresponding component of the right-hand side int3x3.
inline int3x3 int3x3_cand( const int3x3* lhs, const int3x3* rhs );

// Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise OR'd against the corresponding component of the right-hand side int3x3.
inline int3x3 int3x3_cor( const int3x3* lhs, const int3x3* rhs );

// Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise XOR'd against the corresponding component of the right-hand side int3x3.
inline int3x3 int3x3_cxor( const int3x3* lhs, const int3x3* rhs );

// Performs a unary bitwise operation on all components of the given int3x3.
inline int3x3 int3x3_cunary( const int3x3* lhs );

// Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise left-shifted by the corresponding component of the right-hand side int3x3.
inline int3x3 int3x3_cshift_left( const int3x3* lhs, const int3x3* rhs );

// Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise right-shifted by the corresponding component of the right-hand side int3x3.
inline int3x3 int3x3_cshift_right( const int3x3* lhs, const int3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x3 int3x3_cmpl( const int3x3* lhs, const int3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x3 int3x3_cmple( const int3x3* lhs, const int3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x3 int3x3_cmpg( const int3x3* lhs, const int3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x3 int3x3_cmpge( const int3x3* lhs, const int3x3* rhs );

// Sets the matrix to an identity matrix.
inline void int3x3_identity( int3x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int3x3 int3x3_transpose( const int3x3* mat );

// Returns the determinant of the matrix.
inline int32_t int3x3_determinant( const int3x3* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int3x3 int3x3_mulm( const int3x3* lhs, const int3x3* rhs );

// Returns the right-hand vector multiplied by the left-hand matrix.
inline int3 int3x3_mulv( const int3x3* lhs, const int3* rhs );

// Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline int3x3 int3x3_translate( const int3x3* mat, const int2* vec );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int3x3 int3x3_scale( const int3x3* mat, const int2* vec );


// int3x4
// Returns true if the all the components of the left-hand-side int3x4 match the other one, otherwise returns false.
inline bool int3x4_cmpe( const int3x4* lhs, const int3x4* rhs );

// Returns true if not all of the components of the left-hand-side int3x4 match the other one, otherwise returns false.
inline bool int3x4_cmpne( const int3x4* lhs, const int3x4* rhs );

// Returns a copy of the int3x4 that has been component-wise added by the given scalar value.
inline int3x4 int3x4_cadds( const int3x4* lhs, const int32_t scalar );

// Returns a copy of the int3x4 that has been component-wise added by the corresponding component of the right-hand int3x4.
inline int3x4 int3x4_caddm( const int3x4* lhs, const int3x4* rhs );

// Returns a copy of the int3x4 that has been component-wise subtracted by the given scalar value.
inline int3x4 int3x4_csubs( const int3x4* lhs, const int32_t scalar );

// Returns a copy of the int3x4 that has been component-wise subtracted by the corresponding component of the right-hand int3x4.
inline int3x4 int3x4_csubm( const int3x4* lhs, const int3x4* rhs );

// Returns a copy of the int3x4 that has been component-wise multiplied by the given scalar value.
inline int3x4 int3x4_cmuls( const int3x4* lhs, const int32_t scalar );

// Returns a copy of the int3x4 that has been component-wise multiplied by the corresponding component of the right-hand int3x4.
inline int3x4 int3x4_cmulm( const int3x4* lhs, const int3x4* rhs );

// Returns a copy of the int3x4 that has been component-wise divided by the given scalar value.
inline int3x4 int3x4_cdivs( const int3x4* lhs, const int32_t scalar );

// Returns a copy of the int3x4 that has been component-wise divided by the corresponding component of the right-hand int3x4.
inline int3x4 int3x4_cdivm( const int3x4* lhs, const int3x4* rhs );

// Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise AND'd against the corresponding component of the right-hand side int3x4.
inline int3x4 int3x4_cand( const int3x4* lhs, const int3x4* rhs );

// Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise OR'd against the corresponding component of the right-hand side int3x4.
inline int3x4 int3x4_cor( const int3x4* lhs, const int3x4* rhs );

// Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise XOR'd against the corresponding component of the right-hand side int3x4.
inline int3x4 int3x4_cxor( const int3x4* lhs, const int3x4* rhs );

// Performs a unary bitwise operation on all components of the given int3x4.
inline int3x4 int3x4_cunary( const int3x4* lhs );

// Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise left-shifted by the corresponding component of the right-hand side int3x4.
inline int3x4 int3x4_cshift_left( const int3x4* lhs, const int3x4* rhs );

// Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise right-shifted by the corresponding component of the right-hand side int3x4.
inline int3x4 int3x4_cshift_right( const int3x4* lhs, const int3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x4 int3x4_cmpl( const int3x4* lhs, const int3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x4 int3x4_cmple( const int3x4* lhs, const int3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x4 int3x4_cmpg( const int3x4* lhs, const int3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x4 int3x4_cmpge( const int3x4* lhs, const int3x4* rhs );

// Sets the matrix to an identity matrix.
inline void int3x4_identity( int3x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int4x3 int3x4_transpose( const int3x4* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int3x3 int3x4_mulm( const int3x4* lhs, const int4x3* rhs );

// Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline int3x4 int3x4_translate( const int3x4* mat, const int3* vec );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int3x4 int3x4_scale( const int3x4* mat, const int2* vec );


// int4x2
// Returns true if the all the components of the left-hand-side int4x2 match the other one, otherwise returns false.
inline bool int4x2_cmpe( const int4x2* lhs, const int4x2* rhs );

// Returns true if not all of the components of the left-hand-side int4x2 match the other one, otherwise returns false.
inline bool int4x2_cmpne( const int4x2* lhs, const int4x2* rhs );

// Returns a copy of the int4x2 that has been component-wise added by the given scalar value.
inline int4x2 int4x2_cadds( const int4x2* lhs, const int32_t scalar );

// Returns a copy of the int4x2 that has been component-wise added by the corresponding component of the right-hand int4x2.
inline int4x2 int4x2_caddm( const int4x2* lhs, const int4x2* rhs );

// Returns a copy of the int4x2 that has been component-wise subtracted by the given scalar value.
inline int4x2 int4x2_csubs( const int4x2* lhs, const int32_t scalar );

// Returns a copy of the int4x2 that has been component-wise subtracted by the corresponding component of the right-hand int4x2.
inline int4x2 int4x2_csubm( const int4x2* lhs, const int4x2* rhs );

// Returns a copy of the int4x2 that has been component-wise multiplied by the given scalar value.
inline int4x2 int4x2_cmuls( const int4x2* lhs, const int32_t scalar );

// Returns a copy of the int4x2 that has been component-wise multiplied by the corresponding component of the right-hand int4x2.
inline int4x2 int4x2_cmulm( const int4x2* lhs, const int4x2* rhs );

// Returns a copy of the int4x2 that has been component-wise divided by the given scalar value.
inline int4x2 int4x2_cdivs( const int4x2* lhs, const int32_t scalar );

// Returns a copy of the int4x2 that has been component-wise divided by the corresponding component of the right-hand int4x2.
inline int4x2 int4x2_cdivm( const int4x2* lhs, const int4x2* rhs );

// Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise AND'd against the corresponding component of the right-hand side int4x2.
inline int4x2 int4x2_cand( const int4x2* lhs, const int4x2* rhs );

// Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise OR'd against the corresponding component of the right-hand side int4x2.
inline int4x2 int4x2_cor( const int4x2* lhs, const int4x2* rhs );

// Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise XOR'd against the corresponding component of the right-hand side int4x2.
inline int4x2 int4x2_cxor( const int4x2* lhs, const int4x2* rhs );

// Performs a unary bitwise operation on all components of the given int4x2.
inline int4x2 int4x2_cunary( const int4x2* lhs );

// Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise left-shifted by the corresponding component of the right-hand side int4x2.
inline int4x2 int4x2_cshift_left( const int4x2* lhs, const int4x2* rhs );

// Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise right-shifted by the corresponding component of the right-hand side int4x2.
inline int4x2 int4x2_cshift_right( const int4x2* lhs, const int4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x2 int4x2_cmpl( const int4x2* lhs, const int4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x2 int4x2_cmple( const int4x2* lhs, const int4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x2 int4x2_cmpg( const int4x2* lhs, const int4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x2 int4x2_cmpge( const int4x2* lhs, const int4x2* rhs );

// Sets the matrix to an identity matrix.
inline void int4x2_identity( int4x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int2x4 int4x2_transpose( const int4x2* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int4x4 int4x2_mulm( const int4x2* lhs, const int2x4* rhs );


// int4x3
// Returns true if the all the components of the left-hand-side int4x3 match the other one, otherwise returns false.
inline bool int4x3_cmpe( const int4x3* lhs, const int4x3* rhs );

// Returns true if not all of the components of the left-hand-side int4x3 match the other one, otherwise returns false.
inline bool int4x3_cmpne( const int4x3* lhs, const int4x3* rhs );

// Returns a copy of the int4x3 that has been component-wise added by the given scalar value.
inline int4x3 int4x3_cadds( const int4x3* lhs, const int32_t scalar );

// Returns a copy of the int4x3 that has been component-wise added by the corresponding component of the right-hand int4x3.
inline int4x3 int4x3_caddm( const int4x3* lhs, const int4x3* rhs );

// Returns a copy of the int4x3 that has been component-wise subtracted by the given scalar value.
inline int4x3 int4x3_csubs( const int4x3* lhs, const int32_t scalar );

// Returns a copy of the int4x3 that has been component-wise subtracted by the corresponding component of the right-hand int4x3.
inline int4x3 int4x3_csubm( const int4x3* lhs, const int4x3* rhs );

// Returns a copy of the int4x3 that has been component-wise multiplied by the given scalar value.
inline int4x3 int4x3_cmuls( const int4x3* lhs, const int32_t scalar );

// Returns a copy of the int4x3 that has been component-wise multiplied by the corresponding component of the right-hand int4x3.
inline int4x3 int4x3_cmulm( const int4x3* lhs, const int4x3* rhs );

// Returns a copy of the int4x3 that has been component-wise divided by the given scalar value.
inline int4x3 int4x3_cdivs( const int4x3* lhs, const int32_t scalar );

// Returns a copy of the int4x3 that has been component-wise divided by the corresponding component of the right-hand int4x3.
inline int4x3 int4x3_cdivm( const int4x3* lhs, const int4x3* rhs );

// Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise AND'd against the corresponding component of the right-hand side int4x3.
inline int4x3 int4x3_cand( const int4x3* lhs, const int4x3* rhs );

// Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise OR'd against the corresponding component of the right-hand side int4x3.
inline int4x3 int4x3_cor( const int4x3* lhs, const int4x3* rhs );

// Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise XOR'd against the corresponding component of the right-hand side int4x3.
inline int4x3 int4x3_cxor( const int4x3* lhs, const int4x3* rhs );

// Performs a unary bitwise operation on all components of the given int4x3.
inline int4x3 int4x3_cunary( const int4x3* lhs );

// Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise left-shifted by the corresponding component of the right-hand side int4x3.
inline int4x3 int4x3_cshift_left( const int4x3* lhs, const int4x3* rhs );

// Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise right-shifted by the corresponding component of the right-hand side int4x3.
inline int4x3 int4x3_cshift_right( const int4x3* lhs, const int4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x3 int4x3_cmpl( const int4x3* lhs, const int4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x3 int4x3_cmple( const int4x3* lhs, const int4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x3 int4x3_cmpg( const int4x3* lhs, const int4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x3 int4x3_cmpge( const int4x3* lhs, const int4x3* rhs );

// Sets the matrix to an identity matrix.
inline void int4x3_identity( int4x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int3x4 int4x3_transpose( const int4x3* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int4x4 int4x3_mulm( const int4x3* lhs, const int3x4* rhs );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int4x3 int4x3_scale( const int4x3* mat, const int2* vec );


// int4x4
// Returns true if the all the components of the left-hand-side int4x4 match the other one, otherwise returns false.
inline bool int4x4_cmpe( const int4x4* lhs, const int4x4* rhs );

// Returns true if not all of the components of the left-hand-side int4x4 match the other one, otherwise returns false.
inline bool int4x4_cmpne( const int4x4* lhs, const int4x4* rhs );

// Returns a copy of the int4x4 that has been component-wise added by the given scalar value.
inline int4x4 int4x4_cadds( const int4x4* lhs, const int32_t scalar );

// Returns a copy of the int4x4 that has been component-wise added by the corresponding component of the right-hand int4x4.
inline int4x4 int4x4_caddm( const int4x4* lhs, const int4x4* rhs );

// Returns a copy of the int4x4 that has been component-wise subtracted by the given scalar value.
inline int4x4 int4x4_csubs( const int4x4* lhs, const int32_t scalar );

// Returns a copy of the int4x4 that has been component-wise subtracted by the corresponding component of the right-hand int4x4.
inline int4x4 int4x4_csubm( const int4x4* lhs, const int4x4* rhs );

// Returns a copy of the int4x4 that has been component-wise multiplied by the given scalar value.
inline int4x4 int4x4_cmuls( const int4x4* lhs, const int32_t scalar );

// Returns a copy of the int4x4 that has been component-wise multiplied by the corresponding component of the right-hand int4x4.
inline int4x4 int4x4_cmulm( const int4x4* lhs, const int4x4* rhs );

// Returns a copy of the int4x4 that has been component-wise divided by the given scalar value.
inline int4x4 int4x4_cdivs( const int4x4* lhs, const int32_t scalar );

// Returns a copy of the int4x4 that has been component-wise divided by the corresponding component of the right-hand int4x4.
inline int4x4 int4x4_cdivm( const int4x4* lhs, const int4x4* rhs );

// Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise AND'd against the corresponding component of the right-hand side int4x4.
inline int4x4 int4x4_cand( const int4x4* lhs, const int4x4* rhs );

// Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise OR'd against the corresponding component of the right-hand side int4x4.
inline int4x4 int4x4_cor( const int4x4* lhs, const int4x4* rhs );

// Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise XOR'd against the corresponding component of the right-hand side int4x4.
inline int4x4 int4x4_cxor( const int4x4* lhs, const int4x4* rhs );

// Performs a unary bitwise operation on all components of the given int4x4.
inline int4x4 int4x4_cunary( const int4x4* lhs );

// Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise left-shifted by the corresponding component of the right-hand side int4x4.
inline int4x4 int4x4_cshift_left( const int4x4* lhs, const int4x4* rhs );

// Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise right-shifted by the corresponding component of the right-hand side int4x4.
inline int4x4 int4x4_cshift_right( const int4x4* lhs, const int4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x4 int4x4_cmpl( const int4x4* lhs, const int4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x4 int4x4_cmple( const int4x4* lhs, const int4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x4 int4x4_cmpg( const int4x4* lhs, const int4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x4 int4x4_cmpge( const int4x4* lhs, const int4x4* rhs );

// Sets the matrix to an identity matrix.
inline void int4x4_identity( int4x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int4x4 int4x4_transpose( const int4x4* mat );

// Returns the determinant of the matrix.
inline int32_t int4x4_determinant( const int4x4* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int4x4 int4x4_mulm( const int4x4* lhs, const int4x4* rhs );

// Returns the right-hand vector multiplied by the left-hand matrix.
inline int4 int4x4_mulv( const int4x4* lhs, const int4* rhs );

// Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline int4x4 int4x4_translate( const int4x4* mat, const int3* vec );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int4x4 int4x4_scale( const int4x4* mat, const int3* vec );


// uint2x2
// Returns true if the all the components of the left-hand-side uint2x2 match the other one, otherwise returns false.
inline bool uint2x2_cmpe( const uint2x2* lhs, const uint2x2* rhs );

// Returns true if not all of the components of the left-hand-side uint2x2 match the other one, otherwise returns false.
inline bool uint2x2_cmpne( const uint2x2* lhs, const uint2x2* rhs );

// Returns a copy of the uint2x2 that has been component-wise added by the given scalar value.
inline uint2x2 uint2x2_cadds( const uint2x2* lhs, const uint32_t scalar );

// Returns a copy of the uint2x2 that has been component-wise added by the corresponding component of the right-hand uint2x2.
inline uint2x2 uint2x2_caddm( const uint2x2* lhs, const uint2x2* rhs );

// Returns a copy of the uint2x2 that has been component-wise subtracted by the given scalar value.
inline uint2x2 uint2x2_csubs( const uint2x2* lhs, const uint32_t scalar );

// Returns a copy of the uint2x2 that has been component-wise subtracted by the corresponding component of the right-hand uint2x2.
inline uint2x2 uint2x2_csubm( const uint2x2* lhs, const uint2x2* rhs );

// Returns a copy of the uint2x2 that has been component-wise multiplied by the given scalar value.
inline uint2x2 uint2x2_cmuls( const uint2x2* lhs, const uint32_t scalar );

// Returns a copy of the uint2x2 that has been component-wise multiplied by the corresponding component of the right-hand uint2x2.
inline uint2x2 uint2x2_cmulm( const uint2x2* lhs, const uint2x2* rhs );

// Returns a copy of the uint2x2 that has been component-wise divided by the given scalar value.
inline uint2x2 uint2x2_cdivs( const uint2x2* lhs, const uint32_t scalar );

// Returns a copy of the uint2x2 that has been component-wise divided by the corresponding component of the right-hand uint2x2.
inline uint2x2 uint2x2_cdivm( const uint2x2* lhs, const uint2x2* rhs );

// Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise AND'd against the corresponding component of the right-hand side uint2x2.
inline uint2x2 uint2x2_cand( const uint2x2* lhs, const uint2x2* rhs );

// Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise OR'd against the corresponding component of the right-hand side uint2x2.
inline uint2x2 uint2x2_cor( const uint2x2* lhs, const uint2x2* rhs );

// Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise XOR'd against the corresponding component of the right-hand side uint2x2.
inline uint2x2 uint2x2_cxor( const uint2x2* lhs, const uint2x2* rhs );

// Performs a unary bitwise operation on all components of the given uint2x2.
inline uint2x2 uint2x2_cunary( const uint2x2* lhs );

// Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise left-shifted by the corresponding component of the right-hand side uint2x2.
inline uint2x2 uint2x2_cshift_left( const uint2x2* lhs, const uint2x2* rhs );

// Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise right-shifted by the corresponding component of the right-hand side uint2x2.
inline uint2x2 uint2x2_cshift_right( const uint2x2* lhs, const uint2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x2 uint2x2_cmpl( const uint2x2* lhs, const uint2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x2 uint2x2_cmple( const uint2x2* lhs, const uint2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x2 uint2x2_cmpg( const uint2x2* lhs, const uint2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x2 uint2x2_cmpge( const uint2x2* lhs, const uint2x2* rhs );

// Sets the matrix to an identity matrix.
inline void uint2x2_identity( uint2x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint2x2 uint2x2_transpose( const uint2x2* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint2x2 uint2x2_mulm( const uint2x2* lhs, const uint2x2* rhs );

// Returns the right-hand vector multiplied by the left-hand matrix.
inline uint2 uint2x2_mulv( const uint2x2* lhs, const uint2* rhs );


// uint2x3
// Returns true if the all the components of the left-hand-side uint2x3 match the other one, otherwise returns false.
inline bool uint2x3_cmpe( const uint2x3* lhs, const uint2x3* rhs );

// Returns true if not all of the components of the left-hand-side uint2x3 match the other one, otherwise returns false.
inline bool uint2x3_cmpne( const uint2x3* lhs, const uint2x3* rhs );

// Returns a copy of the uint2x3 that has been component-wise added by the given scalar value.
inline uint2x3 uint2x3_cadds( const uint2x3* lhs, const uint32_t scalar );

// Returns a copy of the uint2x3 that has been component-wise added by the corresponding component of the right-hand uint2x3.
inline uint2x3 uint2x3_caddm( const uint2x3* lhs, const uint2x3* rhs );

// Returns a copy of the uint2x3 that has been component-wise subtracted by the given scalar value.
inline uint2x3 uint2x3_csubs( const uint2x3* lhs, const uint32_t scalar );

// Returns a copy of the uint2x3 that has been component-wise subtracted by the corresponding component of the right-hand uint2x3.
inline uint2x3 uint2x3_csubm( const uint2x3* lhs, const uint2x3* rhs );

// Returns a copy of the uint2x3 that has been component-wise multiplied by the given scalar value.
inline uint2x3 uint2x3_cmuls( const uint2x3* lhs, const uint32_t scalar );

// Returns a copy of the uint2x3 that has been component-wise multiplied by the corresponding component of the right-hand uint2x3.
inline uint2x3 uint2x3_cmulm( const uint2x3* lhs, const uint2x3* rhs );

// Returns a copy of the uint2x3 that has been component-wise divided by the given scalar value.
inline uint2x3 uint2x3_cdivs( const uint2x3* lhs, const uint32_t scalar );

// Returns a copy of the uint2x3 that has been component-wise divided by the corresponding component of the right-hand uint2x3.
inline uint2x3 uint2x3_cdivm( const uint2x3* lhs, const uint2x3* rhs );

// Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise AND'd against the corresponding component of the right-hand side uint2x3.
inline uint2x3 uint2x3_cand( const uint2x3* lhs, const uint2x3* rhs );

// Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise OR'd against the corresponding component of the right-hand side uint2x3.
inline uint2x3 uint2x3_cor( const uint2x3* lhs, const uint2x3* rhs );

// Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise XOR'd against the corresponding component of the right-hand side uint2x3.
inline uint2x3 uint2x3_cxor( const uint2x3* lhs, const uint2x3* rhs );

// Performs a unary bitwise operation on all components of the given uint2x3.
inline uint2x3 uint2x3_cunary( const uint2x3* lhs );

// Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise left-shifted by the corresponding component of the right-hand side uint2x3.
inline uint2x3 uint2x3_cshift_left( const uint2x3* lhs, const uint2x3* rhs );

// Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise right-shifted by the corresponding component of the right-hand side uint2x3.
inline uint2x3 uint2x3_cshift_right( const uint2x3* lhs, const uint2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x3 uint2x3_cmpl( const uint2x3* lhs, const uint2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x3 uint2x3_cmple( const uint2x3* lhs, const uint2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x3 uint2x3_cmpg( const uint2x3* lhs, const uint2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x3 uint2x3_cmpge( const uint2x3* lhs, const uint2x3* rhs );

// Sets the matrix to an identity matrix.
inline void uint2x3_identity( uint2x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint3x2 uint2x3_transpose( const uint2x3* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint2x2 uint2x3_mulm( const uint2x3* lhs, const uint3x2* rhs );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint2x3 uint2x3_scale( const uint2x3* mat, const uint2* vec );


// uint2x4
// Returns true if the all the components of the left-hand-side uint2x4 match the other one, otherwise returns false.
inline bool uint2x4_cmpe( const uint2x4* lhs, const uint2x4* rhs );

// Returns true if not all of the components of the left-hand-side uint2x4 match the other one, otherwise returns false.
inline bool uint2x4_cmpne( const uint2x4* lhs, const uint2x4* rhs );

// Returns a copy of the uint2x4 that has been component-wise added by the given scalar value.
inline uint2x4 uint2x4_cadds( const uint2x4* lhs, const uint32_t scalar );

// Returns a copy of the uint2x4 that has been component-wise added by the corresponding component of the right-hand uint2x4.
inline uint2x4 uint2x4_caddm( const uint2x4* lhs, const uint2x4* rhs );

// Returns a copy of the uint2x4 that has been component-wise subtracted by the given scalar value.
inline uint2x4 uint2x4_csubs( const uint2x4* lhs, const uint32_t scalar );

// Returns a copy of the uint2x4 that has been component-wise subtracted by the corresponding component of the right-hand uint2x4.
inline uint2x4 uint2x4_csubm( const uint2x4* lhs, const uint2x4* rhs );

// Returns a copy of the uint2x4 that has been component-wise multiplied by the given scalar value.
inline uint2x4 uint2x4_cmuls( const uint2x4* lhs, const uint32_t scalar );

// Returns a copy of the uint2x4 that has been component-wise multiplied by the corresponding component of the right-hand uint2x4.
inline uint2x4 uint2x4_cmulm( const uint2x4* lhs, const uint2x4* rhs );

// Returns a copy of the uint2x4 that has been component-wise divided by the given scalar value.
inline uint2x4 uint2x4_cdivs( const uint2x4* lhs, const uint32_t scalar );

// Returns a copy of the uint2x4 that has been component-wise divided by the corresponding component of the right-hand uint2x4.
inline uint2x4 uint2x4_cdivm( const uint2x4* lhs, const uint2x4* rhs );

// Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise AND'd against the corresponding component of the right-hand side uint2x4.
inline uint2x4 uint2x4_cand( const uint2x4* lhs, const uint2x4* rhs );

// Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise OR'd against the corresponding component of the right-hand side uint2x4.
inline uint2x4 uint2x4_cor( const uint2x4* lhs, const uint2x4* rhs );

// Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise XOR'd against the corresponding component of the right-hand side uint2x4.
inline uint2x4 uint2x4_cxor( const uint2x4* lhs, const uint2x4* rhs );

// Performs a unary bitwise operation on all components of the given uint2x4.
inline uint2x4 uint2x4_cunary( const uint2x4* lhs );

// Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise left-shifted by the corresponding component of the right-hand side uint2x4.
inline uint2x4 uint2x4_cshift_left( const uint2x4* lhs, const uint2x4* rhs );

// Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise right-shifted by the corresponding component of the right-hand side uint2x4.
inline uint2x4 uint2x4_cshift_right( const uint2x4* lhs, const uint2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x4 uint2x4_cmpl( const uint2x4* lhs, const uint2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x4 uint2x4_cmple( const uint2x4* lhs, const uint2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x4 uint2x4_cmpg( const uint2x4* lhs, const uint2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x4 uint2x4_cmpge( const uint2x4* lhs, const uint2x4* rhs );

// Sets the matrix to an identity matrix.
inline void uint2x4_identity( uint2x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint4x2 uint2x4_transpose( const uint2x4* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint2x2 uint2x4_mulm( const uint2x4* lhs, const uint4x2* rhs );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint2x4 uint2x4_scale( const uint2x4* mat, const uint2* vec );


// uint3x2
// Returns true if the all the components of the left-hand-side uint3x2 match the other one, otherwise returns false.
inline bool uint3x2_cmpe( const uint3x2* lhs, const uint3x2* rhs );

// Returns true if not all of the components of the left-hand-side uint3x2 match the other one, otherwise returns false.
inline bool uint3x2_cmpne( const uint3x2* lhs, const uint3x2* rhs );

// Returns a copy of the uint3x2 that has been component-wise added by the given scalar value.
inline uint3x2 uint3x2_cadds( const uint3x2* lhs, const uint32_t scalar );

// Returns a copy of the uint3x2 that has been component-wise added by the corresponding component of the right-hand uint3x2.
inline uint3x2 uint3x2_caddm( const uint3x2* lhs, const uint3x2* rhs );

// Returns a copy of the uint3x2 that has been component-wise subtracted by the given scalar value.
inline uint3x2 uint3x2_csubs( const uint3x2* lhs, const uint32_t scalar );

// Returns a copy of the uint3x2 that has been component-wise subtracted by the corresponding component of the right-hand uint3x2.
inline uint3x2 uint3x2_csubm( const uint3x2* lhs, const uint3x2* rhs );

// Returns a copy of the uint3x2 that has been component-wise multiplied by the given scalar value.
inline uint3x2 uint3x2_cmuls( const uint3x2* lhs, const uint32_t scalar );

// Returns a copy of the uint3x2 that has been component-wise multiplied by the corresponding component of the right-hand uint3x2.
inline uint3x2 uint3x2_cmulm( const uint3x2* lhs, const uint3x2* rhs );

// Returns a copy of the uint3x2 that has been component-wise divided by the given scalar value.
inline uint3x2 uint3x2_cdivs( const uint3x2* lhs, const uint32_t scalar );

// Returns a copy of the uint3x2 that has been component-wise divided by the corresponding component of the right-hand uint3x2.
inline uint3x2 uint3x2_cdivm( const uint3x2* lhs, const uint3x2* rhs );

// Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise AND'd against the corresponding component of the right-hand side uint3x2.
inline uint3x2 uint3x2_cand( const uint3x2* lhs, const uint3x2* rhs );

// Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise OR'd against the corresponding component of the right-hand side uint3x2.
inline uint3x2 uint3x2_cor( const uint3x2* lhs, const uint3x2* rhs );

// Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise XOR'd against the corresponding component of the right-hand side uint3x2.
inline uint3x2 uint3x2_cxor( const uint3x2* lhs, const uint3x2* rhs );

// Performs a unary bitwise operation on all components of the given uint3x2.
inline uint3x2 uint3x2_cunary( const uint3x2* lhs );

// Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise left-shifted by the corresponding component of the right-hand side uint3x2.
inline uint3x2 uint3x2_cshift_left( const uint3x2* lhs, const uint3x2* rhs );

// Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise right-shifted by the corresponding component of the right-hand side uint3x2.
inline uint3x2 uint3x2_cshift_right( const uint3x2* lhs, const uint3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x2 uint3x2_cmpl( const uint3x2* lhs, const uint3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x2 uint3x2_cmple( const uint3x2* lhs, const uint3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x2 uint3x2_cmpg( const uint3x2* lhs, const uint3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x2 uint3x2_cmpge( const uint3x2* lhs, const uint3x2* rhs );

// Sets the matrix to an identity matrix.
inline void uint3x2_identity( uint3x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint2x3 uint3x2_transpose( const uint3x2* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint3x3 uint3x2_mulm( const uint3x2* lhs, const uint2x3* rhs );


// uint3x3
// Returns true if the all the components of the left-hand-side uint3x3 match the other one, otherwise returns false.
inline bool uint3x3_cmpe( const uint3x3* lhs, const uint3x3* rhs );

// Returns true if not all of the components of the left-hand-side uint3x3 match the other one, otherwise returns false.
inline bool uint3x3_cmpne( const uint3x3* lhs, const uint3x3* rhs );

// Returns a copy of the uint3x3 that has been component-wise added by the given scalar value.
inline uint3x3 uint3x3_cadds( const uint3x3* lhs, const uint32_t scalar );

// Returns a copy of the uint3x3 that has been component-wise added by the corresponding component of the right-hand uint3x3.
inline uint3x3 uint3x3_caddm( const uint3x3* lhs, const uint3x3* rhs );

// Returns a copy of the uint3x3 that has been component-wise subtracted by the given scalar value.
inline uint3x3 uint3x3_csubs( const uint3x3* lhs, const uint32_t scalar );

// Returns a copy of the uint3x3 that has been component-wise subtracted by the corresponding component of the right-hand uint3x3.
inline uint3x3 uint3x3_csubm( const uint3x3* lhs, const uint3x3* rhs );

// Returns a copy of the uint3x3 that has been component-wise multiplied by the given scalar value.
inline uint3x3 uint3x3_cmuls( const uint3x3* lhs, const uint32_t scalar );

// Returns a copy of the uint3x3 that has been component-wise multiplied by the corresponding component of the right-hand uint3x3.
inline uint3x3 uint3x3_cmulm( const uint3x3* lhs, const uint3x3* rhs );

// Returns a copy of the uint3x3 that has been component-wise divided by the given scalar value.
inline uint3x3 uint3x3_cdivs( const uint3x3* lhs, const uint32_t scalar );

// Returns a copy of the uint3x3 that has been component-wise divided by the corresponding component of the right-hand uint3x3.
inline uint3x3 uint3x3_cdivm( const uint3x3* lhs, const uint3x3* rhs );

// Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise AND'd against the corresponding component of the right-hand side uint3x3.
inline uint3x3 uint3x3_cand( const uint3x3* lhs, const uint3x3* rhs );

// Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise OR'd against the corresponding component of the right-hand side uint3x3.
inline uint3x3 uint3x3_cor( const uint3x3* lhs, const uint3x3* rhs );

// Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise XOR'd against the corresponding component of the right-hand side uint3x3.
inline uint3x3 uint3x3_cxor( const uint3x3* lhs, const uint3x3* rhs );

// Performs a unary bitwise operation on all components of the given uint3x3.
inline uint3x3 uint3x3_cunary( const uint3x3* lhs );

// Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise left-shifted by the corresponding component of the right-hand side uint3x3.
inline uint3x3 uint3x3_cshift_left( const uint3x3* lhs, const uint3x3* rhs );

// Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise right-shifted by the corresponding component of the right-hand side uint3x3.
inline uint3x3 uint3x3_cshift_right( const uint3x3* lhs, const uint3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x3 uint3x3_cmpl( const uint3x3* lhs, const uint3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x3 uint3x3_cmple( const uint3x3* lhs, const uint3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x3 uint3x3_cmpg( const uint3x3* lhs, const uint3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x3 uint3x3_cmpge( const uint3x3* lhs, const uint3x3* rhs );

// Sets the matrix to an identity matrix.
inline void uint3x3_identity( uint3x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint3x3 uint3x3_transpose( const uint3x3* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint3x3 uint3x3_mulm( const uint3x3* lhs, const uint3x3* rhs );

// Returns the right-hand vector multiplied by the left-hand matrix.
inline uint3 uint3x3_mulv( const uint3x3* lhs, const uint3* rhs );

// Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline uint3x3 uint3x3_translate( const uint3x3* mat, const uint2* vec );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint3x3 uint3x3_scale( const uint3x3* mat, const uint2* vec );


// uint3x4
// Returns true if the all the components of the left-hand-side uint3x4 match the other one, otherwise returns false.
inline bool uint3x4_cmpe( const uint3x4* lhs, const uint3x4* rhs );

// Returns true if not all of the components of the left-hand-side uint3x4 match the other one, otherwise returns false.
inline bool uint3x4_cmpne( const uint3x4* lhs, const uint3x4* rhs );

// Returns a copy of the uint3x4 that has been component-wise added by the given scalar value.
inline uint3x4 uint3x4_cadds( const uint3x4* lhs, const uint32_t scalar );

// Returns a copy of the uint3x4 that has been component-wise added by the corresponding component of the right-hand uint3x4.
inline uint3x4 uint3x4_caddm( const uint3x4* lhs, const uint3x4* rhs );

// Returns a copy of the uint3x4 that has been component-wise subtracted by the given scalar value.
inline uint3x4 uint3x4_csubs( const uint3x4* lhs, const uint32_t scalar );

// Returns a copy of the uint3x4 that has been component-wise subtracted by the corresponding component of the right-hand uint3x4.
inline uint3x4 uint3x4_csubm( const uint3x4* lhs, const uint3x4* rhs );

// Returns a copy of the uint3x4 that has been component-wise multiplied by the given scalar value.
inline uint3x4 uint3x4_cmuls( const uint3x4* lhs, const uint32_t scalar );

// Returns a copy of the uint3x4 that has been component-wise multiplied by the corresponding component of the right-hand uint3x4.
inline uint3x4 uint3x4_cmulm( const uint3x4* lhs, const uint3x4* rhs );

// Returns a copy of the uint3x4 that has been component-wise divided by the given scalar value.
inline uint3x4 uint3x4_cdivs( const uint3x4* lhs, const uint32_t scalar );

// Returns a copy of the uint3x4 that has been component-wise divided by the corresponding component of the right-hand uint3x4.
inline uint3x4 uint3x4_cdivm( const uint3x4* lhs, const uint3x4* rhs );

// Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise AND'd against the corresponding component of the right-hand side uint3x4.
inline uint3x4 uint3x4_cand( const uint3x4* lhs, const uint3x4* rhs );

// Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise OR'd against the corresponding component of the right-hand side uint3x4.
inline uint3x4 uint3x4_cor( const uint3x4* lhs, const uint3x4* rhs );

// Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise XOR'd against the corresponding component of the right-hand side uint3x4.
inline uint3x4 uint3x4_cxor( const uint3x4* lhs, const uint3x4* rhs );

// Performs a unary bitwise operation on all components of the given uint3x4.
inline uint3x4 uint3x4_cunary( const uint3x4* lhs );

// Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise left-shifted by the corresponding component of the right-hand side uint3x4.
inline uint3x4 uint3x4_cshift_left( const uint3x4* lhs, const uint3x4* rhs );

// Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise right-shifted by the corresponding component of the right-hand side uint3x4.
inline uint3x4 uint3x4_cshift_right( const uint3x4* lhs, const uint3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x4 uint3x4_cmpl( const uint3x4* lhs, const uint3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x4 uint3x4_cmple( const uint3x4* lhs, const uint3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x4 uint3x4_cmpg( const uint3x4* lhs, const uint3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x4 uint3x4_cmpge( const uint3x4* lhs, const uint3x4* rhs );

// Sets the matrix to an identity matrix.
inline void uint3x4_identity( uint3x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint4x3 uint3x4_transpose( const uint3x4* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint3x3 uint3x4_mulm( const uint3x4* lhs, const uint4x3* rhs );

// Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline uint3x4 uint3x4_translate( const uint3x4* mat, const uint3* vec );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint3x4 uint3x4_scale( const uint3x4* mat, const uint2* vec );


// uint4x2
// Returns true if the all the components of the left-hand-side uint4x2 match the other one, otherwise returns false.
inline bool uint4x2_cmpe( const uint4x2* lhs, const uint4x2* rhs );

// Returns true if not all of the components of the left-hand-side uint4x2 match the other one, otherwise returns false.
inline bool uint4x2_cmpne( const uint4x2* lhs, const uint4x2* rhs );

// Returns a copy of the uint4x2 that has been component-wise added by the given scalar value.
inline uint4x2 uint4x2_cadds( const uint4x2* lhs, const uint32_t scalar );

// Returns a copy of the uint4x2 that has been component-wise added by the corresponding component of the right-hand uint4x2.
inline uint4x2 uint4x2_caddm( const uint4x2* lhs, const uint4x2* rhs );

// Returns a copy of the uint4x2 that has been component-wise subtracted by the given scalar value.
inline uint4x2 uint4x2_csubs( const uint4x2* lhs, const uint32_t scalar );

// Returns a copy of the uint4x2 that has been component-wise subtracted by the corresponding component of the right-hand uint4x2.
inline uint4x2 uint4x2_csubm( const uint4x2* lhs, const uint4x2* rhs );

// Returns a copy of the uint4x2 that has been component-wise multiplied by the given scalar value.
inline uint4x2 uint4x2_cmuls( const uint4x2* lhs, const uint32_t scalar );

// Returns a copy of the uint4x2 that has been component-wise multiplied by the corresponding component of the right-hand uint4x2.
inline uint4x2 uint4x2_cmulm( const uint4x2* lhs, const uint4x2* rhs );

// Returns a copy of the uint4x2 that has been component-wise divided by the given scalar value.
inline uint4x2 uint4x2_cdivs( const uint4x2* lhs, const uint32_t scalar );

// Returns a copy of the uint4x2 that has been component-wise divided by the corresponding component of the right-hand uint4x2.
inline uint4x2 uint4x2_cdivm( const uint4x2* lhs, const uint4x2* rhs );

// Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise AND'd against the corresponding component of the right-hand side uint4x2.
inline uint4x2 uint4x2_cand( const uint4x2* lhs, const uint4x2* rhs );

// Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise OR'd against the corresponding component of the right-hand side uint4x2.
inline uint4x2 uint4x2_cor( const uint4x2* lhs, const uint4x2* rhs );

// Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise XOR'd against the corresponding component of the right-hand side uint4x2.
inline uint4x2 uint4x2_cxor( const uint4x2* lhs, const uint4x2* rhs );

// Performs a unary bitwise operation on all components of the given uint4x2.
inline uint4x2 uint4x2_cunary( const uint4x2* lhs );

// Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise left-shifted by the corresponding component of the right-hand side uint4x2.
inline uint4x2 uint4x2_cshift_left( const uint4x2* lhs, const uint4x2* rhs );

// Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise right-shifted by the corresponding component of the right-hand side uint4x2.
inline uint4x2 uint4x2_cshift_right( const uint4x2* lhs, const uint4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x2 uint4x2_cmpl( const uint4x2* lhs, const uint4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x2 uint4x2_cmple( const uint4x2* lhs, const uint4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x2 uint4x2_cmpg( const uint4x2* lhs, const uint4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x2 uint4x2_cmpge( const uint4x2* lhs, const uint4x2* rhs );

// Sets the matrix to an identity matrix.
inline void uint4x2_identity( uint4x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint2x4 uint4x2_transpose( const uint4x2* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint4x4 uint4x2_mulm( const uint4x2* lhs, const uint2x4* rhs );


// uint4x3
// Returns true if the all the components of the left-hand-side uint4x3 match the other one, otherwise returns false.
inline bool uint4x3_cmpe( const uint4x3* lhs, const uint4x3* rhs );

// Returns true if not all of the components of the left-hand-side uint4x3 match the other one, otherwise returns false.
inline bool uint4x3_cmpne( const uint4x3* lhs, const uint4x3* rhs );

// Returns a copy of the uint4x3 that has been component-wise added by the given scalar value.
inline uint4x3 uint4x3_cadds( const uint4x3* lhs, const uint32_t scalar );

// Returns a copy of the uint4x3 that has been component-wise added by the corresponding component of the right-hand uint4x3.
inline uint4x3 uint4x3_caddm( const uint4x3* lhs, const uint4x3* rhs );

// Returns a copy of the uint4x3 that has been component-wise subtracted by the given scalar value.
inline uint4x3 uint4x3_csubs( const uint4x3* lhs, const uint32_t scalar );

// Returns a copy of the uint4x3 that has been component-wise subtracted by the corresponding component of the right-hand uint4x3.
inline uint4x3 uint4x3_csubm( const uint4x3* lhs, const uint4x3* rhs );

// Returns a copy of the uint4x3 that has been component-wise multiplied by the given scalar value.
inline uint4x3 uint4x3_cmuls( const uint4x3* lhs, const uint32_t scalar );

// Returns a copy of the uint4x3 that has been component-wise multiplied by the corresponding component of the right-hand uint4x3.
inline uint4x3 uint4x3_cmulm( const uint4x3* lhs, const uint4x3* rhs );

// Returns a copy of the uint4x3 that has been component-wise divided by the given scalar value.
inline uint4x3 uint4x3_cdivs( const uint4x3* lhs, const uint32_t scalar );

// Returns a copy of the uint4x3 that has been component-wise divided by the corresponding component of the right-hand uint4x3.
inline uint4x3 uint4x3_cdivm( const uint4x3* lhs, const uint4x3* rhs );

// Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise AND'd against the corresponding component of the right-hand side uint4x3.
inline uint4x3 uint4x3_cand( const uint4x3* lhs, const uint4x3* rhs );

// Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise OR'd against the corresponding component of the right-hand side uint4x3.
inline uint4x3 uint4x3_cor( const uint4x3* lhs, const uint4x3* rhs );

// Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise XOR'd against the corresponding component of the right-hand side uint4x3.
inline uint4x3 uint4x3_cxor( const uint4x3* lhs, const uint4x3* rhs );

// Performs a unary bitwise operation on all components of the given uint4x3.
inline uint4x3 uint4x3_cunary( const uint4x3* lhs );

// Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise left-shifted by the corresponding component of the right-hand side uint4x3.
inline uint4x3 uint4x3_cshift_left( const uint4x3* lhs, const uint4x3* rhs );

// Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise right-shifted by the corresponding component of the right-hand side uint4x3.
inline uint4x3 uint4x3_cshift_right( const uint4x3* lhs, const uint4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x3 uint4x3_cmpl( const uint4x3* lhs, const uint4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x3 uint4x3_cmple( const uint4x3* lhs, const uint4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x3 uint4x3_cmpg( const uint4x3* lhs, const uint4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x3 uint4x3_cmpge( const uint4x3* lhs, const uint4x3* rhs );

// Sets the matrix to an identity matrix.
inline void uint4x3_identity( uint4x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint3x4 uint4x3_transpose( const uint4x3* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint4x4 uint4x3_mulm( const uint4x3* lhs, const uint3x4* rhs );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint4x3 uint4x3_scale( const uint4x3* mat, const uint2* vec );


// uint4x4
// Returns true if the all the components of the left-hand-side uint4x4 match the other one, otherwise returns false.
inline bool uint4x4_cmpe( const uint4x4* lhs, const uint4x4* rhs );

// Returns true if not all of the components of the left-hand-side uint4x4 match the other one, otherwise returns false.
inline bool uint4x4_cmpne( const uint4x4* lhs, const uint4x4* rhs );

// Returns a copy of the uint4x4 that has been component-wise added by the given scalar value.
inline uint4x4 uint4x4_cadds( const uint4x4* lhs, const uint32_t scalar );

// Returns a copy of the uint4x4 that has been component-wise added by the corresponding component of the right-hand uint4x4.
inline uint4x4 uint4x4_caddm( const uint4x4* lhs, const uint4x4* rhs );

// Returns a copy of the uint4x4 that has been component-wise subtracted by the given scalar value.
inline uint4x4 uint4x4_csubs( const uint4x4* lhs, const uint32_t scalar );

// Returns a copy of the uint4x4 that has been component-wise subtracted by the corresponding component of the right-hand uint4x4.
inline uint4x4 uint4x4_csubm( const uint4x4* lhs, const uint4x4* rhs );

// Returns a copy of the uint4x4 that has been component-wise multiplied by the given scalar value.
inline uint4x4 uint4x4_cmuls( const uint4x4* lhs, const uint32_t scalar );

// Returns a copy of the uint4x4 that has been component-wise multiplied by the corresponding component of the right-hand uint4x4.
inline uint4x4 uint4x4_cmulm( const uint4x4* lhs, const uint4x4* rhs );

// Returns a copy of the uint4x4 that has been component-wise divided by the given scalar value.
inline uint4x4 uint4x4_cdivs( const uint4x4* lhs, const uint32_t scalar );

// Returns a copy of the uint4x4 that has been component-wise divided by the corresponding component of the right-hand uint4x4.
inline uint4x4 uint4x4_cdivm( const uint4x4* lhs, const uint4x4* rhs );

// Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise AND'd against the corresponding component of the right-hand side uint4x4.
inline uint4x4 uint4x4_cand( const uint4x4* lhs, const uint4x4* rhs );

// Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise OR'd against the corresponding component of the right-hand side uint4x4.
inline uint4x4 uint4x4_cor( const uint4x4* lhs, const uint4x4* rhs );

// Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise XOR'd against the corresponding component of the right-hand side uint4x4.
inline uint4x4 uint4x4_cxor( const uint4x4* lhs, const uint4x4* rhs );

// Performs a unary bitwise operation on all components of the given uint4x4.
inline uint4x4 uint4x4_cunary( const uint4x4* lhs );

// Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise left-shifted by the corresponding component of the right-hand side uint4x4.
inline uint4x4 uint4x4_cshift_left( const uint4x4* lhs, const uint4x4* rhs );

// Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise right-shifted by the corresponding component of the right-hand side uint4x4.
inline uint4x4 uint4x4_cshift_right( const uint4x4* lhs, const uint4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x4 uint4x4_cmpl( const uint4x4* lhs, const uint4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x4 uint4x4_cmple( const uint4x4* lhs, const uint4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x4 uint4x4_cmpg( const uint4x4* lhs, const uint4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x4 uint4x4_cmpge( const uint4x4* lhs, const uint4x4* rhs );

// Sets the matrix to an identity matrix.
inline void uint4x4_identity( uint4x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint4x4 uint4x4_transpose( const uint4x4* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint4x4 uint4x4_mulm( const uint4x4* lhs, const uint4x4* rhs );

// Returns the right-hand vector multiplied by the left-hand matrix.
inline uint4 uint4x4_mulv( const uint4x4* lhs, const uint4* rhs );

// Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline uint4x4 uint4x4_translate( const uint4x4* mat, const uint3* vec );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint4x4 uint4x4_scale( const uint4x4* mat, const uint3* vec );


// float2x2
// Returns true if the all the components of the left-hand-side float2x2 match the other one, otherwise returns false.
inline bool float2x2_cmpe( const float2x2* lhs, const float2x2* rhs );

// Returns true if not all of the components of the left-hand-side float2x2 match the other one, otherwise returns false.
inline bool float2x2_cmpne( const float2x2* lhs, const float2x2* rhs );

// Returns a copy of the float2x2 that has been component-wise added by the given scalar value.
inline float2x2 float2x2_cadds( const float2x2* lhs, const float scalar );

// Returns a copy of the float2x2 that has been component-wise added by the corresponding component of the right-hand float2x2.
inline float2x2 float2x2_caddm( const float2x2* lhs, const float2x2* rhs );

// Returns a copy of the float2x2 that has been component-wise subtracted by the given scalar value.
inline float2x2 float2x2_csubs( const float2x2* lhs, const float scalar );

// Returns a copy of the float2x2 that has been component-wise subtracted by the corresponding component of the right-hand float2x2.
inline float2x2 float2x2_csubm( const float2x2* lhs, const float2x2* rhs );

// Returns a copy of the float2x2 that has been component-wise multiplied by the given scalar value.
inline float2x2 float2x2_cmuls( const float2x2* lhs, const float scalar );

// Returns a copy of the float2x2 that has been component-wise multiplied by the corresponding component of the right-hand float2x2.
inline float2x2 float2x2_cmulm( const float2x2* lhs, const float2x2* rhs );

// Returns a copy of the float2x2 that has been component-wise divided by the given scalar value.
inline float2x2 float2x2_cdivs( const float2x2* lhs, const float scalar );

// Returns a copy of the float2x2 that has been component-wise divided by the corresponding component of the right-hand float2x2.
inline float2x2 float2x2_cdivm( const float2x2* lhs, const float2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x2 float2x2_cmpl( const float2x2* lhs, const float2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x2 float2x2_cmple( const float2x2* lhs, const float2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x2 float2x2_cmpg( const float2x2* lhs, const float2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x2 float2x2_cmpge( const float2x2* lhs, const float2x2* rhs );

// Sets the matrix to an identity matrix.
inline void float2x2_identity( float2x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float2x2 float2x2_transpose( const float2x2* mat );

// Returns the determinant of the matrix.
inline float float2x2_determinant( const float2x2* mat );

// Returns a copy of the matrix that is inversed.
// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline float2x2 float2x2_inverse( const float2x2* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float2x2 float2x2_mulm( const float2x2* lhs, const float2x2* rhs );

// Returns the right-hand vector multiplied by the left-hand matrix.
inline float2 float2x2_mulv( const float2x2* lhs, const float2* rhs );


// float2x3
// Returns true if the all the components of the left-hand-side float2x3 match the other one, otherwise returns false.
inline bool float2x3_cmpe( const float2x3* lhs, const float2x3* rhs );

// Returns true if not all of the components of the left-hand-side float2x3 match the other one, otherwise returns false.
inline bool float2x3_cmpne( const float2x3* lhs, const float2x3* rhs );

// Returns a copy of the float2x3 that has been component-wise added by the given scalar value.
inline float2x3 float2x3_cadds( const float2x3* lhs, const float scalar );

// Returns a copy of the float2x3 that has been component-wise added by the corresponding component of the right-hand float2x3.
inline float2x3 float2x3_caddm( const float2x3* lhs, const float2x3* rhs );

// Returns a copy of the float2x3 that has been component-wise subtracted by the given scalar value.
inline float2x3 float2x3_csubs( const float2x3* lhs, const float scalar );

// Returns a copy of the float2x3 that has been component-wise subtracted by the corresponding component of the right-hand float2x3.
inline float2x3 float2x3_csubm( const float2x3* lhs, const float2x3* rhs );

// Returns a copy of the float2x3 that has been component-wise multiplied by the given scalar value.
inline float2x3 float2x3_cmuls( const float2x3* lhs, const float scalar );

// Returns a copy of the float2x3 that has been component-wise multiplied by the corresponding component of the right-hand float2x3.
inline float2x3 float2x3_cmulm( const float2x3* lhs, const float2x3* rhs );

// Returns a copy of the float2x3 that has been component-wise divided by the given scalar value.
inline float2x3 float2x3_cdivs( const float2x3* lhs, const float scalar );

// Returns a copy of the float2x3 that has been component-wise divided by the corresponding component of the right-hand float2x3.
inline float2x3 float2x3_cdivm( const float2x3* lhs, const float2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x3 float2x3_cmpl( const float2x3* lhs, const float2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x3 float2x3_cmple( const float2x3* lhs, const float2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x3 float2x3_cmpg( const float2x3* lhs, const float2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x3 float2x3_cmpge( const float2x3* lhs, const float2x3* rhs );

// Sets the matrix to an identity matrix.
inline void float2x3_identity( float2x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float3x2 float2x3_transpose( const float2x3* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float2x2 float2x3_mulm( const float2x3* lhs, const float3x2* rhs );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float2x3 float2x3_scale( const float2x3* mat, const float2* vec );


// float2x4
// Returns true if the all the components of the left-hand-side float2x4 match the other one, otherwise returns false.
inline bool float2x4_cmpe( const float2x4* lhs, const float2x4* rhs );

// Returns true if not all of the components of the left-hand-side float2x4 match the other one, otherwise returns false.
inline bool float2x4_cmpne( const float2x4* lhs, const float2x4* rhs );

// Returns a copy of the float2x4 that has been component-wise added by the given scalar value.
inline float2x4 float2x4_cadds( const float2x4* lhs, const float scalar );

// Returns a copy of the float2x4 that has been component-wise added by the corresponding component of the right-hand float2x4.
inline float2x4 float2x4_caddm( const float2x4* lhs, const float2x4* rhs );

// Returns a copy of the float2x4 that has been component-wise subtracted by the given scalar value.
inline float2x4 float2x4_csubs( const float2x4* lhs, const float scalar );

// Returns a copy of the float2x4 that has been component-wise subtracted by the corresponding component of the right-hand float2x4.
inline float2x4 float2x4_csubm( const float2x4* lhs, const float2x4* rhs );

// Returns a copy of the float2x4 that has been component-wise multiplied by the given scalar value.
inline float2x4 float2x4_cmuls( const float2x4* lhs, const float scalar );

// Returns a copy of the float2x4 that has been component-wise multiplied by the corresponding component of the right-hand float2x4.
inline float2x4 float2x4_cmulm( const float2x4* lhs, const float2x4* rhs );

// Returns a copy of the float2x4 that has been component-wise divided by the given scalar value.
inline float2x4 float2x4_cdivs( const float2x4* lhs, const float scalar );

// Returns a copy of the float2x4 that has been component-wise divided by the corresponding component of the right-hand float2x4.
inline float2x4 float2x4_cdivm( const float2x4* lhs, const float2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x4 float2x4_cmpl( const float2x4* lhs, const float2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x4 float2x4_cmple( const float2x4* lhs, const float2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x4 float2x4_cmpg( const float2x4* lhs, const float2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x4 float2x4_cmpge( const float2x4* lhs, const float2x4* rhs );

// Sets the matrix to an identity matrix.
inline void float2x4_identity( float2x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float4x2 float2x4_transpose( const float2x4* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float2x2 float2x4_mulm( const float2x4* lhs, const float4x2* rhs );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float2x4 float2x4_scale( const float2x4* mat, const float2* vec );


// float3x2
// Returns true if the all the components of the left-hand-side float3x2 match the other one, otherwise returns false.
inline bool float3x2_cmpe( const float3x2* lhs, const float3x2* rhs );

// Returns true if not all of the components of the left-hand-side float3x2 match the other one, otherwise returns false.
inline bool float3x2_cmpne( const float3x2* lhs, const float3x2* rhs );

// Returns a copy of the float3x2 that has been component-wise added by the given scalar value.
inline float3x2 float3x2_cadds( const float3x2* lhs, const float scalar );

// Returns a copy of the float3x2 that has been component-wise added by the corresponding component of the right-hand float3x2.
inline float3x2 float3x2_caddm( const float3x2* lhs, const float3x2* rhs );

// Returns a copy of the float3x2 that has been component-wise subtracted by the given scalar value.
inline float3x2 float3x2_csubs( const float3x2* lhs, const float scalar );

// Returns a copy of the float3x2 that has been component-wise subtracted by the corresponding component of the right-hand float3x2.
inline float3x2 float3x2_csubm( const float3x2* lhs, const float3x2* rhs );

// Returns a copy of the float3x2 that has been component-wise multiplied by the given scalar value.
inline float3x2 float3x2_cmuls( const float3x2* lhs, const float scalar );

// Returns a copy of the float3x2 that has been component-wise multiplied by the corresponding component of the right-hand float3x2.
inline float3x2 float3x2_cmulm( const float3x2* lhs, const float3x2* rhs );

// Returns a copy of the float3x2 that has been component-wise divided by the given scalar value.
inline float3x2 float3x2_cdivs( const float3x2* lhs, const float scalar );

// Returns a copy of the float3x2 that has been component-wise divided by the corresponding component of the right-hand float3x2.
inline float3x2 float3x2_cdivm( const float3x2* lhs, const float3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x2 float3x2_cmpl( const float3x2* lhs, const float3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x2 float3x2_cmple( const float3x2* lhs, const float3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x2 float3x2_cmpg( const float3x2* lhs, const float3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x2 float3x2_cmpge( const float3x2* lhs, const float3x2* rhs );

// Sets the matrix to an identity matrix.
inline void float3x2_identity( float3x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float2x3 float3x2_transpose( const float3x2* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float3x3 float3x2_mulm( const float3x2* lhs, const float2x3* rhs );


// float3x3
// Returns true if the all the components of the left-hand-side float3x3 match the other one, otherwise returns false.
inline bool float3x3_cmpe( const float3x3* lhs, const float3x3* rhs );

// Returns true if not all of the components of the left-hand-side float3x3 match the other one, otherwise returns false.
inline bool float3x3_cmpne( const float3x3* lhs, const float3x3* rhs );

// Returns a copy of the float3x3 that has been component-wise added by the given scalar value.
inline float3x3 float3x3_cadds( const float3x3* lhs, const float scalar );

// Returns a copy of the float3x3 that has been component-wise added by the corresponding component of the right-hand float3x3.
inline float3x3 float3x3_caddm( const float3x3* lhs, const float3x3* rhs );

// Returns a copy of the float3x3 that has been component-wise subtracted by the given scalar value.
inline float3x3 float3x3_csubs( const float3x3* lhs, const float scalar );

// Returns a copy of the float3x3 that has been component-wise subtracted by the corresponding component of the right-hand float3x3.
inline float3x3 float3x3_csubm( const float3x3* lhs, const float3x3* rhs );

// Returns a copy of the float3x3 that has been component-wise multiplied by the given scalar value.
inline float3x3 float3x3_cmuls( const float3x3* lhs, const float scalar );

// Returns a copy of the float3x3 that has been component-wise multiplied by the corresponding component of the right-hand float3x3.
inline float3x3 float3x3_cmulm( const float3x3* lhs, const float3x3* rhs );

// Returns a copy of the float3x3 that has been component-wise divided by the given scalar value.
inline float3x3 float3x3_cdivs( const float3x3* lhs, const float scalar );

// Returns a copy of the float3x3 that has been component-wise divided by the corresponding component of the right-hand float3x3.
inline float3x3 float3x3_cdivm( const float3x3* lhs, const float3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x3 float3x3_cmpl( const float3x3* lhs, const float3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x3 float3x3_cmple( const float3x3* lhs, const float3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x3 float3x3_cmpg( const float3x3* lhs, const float3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x3 float3x3_cmpge( const float3x3* lhs, const float3x3* rhs );

// Sets the matrix to an identity matrix.
inline void float3x3_identity( float3x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float3x3 float3x3_transpose( const float3x3* mat );

// Returns the determinant of the matrix.
inline float float3x3_determinant( const float3x3* mat );

// Returns a copy of the matrix that is inversed.
// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline float3x3 float3x3_inverse( const float3x3* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float3x3 float3x3_mulm( const float3x3* lhs, const float3x3* rhs );

// Returns the right-hand vector multiplied by the left-hand matrix.
inline float3 float3x3_mulv( const float3x3* lhs, const float3* rhs );

// Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline float3x3 float3x3_translate( const float3x3* mat, const float2* vec );

// Returns a copy of the matrix that has had a rotation applied to it in radians on one or more of the following axes.
inline float3x3 float3x3_rotate( const float3x3* mat, const float rad );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float3x3 float3x3_scale( const float3x3* mat, const float2* vec );


// float3x4
// Returns true if the all the components of the left-hand-side float3x4 match the other one, otherwise returns false.
inline bool float3x4_cmpe( const float3x4* lhs, const float3x4* rhs );

// Returns true if not all of the components of the left-hand-side float3x4 match the other one, otherwise returns false.
inline bool float3x4_cmpne( const float3x4* lhs, const float3x4* rhs );

// Returns a copy of the float3x4 that has been component-wise added by the given scalar value.
inline float3x4 float3x4_cadds( const float3x4* lhs, const float scalar );

// Returns a copy of the float3x4 that has been component-wise added by the corresponding component of the right-hand float3x4.
inline float3x4 float3x4_caddm( const float3x4* lhs, const float3x4* rhs );

// Returns a copy of the float3x4 that has been component-wise subtracted by the given scalar value.
inline float3x4 float3x4_csubs( const float3x4* lhs, const float scalar );

// Returns a copy of the float3x4 that has been component-wise subtracted by the corresponding component of the right-hand float3x4.
inline float3x4 float3x4_csubm( const float3x4* lhs, const float3x4* rhs );

// Returns a copy of the float3x4 that has been component-wise multiplied by the given scalar value.
inline float3x4 float3x4_cmuls( const float3x4* lhs, const float scalar );

// Returns a copy of the float3x4 that has been component-wise multiplied by the corresponding component of the right-hand float3x4.
inline float3x4 float3x4_cmulm( const float3x4* lhs, const float3x4* rhs );

// Returns a copy of the float3x4 that has been component-wise divided by the given scalar value.
inline float3x4 float3x4_cdivs( const float3x4* lhs, const float scalar );

// Returns a copy of the float3x4 that has been component-wise divided by the corresponding component of the right-hand float3x4.
inline float3x4 float3x4_cdivm( const float3x4* lhs, const float3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x4 float3x4_cmpl( const float3x4* lhs, const float3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x4 float3x4_cmple( const float3x4* lhs, const float3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x4 float3x4_cmpg( const float3x4* lhs, const float3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x4 float3x4_cmpge( const float3x4* lhs, const float3x4* rhs );

// Sets the matrix to an identity matrix.
inline void float3x4_identity( float3x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float4x3 float3x4_transpose( const float3x4* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float3x3 float3x4_mulm( const float3x4* lhs, const float4x3* rhs );

// Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline float3x4 float3x4_translate( const float3x4* mat, const float3* vec );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float3x4 float3x4_scale( const float3x4* mat, const float2* vec );


// float4x2
// Returns true if the all the components of the left-hand-side float4x2 match the other one, otherwise returns false.
inline bool float4x2_cmpe( const float4x2* lhs, const float4x2* rhs );

// Returns true if not all of the components of the left-hand-side float4x2 match the other one, otherwise returns false.
inline bool float4x2_cmpne( const float4x2* lhs, const float4x2* rhs );

// Returns a copy of the float4x2 that has been component-wise added by the given scalar value.
inline float4x2 float4x2_cadds( const float4x2* lhs, const float scalar );

// Returns a copy of the float4x2 that has been component-wise added by the corresponding component of the right-hand float4x2.
inline float4x2 float4x2_caddm( const float4x2* lhs, const float4x2* rhs );

// Returns a copy of the float4x2 that has been component-wise subtracted by the given scalar value.
inline float4x2 float4x2_csubs( const float4x2* lhs, const float scalar );

// Returns a copy of the float4x2 that has been component-wise subtracted by the corresponding component of the right-hand float4x2.
inline float4x2 float4x2_csubm( const float4x2* lhs, const float4x2* rhs );

// Returns a copy of the float4x2 that has been component-wise multiplied by the given scalar value.
inline float4x2 float4x2_cmuls( const float4x2* lhs, const float scalar );

// Returns a copy of the float4x2 that has been component-wise multiplied by the corresponding component of the right-hand float4x2.
inline float4x2 float4x2_cmulm( const float4x2* lhs, const float4x2* rhs );

// Returns a copy of the float4x2 that has been component-wise divided by the given scalar value.
inline float4x2 float4x2_cdivs( const float4x2* lhs, const float scalar );

// Returns a copy of the float4x2 that has been component-wise divided by the corresponding component of the right-hand float4x2.
inline float4x2 float4x2_cdivm( const float4x2* lhs, const float4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x2 float4x2_cmpl( const float4x2* lhs, const float4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x2 float4x2_cmple( const float4x2* lhs, const float4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x2 float4x2_cmpg( const float4x2* lhs, const float4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x2 float4x2_cmpge( const float4x2* lhs, const float4x2* rhs );

// Sets the matrix to an identity matrix.
inline void float4x2_identity( float4x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float2x4 float4x2_transpose( const float4x2* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float4x4 float4x2_mulm( const float4x2* lhs, const float2x4* rhs );


// float4x3
// Returns true if the all the components of the left-hand-side float4x3 match the other one, otherwise returns false.
inline bool float4x3_cmpe( const float4x3* lhs, const float4x3* rhs );

// Returns true if not all of the components of the left-hand-side float4x3 match the other one, otherwise returns false.
inline bool float4x3_cmpne( const float4x3* lhs, const float4x3* rhs );

// Returns a copy of the float4x3 that has been component-wise added by the given scalar value.
inline float4x3 float4x3_cadds( const float4x3* lhs, const float scalar );

// Returns a copy of the float4x3 that has been component-wise added by the corresponding component of the right-hand float4x3.
inline float4x3 float4x3_caddm( const float4x3* lhs, const float4x3* rhs );

// Returns a copy of the float4x3 that has been component-wise subtracted by the given scalar value.
inline float4x3 float4x3_csubs( const float4x3* lhs, const float scalar );

// Returns a copy of the float4x3 that has been component-wise subtracted by the corresponding component of the right-hand float4x3.
inline float4x3 float4x3_csubm( const float4x3* lhs, const float4x3* rhs );

// Returns a copy of the float4x3 that has been component-wise multiplied by the given scalar value.
inline float4x3 float4x3_cmuls( const float4x3* lhs, const float scalar );

// Returns a copy of the float4x3 that has been component-wise multiplied by the corresponding component of the right-hand float4x3.
inline float4x3 float4x3_cmulm( const float4x3* lhs, const float4x3* rhs );

// Returns a copy of the float4x3 that has been component-wise divided by the given scalar value.
inline float4x3 float4x3_cdivs( const float4x3* lhs, const float scalar );

// Returns a copy of the float4x3 that has been component-wise divided by the corresponding component of the right-hand float4x3.
inline float4x3 float4x3_cdivm( const float4x3* lhs, const float4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x3 float4x3_cmpl( const float4x3* lhs, const float4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x3 float4x3_cmple( const float4x3* lhs, const float4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x3 float4x3_cmpg( const float4x3* lhs, const float4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x3 float4x3_cmpge( const float4x3* lhs, const float4x3* rhs );

// Sets the matrix to an identity matrix.
inline void float4x3_identity( float4x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float3x4 float4x3_transpose( const float4x3* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float4x4 float4x3_mulm( const float4x3* lhs, const float3x4* rhs );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float4x3 float4x3_scale( const float4x3* mat, const float2* vec );


// float4x4
// Returns true if the all the components of the left-hand-side float4x4 match the other one, otherwise returns false.
inline bool float4x4_cmpe( const float4x4* lhs, const float4x4* rhs );

// Returns true if not all of the components of the left-hand-side float4x4 match the other one, otherwise returns false.
inline bool float4x4_cmpne( const float4x4* lhs, const float4x4* rhs );

// Returns a copy of the float4x4 that has been component-wise added by the given scalar value.
inline float4x4 float4x4_cadds( const float4x4* lhs, const float scalar );

// Returns a copy of the float4x4 that has been component-wise added by the corresponding component of the right-hand float4x4.
inline float4x4 float4x4_caddm( const float4x4* lhs, const float4x4* rhs );

// Returns a copy of the float4x4 that has been component-wise subtracted by the given scalar value.
inline float4x4 float4x4_csubs( const float4x4* lhs, const float scalar );

// Returns a copy of the float4x4 that has been component-wise subtracted by the corresponding component of the right-hand float4x4.
inline float4x4 float4x4_csubm( const float4x4* lhs, const float4x4* rhs );

// Returns a copy of the float4x4 that has been component-wise multiplied by the given scalar value.
inline float4x4 float4x4_cmuls( const float4x4* lhs, const float scalar );

// Returns a copy of the float4x4 that has been component-wise multiplied by the corresponding component of the right-hand float4x4.
inline float4x4 float4x4_cmulm( const float4x4* lhs, const float4x4* rhs );

// Returns a copy of the float4x4 that has been component-wise divided by the given scalar value.
inline float4x4 float4x4_cdivs( const float4x4* lhs, const float scalar );

// Returns a copy of the float4x4 that has been component-wise divided by the corresponding component of the right-hand float4x4.
inline float4x4 float4x4_cdivm( const float4x4* lhs, const float4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x4 float4x4_cmpl( const float4x4* lhs, const float4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x4 float4x4_cmple( const float4x4* lhs, const float4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x4 float4x4_cmpg( const float4x4* lhs, const float4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x4 float4x4_cmpge( const float4x4* lhs, const float4x4* rhs );

// Sets the matrix to an identity matrix.
inline void float4x4_identity( float4x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float4x4 float4x4_transpose( const float4x4* mat );

// Returns the determinant of the matrix.
inline float float4x4_determinant( const float4x4* mat );

// Returns a copy of the matrix that is inversed.
// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline float4x4 float4x4_inverse( const float4x4* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float4x4 float4x4_mulm( const float4x4* lhs, const float4x4* rhs );

// Returns the right-hand vector multiplied by the left-hand matrix.
inline float4 float4x4_mulv( const float4x4* lhs, const float4* rhs );

// Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline float4x4 float4x4_translate( const float4x4* mat, const float3* vec );

// Returns a copy of the matrix that has had a rotation applied to it in radians on one or more of the following axes.
inline float4x4 float4x4_rotate( const float4x4* mat, const float rad, const float3* axis );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float4x4 float4x4_scale( const float4x4* mat, const float3* vec );

// Returns an left-handed orthographic projection matrix with the clip-space range zero to one.
inline float4x4 float4x4_ortho_lh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar );

// Returns an left-handed orthographic projection matrix with the clip-space range minus-one to one.
inline float4x4 float4x4_ortho_lh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar );

// Returns an right-handed orthographic projection matrix with the clip-space range zero to one.
inline float4x4 float4x4_ortho_rh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar );

// Returns an right-handed orthographic projection matrix with the clip-space range minus-one to one.
inline float4x4 float4x4_ortho_rh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar );

// Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of zero to one.
inline float4x4 float4x4_perspective_lh_zo( const float fovdeg, const float aspect, const float znear, const float zfar );

// Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of minus-one to one.
inline float4x4 float4x4_perspective_lh_no( const float fovdeg, const float aspect, const float znear, const float zfar );

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of zero to one.
inline float4x4 float4x4_perspective_rh_zo( const float fovdeg, const float aspect, const float znear, const float zfar );

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of minus-one to one.
inline float4x4 float4x4_perspective_rh_no( const float fovdeg, const float aspect, const float znear, const float zfar );

// Returns a left-handed orthonormal matrix that is oriented at position eye to look at position target.
inline float4x4 float4x4_lookat_lh( const float3* eye, const float3* target, const float3* up );

// Returns a right-handed orthonormal matrix that is oriented at position eye to look at position target.
inline float4x4 float4x4_lookat_rh( const float3* eye, const float3* target, const float3* up );


// double2x2
// Returns true if the all the components of the left-hand-side double2x2 match the other one, otherwise returns false.
inline bool double2x2_cmpe( const double2x2* lhs, const double2x2* rhs );

// Returns true if not all of the components of the left-hand-side double2x2 match the other one, otherwise returns false.
inline bool double2x2_cmpne( const double2x2* lhs, const double2x2* rhs );

// Returns a copy of the double2x2 that has been component-wise added by the given scalar value.
inline double2x2 double2x2_cadds( const double2x2* lhs, const double scalar );

// Returns a copy of the double2x2 that has been component-wise added by the corresponding component of the right-hand double2x2.
inline double2x2 double2x2_caddm( const double2x2* lhs, const double2x2* rhs );

// Returns a copy of the double2x2 that has been component-wise subtracted by the given scalar value.
inline double2x2 double2x2_csubs( const double2x2* lhs, const double scalar );

// Returns a copy of the double2x2 that has been component-wise subtracted by the corresponding component of the right-hand double2x2.
inline double2x2 double2x2_csubm( const double2x2* lhs, const double2x2* rhs );

// Returns a copy of the double2x2 that has been component-wise multiplied by the given scalar value.
inline double2x2 double2x2_cmuls( const double2x2* lhs, const double scalar );

// Returns a copy of the double2x2 that has been component-wise multiplied by the corresponding component of the right-hand double2x2.
inline double2x2 double2x2_cmulm( const double2x2* lhs, const double2x2* rhs );

// Returns a copy of the double2x2 that has been component-wise divided by the given scalar value.
inline double2x2 double2x2_cdivs( const double2x2* lhs, const double scalar );

// Returns a copy of the double2x2 that has been component-wise divided by the corresponding component of the right-hand double2x2.
inline double2x2 double2x2_cdivm( const double2x2* lhs, const double2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x2 double2x2_cmpl( const double2x2* lhs, const double2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x2 double2x2_cmple( const double2x2* lhs, const double2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x2 double2x2_cmpg( const double2x2* lhs, const double2x2* rhs );

// Returns a bool2x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x2 double2x2_cmpge( const double2x2* lhs, const double2x2* rhs );

// Sets the matrix to an identity matrix.
inline void double2x2_identity( double2x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double2x2 double2x2_transpose( const double2x2* mat );

// Returns the determinant of the matrix.
inline double double2x2_determinant( const double2x2* mat );

// Returns a copy of the matrix that is inversed.
// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline double2x2 double2x2_inverse( const double2x2* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double2x2 double2x2_mulm( const double2x2* lhs, const double2x2* rhs );

// Returns the right-hand vector multiplied by the left-hand matrix.
inline double2 double2x2_mulv( const double2x2* lhs, const double2* rhs );


// double2x3
// Returns true if the all the components of the left-hand-side double2x3 match the other one, otherwise returns false.
inline bool double2x3_cmpe( const double2x3* lhs, const double2x3* rhs );

// Returns true if not all of the components of the left-hand-side double2x3 match the other one, otherwise returns false.
inline bool double2x3_cmpne( const double2x3* lhs, const double2x3* rhs );

// Returns a copy of the double2x3 that has been component-wise added by the given scalar value.
inline double2x3 double2x3_cadds( const double2x3* lhs, const double scalar );

// Returns a copy of the double2x3 that has been component-wise added by the corresponding component of the right-hand double2x3.
inline double2x3 double2x3_caddm( const double2x3* lhs, const double2x3* rhs );

// Returns a copy of the double2x3 that has been component-wise subtracted by the given scalar value.
inline double2x3 double2x3_csubs( const double2x3* lhs, const double scalar );

// Returns a copy of the double2x3 that has been component-wise subtracted by the corresponding component of the right-hand double2x3.
inline double2x3 double2x3_csubm( const double2x3* lhs, const double2x3* rhs );

// Returns a copy of the double2x3 that has been component-wise multiplied by the given scalar value.
inline double2x3 double2x3_cmuls( const double2x3* lhs, const double scalar );

// Returns a copy of the double2x3 that has been component-wise multiplied by the corresponding component of the right-hand double2x3.
inline double2x3 double2x3_cmulm( const double2x3* lhs, const double2x3* rhs );

// Returns a copy of the double2x3 that has been component-wise divided by the given scalar value.
inline double2x3 double2x3_cdivs( const double2x3* lhs, const double scalar );

// Returns a copy of the double2x3 that has been component-wise divided by the corresponding component of the right-hand double2x3.
inline double2x3 double2x3_cdivm( const double2x3* lhs, const double2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x3 double2x3_cmpl( const double2x3* lhs, const double2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x3 double2x3_cmple( const double2x3* lhs, const double2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x3 double2x3_cmpg( const double2x3* lhs, const double2x3* rhs );

// Returns a bool2x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x3 double2x3_cmpge( const double2x3* lhs, const double2x3* rhs );

// Sets the matrix to an identity matrix.
inline void double2x3_identity( double2x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double3x2 double2x3_transpose( const double2x3* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double2x2 double2x3_mulm( const double2x3* lhs, const double3x2* rhs );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double2x3 double2x3_scale( const double2x3* mat, const double2* vec );


// double2x4
// Returns true if the all the components of the left-hand-side double2x4 match the other one, otherwise returns false.
inline bool double2x4_cmpe( const double2x4* lhs, const double2x4* rhs );

// Returns true if not all of the components of the left-hand-side double2x4 match the other one, otherwise returns false.
inline bool double2x4_cmpne( const double2x4* lhs, const double2x4* rhs );

// Returns a copy of the double2x4 that has been component-wise added by the given scalar value.
inline double2x4 double2x4_cadds( const double2x4* lhs, const double scalar );

// Returns a copy of the double2x4 that has been component-wise added by the corresponding component of the right-hand double2x4.
inline double2x4 double2x4_caddm( const double2x4* lhs, const double2x4* rhs );

// Returns a copy of the double2x4 that has been component-wise subtracted by the given scalar value.
inline double2x4 double2x4_csubs( const double2x4* lhs, const double scalar );

// Returns a copy of the double2x4 that has been component-wise subtracted by the corresponding component of the right-hand double2x4.
inline double2x4 double2x4_csubm( const double2x4* lhs, const double2x4* rhs );

// Returns a copy of the double2x4 that has been component-wise multiplied by the given scalar value.
inline double2x4 double2x4_cmuls( const double2x4* lhs, const double scalar );

// Returns a copy of the double2x4 that has been component-wise multiplied by the corresponding component of the right-hand double2x4.
inline double2x4 double2x4_cmulm( const double2x4* lhs, const double2x4* rhs );

// Returns a copy of the double2x4 that has been component-wise divided by the given scalar value.
inline double2x4 double2x4_cdivs( const double2x4* lhs, const double scalar );

// Returns a copy of the double2x4 that has been component-wise divided by the corresponding component of the right-hand double2x4.
inline double2x4 double2x4_cdivm( const double2x4* lhs, const double2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x4 double2x4_cmpl( const double2x4* lhs, const double2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x4 double2x4_cmple( const double2x4* lhs, const double2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x4 double2x4_cmpg( const double2x4* lhs, const double2x4* rhs );

// Returns a bool2x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x4 double2x4_cmpge( const double2x4* lhs, const double2x4* rhs );

// Sets the matrix to an identity matrix.
inline void double2x4_identity( double2x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double4x2 double2x4_transpose( const double2x4* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double2x2 double2x4_mulm( const double2x4* lhs, const double4x2* rhs );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double2x4 double2x4_scale( const double2x4* mat, const double2* vec );


// double3x2
// Returns true if the all the components of the left-hand-side double3x2 match the other one, otherwise returns false.
inline bool double3x2_cmpe( const double3x2* lhs, const double3x2* rhs );

// Returns true if not all of the components of the left-hand-side double3x2 match the other one, otherwise returns false.
inline bool double3x2_cmpne( const double3x2* lhs, const double3x2* rhs );

// Returns a copy of the double3x2 that has been component-wise added by the given scalar value.
inline double3x2 double3x2_cadds( const double3x2* lhs, const double scalar );

// Returns a copy of the double3x2 that has been component-wise added by the corresponding component of the right-hand double3x2.
inline double3x2 double3x2_caddm( const double3x2* lhs, const double3x2* rhs );

// Returns a copy of the double3x2 that has been component-wise subtracted by the given scalar value.
inline double3x2 double3x2_csubs( const double3x2* lhs, const double scalar );

// Returns a copy of the double3x2 that has been component-wise subtracted by the corresponding component of the right-hand double3x2.
inline double3x2 double3x2_csubm( const double3x2* lhs, const double3x2* rhs );

// Returns a copy of the double3x2 that has been component-wise multiplied by the given scalar value.
inline double3x2 double3x2_cmuls( const double3x2* lhs, const double scalar );

// Returns a copy of the double3x2 that has been component-wise multiplied by the corresponding component of the right-hand double3x2.
inline double3x2 double3x2_cmulm( const double3x2* lhs, const double3x2* rhs );

// Returns a copy of the double3x2 that has been component-wise divided by the given scalar value.
inline double3x2 double3x2_cdivs( const double3x2* lhs, const double scalar );

// Returns a copy of the double3x2 that has been component-wise divided by the corresponding component of the right-hand double3x2.
inline double3x2 double3x2_cdivm( const double3x2* lhs, const double3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x2 double3x2_cmpl( const double3x2* lhs, const double3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x2 double3x2_cmple( const double3x2* lhs, const double3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x2 double3x2_cmpg( const double3x2* lhs, const double3x2* rhs );

// Returns a bool3x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x2 double3x2_cmpge( const double3x2* lhs, const double3x2* rhs );

// Sets the matrix to an identity matrix.
inline void double3x2_identity( double3x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double2x3 double3x2_transpose( const double3x2* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double3x3 double3x2_mulm( const double3x2* lhs, const double2x3* rhs );


// double3x3
// Returns true if the all the components of the left-hand-side double3x3 match the other one, otherwise returns false.
inline bool double3x3_cmpe( const double3x3* lhs, const double3x3* rhs );

// Returns true if not all of the components of the left-hand-side double3x3 match the other one, otherwise returns false.
inline bool double3x3_cmpne( const double3x3* lhs, const double3x3* rhs );

// Returns a copy of the double3x3 that has been component-wise added by the given scalar value.
inline double3x3 double3x3_cadds( const double3x3* lhs, const double scalar );

// Returns a copy of the double3x3 that has been component-wise added by the corresponding component of the right-hand double3x3.
inline double3x3 double3x3_caddm( const double3x3* lhs, const double3x3* rhs );

// Returns a copy of the double3x3 that has been component-wise subtracted by the given scalar value.
inline double3x3 double3x3_csubs( const double3x3* lhs, const double scalar );

// Returns a copy of the double3x3 that has been component-wise subtracted by the corresponding component of the right-hand double3x3.
inline double3x3 double3x3_csubm( const double3x3* lhs, const double3x3* rhs );

// Returns a copy of the double3x3 that has been component-wise multiplied by the given scalar value.
inline double3x3 double3x3_cmuls( const double3x3* lhs, const double scalar );

// Returns a copy of the double3x3 that has been component-wise multiplied by the corresponding component of the right-hand double3x3.
inline double3x3 double3x3_cmulm( const double3x3* lhs, const double3x3* rhs );

// Returns a copy of the double3x3 that has been component-wise divided by the given scalar value.
inline double3x3 double3x3_cdivs( const double3x3* lhs, const double scalar );

// Returns a copy of the double3x3 that has been component-wise divided by the corresponding component of the right-hand double3x3.
inline double3x3 double3x3_cdivm( const double3x3* lhs, const double3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x3 double3x3_cmpl( const double3x3* lhs, const double3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x3 double3x3_cmple( const double3x3* lhs, const double3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x3 double3x3_cmpg( const double3x3* lhs, const double3x3* rhs );

// Returns a bool3x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x3 double3x3_cmpge( const double3x3* lhs, const double3x3* rhs );

// Sets the matrix to an identity matrix.
inline void double3x3_identity( double3x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double3x3 double3x3_transpose( const double3x3* mat );

// Returns the determinant of the matrix.
inline double double3x3_determinant( const double3x3* mat );

// Returns a copy of the matrix that is inversed.
// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline double3x3 double3x3_inverse( const double3x3* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double3x3 double3x3_mulm( const double3x3* lhs, const double3x3* rhs );

// Returns the right-hand vector multiplied by the left-hand matrix.
inline double3 double3x3_mulv( const double3x3* lhs, const double3* rhs );

// Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline double3x3 double3x3_translate( const double3x3* mat, const double2* vec );

// Returns a copy of the matrix that has had a rotation applied to it in radians on one or more of the following axes.
inline double3x3 double3x3_rotate( const double3x3* mat, const double rad );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double3x3 double3x3_scale( const double3x3* mat, const double2* vec );


// double3x4
// Returns true if the all the components of the left-hand-side double3x4 match the other one, otherwise returns false.
inline bool double3x4_cmpe( const double3x4* lhs, const double3x4* rhs );

// Returns true if not all of the components of the left-hand-side double3x4 match the other one, otherwise returns false.
inline bool double3x4_cmpne( const double3x4* lhs, const double3x4* rhs );

// Returns a copy of the double3x4 that has been component-wise added by the given scalar value.
inline double3x4 double3x4_cadds( const double3x4* lhs, const double scalar );

// Returns a copy of the double3x4 that has been component-wise added by the corresponding component of the right-hand double3x4.
inline double3x4 double3x4_caddm( const double3x4* lhs, const double3x4* rhs );

// Returns a copy of the double3x4 that has been component-wise subtracted by the given scalar value.
inline double3x4 double3x4_csubs( const double3x4* lhs, const double scalar );

// Returns a copy of the double3x4 that has been component-wise subtracted by the corresponding component of the right-hand double3x4.
inline double3x4 double3x4_csubm( const double3x4* lhs, const double3x4* rhs );

// Returns a copy of the double3x4 that has been component-wise multiplied by the given scalar value.
inline double3x4 double3x4_cmuls( const double3x4* lhs, const double scalar );

// Returns a copy of the double3x4 that has been component-wise multiplied by the corresponding component of the right-hand double3x4.
inline double3x4 double3x4_cmulm( const double3x4* lhs, const double3x4* rhs );

// Returns a copy of the double3x4 that has been component-wise divided by the given scalar value.
inline double3x4 double3x4_cdivs( const double3x4* lhs, const double scalar );

// Returns a copy of the double3x4 that has been component-wise divided by the corresponding component of the right-hand double3x4.
inline double3x4 double3x4_cdivm( const double3x4* lhs, const double3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x4 double3x4_cmpl( const double3x4* lhs, const double3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x4 double3x4_cmple( const double3x4* lhs, const double3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x4 double3x4_cmpg( const double3x4* lhs, const double3x4* rhs );

// Returns a bool3x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x4 double3x4_cmpge( const double3x4* lhs, const double3x4* rhs );

// Sets the matrix to an identity matrix.
inline void double3x4_identity( double3x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double4x3 double3x4_transpose( const double3x4* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double3x3 double3x4_mulm( const double3x4* lhs, const double4x3* rhs );

// Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline double3x4 double3x4_translate( const double3x4* mat, const double3* vec );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double3x4 double3x4_scale( const double3x4* mat, const double2* vec );


// double4x2
// Returns true if the all the components of the left-hand-side double4x2 match the other one, otherwise returns false.
inline bool double4x2_cmpe( const double4x2* lhs, const double4x2* rhs );

// Returns true if not all of the components of the left-hand-side double4x2 match the other one, otherwise returns false.
inline bool double4x2_cmpne( const double4x2* lhs, const double4x2* rhs );

// Returns a copy of the double4x2 that has been component-wise added by the given scalar value.
inline double4x2 double4x2_cadds( const double4x2* lhs, const double scalar );

// Returns a copy of the double4x2 that has been component-wise added by the corresponding component of the right-hand double4x2.
inline double4x2 double4x2_caddm( const double4x2* lhs, const double4x2* rhs );

// Returns a copy of the double4x2 that has been component-wise subtracted by the given scalar value.
inline double4x2 double4x2_csubs( const double4x2* lhs, const double scalar );

// Returns a copy of the double4x2 that has been component-wise subtracted by the corresponding component of the right-hand double4x2.
inline double4x2 double4x2_csubm( const double4x2* lhs, const double4x2* rhs );

// Returns a copy of the double4x2 that has been component-wise multiplied by the given scalar value.
inline double4x2 double4x2_cmuls( const double4x2* lhs, const double scalar );

// Returns a copy of the double4x2 that has been component-wise multiplied by the corresponding component of the right-hand double4x2.
inline double4x2 double4x2_cmulm( const double4x2* lhs, const double4x2* rhs );

// Returns a copy of the double4x2 that has been component-wise divided by the given scalar value.
inline double4x2 double4x2_cdivs( const double4x2* lhs, const double scalar );

// Returns a copy of the double4x2 that has been component-wise divided by the corresponding component of the right-hand double4x2.
inline double4x2 double4x2_cdivm( const double4x2* lhs, const double4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x2 double4x2_cmpl( const double4x2* lhs, const double4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x2 double4x2_cmple( const double4x2* lhs, const double4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x2 double4x2_cmpg( const double4x2* lhs, const double4x2* rhs );

// Returns a bool4x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x2 double4x2_cmpge( const double4x2* lhs, const double4x2* rhs );

// Sets the matrix to an identity matrix.
inline void double4x2_identity( double4x2* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double2x4 double4x2_transpose( const double4x2* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double4x4 double4x2_mulm( const double4x2* lhs, const double2x4* rhs );


// double4x3
// Returns true if the all the components of the left-hand-side double4x3 match the other one, otherwise returns false.
inline bool double4x3_cmpe( const double4x3* lhs, const double4x3* rhs );

// Returns true if not all of the components of the left-hand-side double4x3 match the other one, otherwise returns false.
inline bool double4x3_cmpne( const double4x3* lhs, const double4x3* rhs );

// Returns a copy of the double4x3 that has been component-wise added by the given scalar value.
inline double4x3 double4x3_cadds( const double4x3* lhs, const double scalar );

// Returns a copy of the double4x3 that has been component-wise added by the corresponding component of the right-hand double4x3.
inline double4x3 double4x3_caddm( const double4x3* lhs, const double4x3* rhs );

// Returns a copy of the double4x3 that has been component-wise subtracted by the given scalar value.
inline double4x3 double4x3_csubs( const double4x3* lhs, const double scalar );

// Returns a copy of the double4x3 that has been component-wise subtracted by the corresponding component of the right-hand double4x3.
inline double4x3 double4x3_csubm( const double4x3* lhs, const double4x3* rhs );

// Returns a copy of the double4x3 that has been component-wise multiplied by the given scalar value.
inline double4x3 double4x3_cmuls( const double4x3* lhs, const double scalar );

// Returns a copy of the double4x3 that has been component-wise multiplied by the corresponding component of the right-hand double4x3.
inline double4x3 double4x3_cmulm( const double4x3* lhs, const double4x3* rhs );

// Returns a copy of the double4x3 that has been component-wise divided by the given scalar value.
inline double4x3 double4x3_cdivs( const double4x3* lhs, const double scalar );

// Returns a copy of the double4x3 that has been component-wise divided by the corresponding component of the right-hand double4x3.
inline double4x3 double4x3_cdivm( const double4x3* lhs, const double4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x3 double4x3_cmpl( const double4x3* lhs, const double4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x3 double4x3_cmple( const double4x3* lhs, const double4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x3 double4x3_cmpg( const double4x3* lhs, const double4x3* rhs );

// Returns a bool4x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x3 double4x3_cmpge( const double4x3* lhs, const double4x3* rhs );

// Sets the matrix to an identity matrix.
inline void double4x3_identity( double4x3* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double3x4 double4x3_transpose( const double4x3* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double4x4 double4x3_mulm( const double4x3* lhs, const double3x4* rhs );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double4x3 double4x3_scale( const double4x3* mat, const double2* vec );


// double4x4
// Returns true if the all the components of the left-hand-side double4x4 match the other one, otherwise returns false.
inline bool double4x4_cmpe( const double4x4* lhs, const double4x4* rhs );

// Returns true if not all of the components of the left-hand-side double4x4 match the other one, otherwise returns false.
inline bool double4x4_cmpne( const double4x4* lhs, const double4x4* rhs );

// Returns a copy of the double4x4 that has been component-wise added by the given scalar value.
inline double4x4 double4x4_cadds( const double4x4* lhs, const double scalar );

// Returns a copy of the double4x4 that has been component-wise added by the corresponding component of the right-hand double4x4.
inline double4x4 double4x4_caddm( const double4x4* lhs, const double4x4* rhs );

// Returns a copy of the double4x4 that has been component-wise subtracted by the given scalar value.
inline double4x4 double4x4_csubs( const double4x4* lhs, const double scalar );

// Returns a copy of the double4x4 that has been component-wise subtracted by the corresponding component of the right-hand double4x4.
inline double4x4 double4x4_csubm( const double4x4* lhs, const double4x4* rhs );

// Returns a copy of the double4x4 that has been component-wise multiplied by the given scalar value.
inline double4x4 double4x4_cmuls( const double4x4* lhs, const double scalar );

// Returns a copy of the double4x4 that has been component-wise multiplied by the corresponding component of the right-hand double4x4.
inline double4x4 double4x4_cmulm( const double4x4* lhs, const double4x4* rhs );

// Returns a copy of the double4x4 that has been component-wise divided by the given scalar value.
inline double4x4 double4x4_cdivs( const double4x4* lhs, const double scalar );

// Returns a copy of the double4x4 that has been component-wise divided by the corresponding component of the right-hand double4x4.
inline double4x4 double4x4_cdivm( const double4x4* lhs, const double4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x4 double4x4_cmpl( const double4x4* lhs, const double4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x4 double4x4_cmple( const double4x4* lhs, const double4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x4 double4x4_cmpg( const double4x4* lhs, const double4x4* rhs );

// Returns a bool4x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x4 double4x4_cmpge( const double4x4* lhs, const double4x4* rhs );

// Sets the matrix to an identity matrix.
inline void double4x4_identity( double4x4* mat );

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double4x4 double4x4_transpose( const double4x4* mat );

// Returns the determinant of the matrix.
inline double double4x4_determinant( const double4x4* mat );

// Returns a copy of the matrix that is inversed.
// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline double4x4 double4x4_inverse( const double4x4* mat );

// Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double4x4 double4x4_mulm( const double4x4* lhs, const double4x4* rhs );

// Returns the right-hand vector multiplied by the left-hand matrix.
inline double4 double4x4_mulv( const double4x4* lhs, const double4* rhs );

// Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline double4x4 double4x4_translate( const double4x4* mat, const double3* vec );

// Returns a copy of the matrix that has had a rotation applied to it in radians on one or more of the following axes.
inline double4x4 double4x4_rotate( const double4x4* mat, const double rad, const double3* axis );

// Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double4x4 double4x4_scale( const double4x4* mat, const double3* vec );

// Returns an left-handed orthographic projection matrix with the clip-space range zero to one.
inline double4x4 double4x4_ortho_lh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar );

// Returns an left-handed orthographic projection matrix with the clip-space range minus-one to one.
inline double4x4 double4x4_ortho_lh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar );

// Returns an right-handed orthographic projection matrix with the clip-space range zero to one.
inline double4x4 double4x4_ortho_rh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar );

// Returns an right-handed orthographic projection matrix with the clip-space range minus-one to one.
inline double4x4 double4x4_ortho_rh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar );

// Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of zero to one.
inline double4x4 double4x4_perspective_lh_zo( const double fovdeg, const double aspect, const double znear, const double zfar );

// Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of minus-one to one.
inline double4x4 double4x4_perspective_lh_no( const double fovdeg, const double aspect, const double znear, const double zfar );

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of zero to one.
inline double4x4 double4x4_perspective_rh_zo( const double fovdeg, const double aspect, const double znear, const double zfar );

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of minus-one to one.
inline double4x4 double4x4_perspective_rh_no( const double fovdeg, const double aspect, const double znear, const double zfar );

// Returns a left-handed orthonormal matrix that is oriented at position eye to look at position target.
inline double4x4 double4x4_lookat_lh( const double3* eye, const double3* target, const double3* up );

// Returns a right-handed orthonormal matrix that is oriented at position eye to look at position target.
inline double4x4 double4x4_lookat_rh( const double3* eye, const double3* target, const double3* up );



#pragma once

// ignore missing brace initializers
#if defined( __GNUC__ ) || defined( __clang__ )
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmissing-braces"
#endif

bool bool2x2_all( const bool2x2* x )
{
	return x->rows[0].x && x->rows[0].y && x->rows[1].x && x->rows[1].y;
}

bool bool2x2_cmpe( const bool2x2* lhs, const bool2x2* rhs )
{
	return bool2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool2_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool bool2x2_cmpne( const bool2x2* lhs, const bool2x2* rhs )
{
	return !( bool2x2_cmpe( lhs, rhs ) );
}

void bool2x2_identity( bool2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat->rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
}

bool2x2 bool2x2_transpose( const bool2x2* mat )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

bool bool2x3_all( const bool2x3* x )
{
	return x->rows[0].x && x->rows[0].y && x->rows[0].z && x->rows[1].x && x->rows[1].y && x->rows[1].z;
}

bool bool2x3_cmpe( const bool2x3* lhs, const bool2x3* rhs )
{
	return bool3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool3_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool bool2x3_cmpne( const bool2x3* lhs, const bool2x3* rhs )
{
	return !( bool2x3_cmpe( lhs, rhs ) );
}

void bool2x3_identity( bool2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
}

bool3x2 bool2x3_transpose( const bool2x3* mat )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

bool bool2x4_all( const bool2x4* x )
{
	return x->rows[0].x && x->rows[0].y && x->rows[0].z && x->rows[0].w && x->rows[1].x && x->rows[1].y && x->rows[1].z && x->rows[1].w;
}

bool bool2x4_cmpe( const bool2x4* lhs, const bool2x4* rhs )
{
	return bool4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool4_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool bool2x4_cmpne( const bool2x4* lhs, const bool2x4* rhs )
{
	return !( bool2x4_cmpe( lhs, rhs ) );
}

void bool2x4_identity( bool2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
}

bool4x2 bool2x4_transpose( const bool2x4* mat )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

bool bool3x2_all( const bool3x2* x )
{
	return x->rows[0].x && x->rows[0].y && x->rows[1].x && x->rows[1].y && x->rows[2].x && x->rows[2].y;
}

bool bool3x2_cmpe( const bool3x2* lhs, const bool3x2* rhs )
{
	return bool2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& bool2_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool bool3x2_cmpne( const bool3x2* lhs, const bool3x2* rhs )
{
	return !( bool3x2_cmpe( lhs, rhs ) );
}

void bool3x2_identity( bool3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat->rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
	mat->rows[2] = HLML_CONSTRUCT( bool2 ) { false, false };
}

bool2x3 bool3x2_transpose( const bool3x2* mat )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

bool bool3x3_all( const bool3x3* x )
{
	return x->rows[0].x && x->rows[0].y && x->rows[0].z && x->rows[1].x && x->rows[1].y && x->rows[1].z && x->rows[2].x && x->rows[2].y && x->rows[2].z;
}

bool bool3x3_cmpe( const bool3x3* lhs, const bool3x3* rhs )
{
	return bool3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& bool3_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool bool3x3_cmpne( const bool3x3* lhs, const bool3x3* rhs )
{
	return !( bool3x3_cmpe( lhs, rhs ) );
}

void bool3x3_identity( bool3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
	mat->rows[2] = HLML_CONSTRUCT( bool3 ) { false, false, true };
}

bool3x3 bool3x3_transpose( const bool3x3* mat )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

bool bool3x4_all( const bool3x4* x )
{
	return x->rows[0].x && x->rows[0].y && x->rows[0].z && x->rows[0].w && x->rows[1].x && x->rows[1].y && x->rows[1].z && x->rows[1].w && x->rows[2].x && x->rows[2].y && x->rows[2].z && x->rows[2].w;
}

bool bool3x4_cmpe( const bool3x4* lhs, const bool3x4* rhs )
{
	return bool4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& bool4_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool bool3x4_cmpne( const bool3x4* lhs, const bool3x4* rhs )
{
	return !( bool3x4_cmpe( lhs, rhs ) );
}

void bool3x4_identity( bool3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
	mat->rows[2] = HLML_CONSTRUCT( bool4 ) { false, false, true, false };
}

bool4x3 bool3x4_transpose( const bool3x4* mat )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

bool bool4x2_all( const bool4x2* x )
{
	return x->rows[0].x && x->rows[0].y && x->rows[1].x && x->rows[1].y && x->rows[2].x && x->rows[2].y && x->rows[3].x && x->rows[3].y;
}

bool bool4x2_cmpe( const bool4x2* lhs, const bool4x2* rhs )
{
	return bool2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& bool2_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& bool2_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool bool4x2_cmpne( const bool4x2* lhs, const bool4x2* rhs )
{
	return !( bool4x2_cmpe( lhs, rhs ) );
}

void bool4x2_identity( bool4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat->rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
	mat->rows[2] = HLML_CONSTRUCT( bool2 ) { false, false };
	mat->rows[3] = HLML_CONSTRUCT( bool2 ) { false, false };
}

bool2x4 bool4x2_transpose( const bool4x2* mat )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

bool bool4x3_all( const bool4x3* x )
{
	return x->rows[0].x && x->rows[0].y && x->rows[0].z && x->rows[1].x && x->rows[1].y && x->rows[1].z && x->rows[2].x && x->rows[2].y && x->rows[2].z && x->rows[3].x && x->rows[3].y && x->rows[3].z;
}

bool bool4x3_cmpe( const bool4x3* lhs, const bool4x3* rhs )
{
	return bool3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& bool3_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& bool3_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool bool4x3_cmpne( const bool4x3* lhs, const bool4x3* rhs )
{
	return !( bool4x3_cmpe( lhs, rhs ) );
}

void bool4x3_identity( bool4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
	mat->rows[2] = HLML_CONSTRUCT( bool3 ) { false, false, true };
	mat->rows[3] = HLML_CONSTRUCT( bool3 ) { false, false, false };
}

bool3x4 bool4x3_transpose( const bool4x3* mat )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

bool bool4x4_all( const bool4x4* x )
{
	return x->rows[0].x && x->rows[0].y && x->rows[0].z && x->rows[0].w && x->rows[1].x && x->rows[1].y && x->rows[1].z && x->rows[1].w && x->rows[2].x && x->rows[2].y && x->rows[2].z && x->rows[2].w && x->rows[3].x && x->rows[3].y && x->rows[3].z && x->rows[3].w;
}

bool bool4x4_cmpe( const bool4x4* lhs, const bool4x4* rhs )
{
	return bool4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& bool4_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& bool4_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool bool4x4_cmpne( const bool4x4* lhs, const bool4x4* rhs )
{
	return !( bool4x4_cmpe( lhs, rhs ) );
}

void bool4x4_identity( bool4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
	mat->rows[2] = HLML_CONSTRUCT( bool4 ) { false, false, true, false };
	mat->rows[3] = HLML_CONSTRUCT( bool4 ) { false, false, false, true };
}

bool4x4 bool4x4_transpose( const bool4x4* mat )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

bool int2x2_cmpe( const int2x2* lhs, const int2x2* rhs )
{
	return int2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int2_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool int2x2_cmpne( const int2x2* lhs, const int2x2* rhs )
{
	return !( int2x2_cmpe( lhs, rhs ) );
}

int2x2 int2x2_cadds( const int2x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar
	};
}

int2x2 int2x2_caddm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int2_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_csubs( const int2x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar
	};
}

int2x2 int2x2_csubm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int2_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_cmuls( const int2x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar
	};
}

int2x2 int2x2_cmulm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_cdivs( const int2x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar
	};
}

int2x2 int2x2_cdivm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_cand( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_cand( &lhs->rows[0], &rhs->rows[0] ),
		int2_cand( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_cor( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_cor( &lhs->rows[0], &rhs->rows[0] ),
		int2_cor( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_cxor( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_cxor( &lhs->rows[0], &rhs->rows[0] ),
		int2_cxor( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_cunary( const int2x2* lhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,

		~lhs->rows[1].x,
		~lhs->rows[1].y

	};
}

int2x2 int2x2_cshift_left( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		int2_cshift_left( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_cshift_right( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		int2_cshift_right( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 int2x2_cmpl( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		int2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 int2x2_cmple( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		int2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 int2x2_cmpg( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		int2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 int2x2_cmpge( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		int2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void int2x2_identity( int2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
}

int2x2 int2x2_transpose( const int2x2* mat )
{
	return HLML_CONSTRUCT( int2x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

int32_t int2x2_determinant( const int2x2* mat )
{
	return mat->rows[0].x * mat->rows[1].y - mat->rows[1].x * mat->rows[0].y;
}

int2x2 int2x2_mulm( const int2x2* lhs, const int2x2* rhs )
{
	int2 row0 = lhs->rows[0];
	int2 row1 = lhs->rows[1];

	int2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	int2 col1 = { rhs->rows[0].y, rhs->rows[1].y };

	return HLML_CONSTRUCT( int2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

int2 int2x2_mulv( const int2x2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( int2 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y
	};
}

bool int2x3_cmpe( const int2x3* lhs, const int2x3* rhs )
{
	return int3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int3_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool int2x3_cmpne( const int2x3* lhs, const int2x3* rhs )
{
	return !( int2x3_cmpe( lhs, rhs ) );
}

int2x3 int2x3_cadds( const int2x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar
	};
}

int2x3 int2x3_caddm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int3_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_csubs( const int2x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar
	};
}

int2x3 int2x3_csubm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int3_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_cmuls( const int2x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar
	};
}

int2x3 int2x3_cmulm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_cdivs( const int2x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar
	};
}

int2x3 int2x3_cdivm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_cand( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_cand( &lhs->rows[0], &rhs->rows[0] ),
		int3_cand( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_cor( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_cor( &lhs->rows[0], &rhs->rows[0] ),
		int3_cor( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_cxor( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_cxor( &lhs->rows[0], &rhs->rows[0] ),
		int3_cxor( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_cunary( const int2x3* lhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z

	};
}

int2x3 int2x3_cshift_left( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		int3_cshift_left( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_cshift_right( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		int3_cshift_right( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 int2x3_cmpl( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		int3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 int2x3_cmple( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		int3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 int2x3_cmpg( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		int3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 int2x3_cmpge( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		int3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void int2x3_identity( int2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
}

int3x2 int2x3_transpose( const int2x3* mat )
{
	return HLML_CONSTRUCT( int3x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

int2x2 int2x3_mulm( const int2x3* lhs, const int3x2* rhs )
{
	int3 row0 = lhs->rows[0];
	int3 row1 = lhs->rows[1];

	int3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	int3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };

	return HLML_CONSTRUCT( int2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

int2x3 int2x3_scale( const int2x3* mat, const int2* vec )
{
	return HLML_CONSTRUCT( int2x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z
	};
}

bool int2x4_cmpe( const int2x4* lhs, const int2x4* rhs )
{
	return int4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int4_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool int2x4_cmpne( const int2x4* lhs, const int2x4* rhs )
{
	return !( int2x4_cmpe( lhs, rhs ) );
}

int2x4 int2x4_cadds( const int2x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar
	};
}

int2x4 int2x4_caddm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int4_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_csubs( const int2x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar
	};
}

int2x4 int2x4_csubm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int4_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_cmuls( const int2x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar
	};
}

int2x4 int2x4_cmulm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_cdivs( const int2x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar
	};
}

int2x4 int2x4_cdivm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_cand( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_cand( &lhs->rows[0], &rhs->rows[0] ),
		int4_cand( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_cor( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_cor( &lhs->rows[0], &rhs->rows[0] ),
		int4_cor( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_cxor( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_cxor( &lhs->rows[0], &rhs->rows[0] ),
		int4_cxor( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_cunary( const int2x4* lhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,
		~lhs->rows[0].w,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,
		~lhs->rows[1].w

	};
}

int2x4 int2x4_cshift_left( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		int4_cshift_left( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_cshift_right( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		int4_cshift_right( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 int2x4_cmpl( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		int4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 int2x4_cmple( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		int4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 int2x4_cmpg( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		int4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 int2x4_cmpge( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		int4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void int2x4_identity( int2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
}

int4x2 int2x4_transpose( const int2x4* mat )
{
	return HLML_CONSTRUCT( int4x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

int2x2 int2x4_mulm( const int2x4* lhs, const int4x2* rhs )
{
	int4 row0 = lhs->rows[0];
	int4 row1 = lhs->rows[1];

	int4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	int4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };

	return HLML_CONSTRUCT( int2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

int2x4 int2x4_scale( const int2x4* mat, const int2* vec )
{
	return HLML_CONSTRUCT( int2x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w
	};
}

bool int3x2_cmpe( const int3x2* lhs, const int3x2* rhs )
{
	return int2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& int2_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool int3x2_cmpne( const int3x2* lhs, const int3x2* rhs )
{
	return !( int3x2_cmpe( lhs, rhs ) );
}

int3x2 int3x2_cadds( const int3x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar
	};
}

int3x2 int3x2_caddm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		int2_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_csubs( const int3x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar
	};
}

int3x2 int3x2_csubm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		int2_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_cmuls( const int3x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar
	};
}

int3x2 int3x2_cmulm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_cdivs( const int3x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar
	};
}

int3x2 int3x2_cdivm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_cand( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_cand( &lhs->rows[0], &rhs->rows[0] ),
		int2_cand( &lhs->rows[1], &rhs->rows[1] ),
		int2_cand( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_cor( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_cor( &lhs->rows[0], &rhs->rows[0] ),
		int2_cor( &lhs->rows[1], &rhs->rows[1] ),
		int2_cor( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_cxor( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_cxor( &lhs->rows[0], &rhs->rows[0] ),
		int2_cxor( &lhs->rows[1], &rhs->rows[1] ),
		int2_cxor( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_cunary( const int3x2* lhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,

		~lhs->rows[1].x,
		~lhs->rows[1].y,

		~lhs->rows[2].x,
		~lhs->rows[2].y

	};
}

int3x2 int3x2_cshift_left( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		int2_cshift_left( &lhs->rows[1], &rhs->rows[1] ),
		int2_cshift_left( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_cshift_right( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		int2_cshift_right( &lhs->rows[1], &rhs->rows[1] ),
		int2_cshift_right( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 int3x2_cmpl( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		int2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 int3x2_cmple( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		int2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 int3x2_cmpg( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		int2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 int3x2_cmpge( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		int2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void int3x2_identity( int3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
	mat->rows[2] = HLML_CONSTRUCT( int2 ) { 0, 0 };
}

int2x3 int3x2_transpose( const int3x2* mat )
{
	return HLML_CONSTRUCT( int2x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

int3x3 int3x2_mulm( const int3x2* lhs, const int2x3* rhs )
{
	int2 row0 = lhs->rows[0];
	int2 row1 = lhs->rows[1];
	int2 row2 = lhs->rows[2];

	int2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	int2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	int2 col2 = { rhs->rows[0].z, rhs->rows[1].z };

	return HLML_CONSTRUCT( int3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

bool int3x3_cmpe( const int3x3* lhs, const int3x3* rhs )
{
	return int3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& int3_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool int3x3_cmpne( const int3x3* lhs, const int3x3* rhs )
{
	return !( int3x3_cmpe( lhs, rhs ) );
}

int3x3 int3x3_cadds( const int3x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar
	};
}

int3x3 int3x3_caddm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		int3_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_csubs( const int3x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar
	};
}

int3x3 int3x3_csubm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		int3_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_cmuls( const int3x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar
	};
}

int3x3 int3x3_cmulm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_cdivs( const int3x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar
	};
}

int3x3 int3x3_cdivm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_cand( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_cand( &lhs->rows[0], &rhs->rows[0] ),
		int3_cand( &lhs->rows[1], &rhs->rows[1] ),
		int3_cand( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_cor( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_cor( &lhs->rows[0], &rhs->rows[0] ),
		int3_cor( &lhs->rows[1], &rhs->rows[1] ),
		int3_cor( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_cxor( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_cxor( &lhs->rows[0], &rhs->rows[0] ),
		int3_cxor( &lhs->rows[1], &rhs->rows[1] ),
		int3_cxor( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_cunary( const int3x3* lhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z

	};
}

int3x3 int3x3_cshift_left( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		int3_cshift_left( &lhs->rows[1], &rhs->rows[1] ),
		int3_cshift_left( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_cshift_right( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		int3_cshift_right( &lhs->rows[1], &rhs->rows[1] ),
		int3_cshift_right( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 int3x3_cmpl( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		int3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 int3x3_cmple( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		int3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 int3x3_cmpg( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		int3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 int3x3_cmpge( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		int3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void int3x3_identity( int3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
	mat->rows[2] = HLML_CONSTRUCT( int3 ) { 0, 0, 1 };
}

int3x3 int3x3_transpose( const int3x3* mat )
{
	return HLML_CONSTRUCT( int3x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

int32_t int3x3_determinant( const int3x3* mat )
{
	return
		+ mat->rows[0].x * ( mat->rows[1].y * mat->rows[2].z - mat->rows[2].y * mat->rows[1].z ) 
		- mat->rows[0].y * ( mat->rows[1].x * mat->rows[2].z - mat->rows[2].x * mat->rows[1].z ) 
		+ mat->rows[0].z * ( mat->rows[1].x * mat->rows[2].y - mat->rows[2].x * mat->rows[1].y );
}

int3x3 int3x3_mulm( const int3x3* lhs, const int3x3* rhs )
{
	int3 row0 = lhs->rows[0];
	int3 row1 = lhs->rows[1];
	int3 row2 = lhs->rows[2];

	int3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	int3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	int3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };

	return HLML_CONSTRUCT( int3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

int3 int3x3_mulv( const int3x3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( int3 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z
	};
}

int3x3 int3x3_translate( const int3x3* mat, const int2* vec )
{
	return HLML_CONSTRUCT( int3x3 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z
	};
}

int3x3 int3x3_scale( const int3x3* mat, const int2* vec )
{
	return HLML_CONSTRUCT( int3x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z
	};
}

bool int3x4_cmpe( const int3x4* lhs, const int3x4* rhs )
{
	return int4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& int4_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool int3x4_cmpne( const int3x4* lhs, const int3x4* rhs )
{
	return !( int3x4_cmpe( lhs, rhs ) );
}

int3x4 int3x4_cadds( const int3x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar
	};
}

int3x4 int3x4_caddm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		int4_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_csubs( const int3x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar
	};
}

int3x4 int3x4_csubm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		int4_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_cmuls( const int3x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar
	};
}

int3x4 int3x4_cmulm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_cdivs( const int3x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar
	};
}

int3x4 int3x4_cdivm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_cand( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_cand( &lhs->rows[0], &rhs->rows[0] ),
		int4_cand( &lhs->rows[1], &rhs->rows[1] ),
		int4_cand( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_cor( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_cor( &lhs->rows[0], &rhs->rows[0] ),
		int4_cor( &lhs->rows[1], &rhs->rows[1] ),
		int4_cor( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_cxor( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_cxor( &lhs->rows[0], &rhs->rows[0] ),
		int4_cxor( &lhs->rows[1], &rhs->rows[1] ),
		int4_cxor( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_cunary( const int3x4* lhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,
		~lhs->rows[0].w,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,
		~lhs->rows[1].w,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z,
		~lhs->rows[2].w

	};
}

int3x4 int3x4_cshift_left( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		int4_cshift_left( &lhs->rows[1], &rhs->rows[1] ),
		int4_cshift_left( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_cshift_right( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		int4_cshift_right( &lhs->rows[1], &rhs->rows[1] ),
		int4_cshift_right( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 int3x4_cmpl( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		int4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 int3x4_cmple( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		int4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 int3x4_cmpg( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		int4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 int3x4_cmpge( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		int4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void int3x4_identity( int3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
	mat->rows[2] = HLML_CONSTRUCT( int4 ) { 0, 0, 1, 0 };
}

int4x3 int3x4_transpose( const int3x4* mat )
{
	return HLML_CONSTRUCT( int4x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

int3x3 int3x4_mulm( const int3x4* lhs, const int4x3* rhs )
{
	int4 row0 = lhs->rows[0];
	int4 row1 = lhs->rows[1];
	int4 row2 = lhs->rows[2];

	int4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	int4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	int4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };

	return HLML_CONSTRUCT( int3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

int3x4 int3x4_translate( const int3x4* mat, const int3* vec )
{
	return HLML_CONSTRUCT( int3x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z
	};
}

int3x4 int3x4_scale( const int3x4* mat, const int2* vec )
{
	return HLML_CONSTRUCT( int3x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,
		mat->rows[2].w
	};
}

bool int4x2_cmpe( const int4x2* lhs, const int4x2* rhs )
{
	return int2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& int2_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& int2_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool int4x2_cmpne( const int4x2* lhs, const int4x2* rhs )
{
	return !( int4x2_cmpe( lhs, rhs ) );
}

int4x2 int4x2_cadds( const int4x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar
	};
}

int4x2 int4x2_caddm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		int2_caddv( &lhs->rows[2], &rhs->rows[2] ),
		int2_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_csubs( const int4x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar
	};
}

int4x2 int4x2_csubm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		int2_csubv( &lhs->rows[2], &rhs->rows[2] ),
		int2_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_cmuls( const int4x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar
	};
}

int4x2 int4x2_cmulm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		int2_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_cdivs( const int4x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar
	};
}

int4x2 int4x2_cdivm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		int2_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		int2_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_cand( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_cand( &lhs->rows[0], &rhs->rows[0] ),
		int2_cand( &lhs->rows[1], &rhs->rows[1] ),
		int2_cand( &lhs->rows[2], &rhs->rows[2] ),
		int2_cand( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_cor( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_cor( &lhs->rows[0], &rhs->rows[0] ),
		int2_cor( &lhs->rows[1], &rhs->rows[1] ),
		int2_cor( &lhs->rows[2], &rhs->rows[2] ),
		int2_cor( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_cxor( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_cxor( &lhs->rows[0], &rhs->rows[0] ),
		int2_cxor( &lhs->rows[1], &rhs->rows[1] ),
		int2_cxor( &lhs->rows[2], &rhs->rows[2] ),
		int2_cxor( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_cunary( const int4x2* lhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,

		~lhs->rows[1].x,
		~lhs->rows[1].y,

		~lhs->rows[2].x,
		~lhs->rows[2].y,

		~lhs->rows[3].x,
		~lhs->rows[3].y

	};
}

int4x2 int4x2_cshift_left( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		int2_cshift_left( &lhs->rows[1], &rhs->rows[1] ),
		int2_cshift_left( &lhs->rows[2], &rhs->rows[2] ),
		int2_cshift_left( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_cshift_right( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		int2_cshift_right( &lhs->rows[1], &rhs->rows[1] ),
		int2_cshift_right( &lhs->rows[2], &rhs->rows[2] ),
		int2_cshift_right( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 int4x2_cmpl( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		int2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		int2_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 int4x2_cmple( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		int2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmple( &lhs->rows[2], &rhs->rows[2] ),
		int2_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 int4x2_cmpg( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		int2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		int2_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 int4x2_cmpge( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		int2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		int2_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void int4x2_identity( int4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
	mat->rows[2] = HLML_CONSTRUCT( int2 ) { 0, 0 };
	mat->rows[3] = HLML_CONSTRUCT( int2 ) { 0, 0 };
}

int2x4 int4x2_transpose( const int4x2* mat )
{
	return HLML_CONSTRUCT( int2x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

int4x4 int4x2_mulm( const int4x2* lhs, const int2x4* rhs )
{
	int2 row0 = lhs->rows[0];
	int2 row1 = lhs->rows[1];
	int2 row2 = lhs->rows[2];
	int2 row3 = lhs->rows[3];

	int2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	int2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	int2 col2 = { rhs->rows[0].z, rhs->rows[1].z };
	int2 col3 = { rhs->rows[0].w, rhs->rows[1].w };

	return HLML_CONSTRUCT( int4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

bool int4x3_cmpe( const int4x3* lhs, const int4x3* rhs )
{
	return int3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& int3_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& int3_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool int4x3_cmpne( const int4x3* lhs, const int4x3* rhs )
{
	return !( int4x3_cmpe( lhs, rhs ) );
}

int4x3 int4x3_cadds( const int4x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar
	};
}

int4x3 int4x3_caddm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		int3_caddv( &lhs->rows[2], &rhs->rows[2] ),
		int3_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_csubs( const int4x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar
	};
}

int4x3 int4x3_csubm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		int3_csubv( &lhs->rows[2], &rhs->rows[2] ),
		int3_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_cmuls( const int4x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar
	};
}

int4x3 int4x3_cmulm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		int3_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_cdivs( const int4x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar
	};
}

int4x3 int4x3_cdivm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		int3_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		int3_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_cand( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_cand( &lhs->rows[0], &rhs->rows[0] ),
		int3_cand( &lhs->rows[1], &rhs->rows[1] ),
		int3_cand( &lhs->rows[2], &rhs->rows[2] ),
		int3_cand( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_cor( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_cor( &lhs->rows[0], &rhs->rows[0] ),
		int3_cor( &lhs->rows[1], &rhs->rows[1] ),
		int3_cor( &lhs->rows[2], &rhs->rows[2] ),
		int3_cor( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_cxor( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_cxor( &lhs->rows[0], &rhs->rows[0] ),
		int3_cxor( &lhs->rows[1], &rhs->rows[1] ),
		int3_cxor( &lhs->rows[2], &rhs->rows[2] ),
		int3_cxor( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_cunary( const int4x3* lhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z,

		~lhs->rows[3].x,
		~lhs->rows[3].y,
		~lhs->rows[3].z

	};
}

int4x3 int4x3_cshift_left( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		int3_cshift_left( &lhs->rows[1], &rhs->rows[1] ),
		int3_cshift_left( &lhs->rows[2], &rhs->rows[2] ),
		int3_cshift_left( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_cshift_right( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		int3_cshift_right( &lhs->rows[1], &rhs->rows[1] ),
		int3_cshift_right( &lhs->rows[2], &rhs->rows[2] ),
		int3_cshift_right( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 int4x3_cmpl( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		int3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		int3_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 int4x3_cmple( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		int3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmple( &lhs->rows[2], &rhs->rows[2] ),
		int3_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 int4x3_cmpg( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		int3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		int3_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 int4x3_cmpge( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		int3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		int3_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void int4x3_identity( int4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
	mat->rows[2] = HLML_CONSTRUCT( int3 ) { 0, 0, 1 };
	mat->rows[3] = HLML_CONSTRUCT( int3 ) { 0, 0, 0 };
}

int3x4 int4x3_transpose( const int4x3* mat )
{
	return HLML_CONSTRUCT( int3x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

int4x4 int4x3_mulm( const int4x3* lhs, const int3x4* rhs )
{
	int3 row0 = lhs->rows[0];
	int3 row1 = lhs->rows[1];
	int3 row2 = lhs->rows[2];
	int3 row3 = lhs->rows[3];

	int3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	int3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	int3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };
	int3 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w };

	return HLML_CONSTRUCT( int4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

int4x3 int4x3_scale( const int4x3* mat, const int2* vec )
{
	return HLML_CONSTRUCT( int4x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z
	};
}

bool int4x4_cmpe( const int4x4* lhs, const int4x4* rhs )
{
	return int4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& int4_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& int4_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool int4x4_cmpne( const int4x4* lhs, const int4x4* rhs )
{
	return !( int4x4_cmpe( lhs, rhs ) );
}

int4x4 int4x4_cadds( const int4x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar, lhs->rows[3].w + scalar
	};
}

int4x4 int4x4_caddm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		int4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		int4_caddv( &lhs->rows[2], &rhs->rows[2] ),
		int4_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_csubs( const int4x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar, lhs->rows[3].w - scalar
	};
}

int4x4 int4x4_csubm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		int4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		int4_csubv( &lhs->rows[2], &rhs->rows[2] ),
		int4_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_cmuls( const int4x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar, lhs->rows[3].w * scalar
	};
}

int4x4 int4x4_cmulm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		int4_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_cdivs( const int4x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar, lhs->rows[3].w / scalar
	};
}

int4x4 int4x4_cdivm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		int4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		int4_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		int4_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_cand( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_cand( &lhs->rows[0], &rhs->rows[0] ),
		int4_cand( &lhs->rows[1], &rhs->rows[1] ),
		int4_cand( &lhs->rows[2], &rhs->rows[2] ),
		int4_cand( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_cor( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_cor( &lhs->rows[0], &rhs->rows[0] ),
		int4_cor( &lhs->rows[1], &rhs->rows[1] ),
		int4_cor( &lhs->rows[2], &rhs->rows[2] ),
		int4_cor( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_cxor( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_cxor( &lhs->rows[0], &rhs->rows[0] ),
		int4_cxor( &lhs->rows[1], &rhs->rows[1] ),
		int4_cxor( &lhs->rows[2], &rhs->rows[2] ),
		int4_cxor( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_cunary( const int4x4* lhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,
		~lhs->rows[0].w,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,
		~lhs->rows[1].w,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z,
		~lhs->rows[2].w,

		~lhs->rows[3].x,
		~lhs->rows[3].y,
		~lhs->rows[3].z,
		~lhs->rows[3].w

	};
}

int4x4 int4x4_cshift_left( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		int4_cshift_left( &lhs->rows[1], &rhs->rows[1] ),
		int4_cshift_left( &lhs->rows[2], &rhs->rows[2] ),
		int4_cshift_left( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_cshift_right( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		int4_cshift_right( &lhs->rows[1], &rhs->rows[1] ),
		int4_cshift_right( &lhs->rows[2], &rhs->rows[2] ),
		int4_cshift_right( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 int4x4_cmpl( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		int4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		int4_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 int4x4_cmple( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		int4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmple( &lhs->rows[2], &rhs->rows[2] ),
		int4_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 int4x4_cmpg( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		int4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		int4_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 int4x4_cmpge( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		int4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		int4_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void int4x4_identity( int4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
	mat->rows[2] = HLML_CONSTRUCT( int4 ) { 0, 0, 1, 0 };
	mat->rows[3] = HLML_CONSTRUCT( int4 ) { 0, 0, 0, 1 };
}

int4x4 int4x4_transpose( const int4x4* mat )
{
	return HLML_CONSTRUCT( int4x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

int32_t int4x4_determinant( const int4x4* mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	int32_t sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	int32_t sub01 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	int32_t sub02 = mat->rows[2].y * mat->rows[3].z - mat->rows[3].y * mat->rows[2].z;
	int32_t sub03 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	int32_t sub04 = mat->rows[2].x * mat->rows[3].z - mat->rows[3].x * mat->rows[2].z;
	int32_t sub05 = mat->rows[2].x * mat->rows[3].y - mat->rows[3].x * mat->rows[2].y;

	int4 cofactor = HLML_CONSTRUCT( int4 ) {
		 ( ( ( mat->rows[1].y * sub00 ) - ( mat->rows[1].z * sub01 ) ) + ( mat->rows[1].w * sub02 ) ),
		-( ( ( mat->rows[1].x * sub00 ) - ( mat->rows[1].z * sub03 ) ) + ( mat->rows[1].w * sub04 ) ),
		 ( ( ( mat->rows[1].x * sub01 ) - ( mat->rows[1].y * sub03 ) ) + ( mat->rows[1].w * sub05 ) ),
		-( ( ( mat->rows[1].x * sub02 ) - ( mat->rows[1].y * sub04 ) ) + ( mat->rows[1].z * sub05 ) ) 
	};

	return
		mat->rows[0].x * cofactor.x + mat->rows[0].y * cofactor.y +
		mat->rows[0].z * cofactor.z + mat->rows[0].w * cofactor.w; 
}

int4x4 int4x4_mulm( const int4x4* lhs, const int4x4* rhs )
{
	int4 row0 = lhs->rows[0];
	int4 row1 = lhs->rows[1];
	int4 row2 = lhs->rows[2];
	int4 row3 = lhs->rows[3];

	int4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	int4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	int4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };
	int4 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w, rhs->rows[3].w };

	return HLML_CONSTRUCT( int4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

int4 int4x4_mulv( const int4x4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( int4 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z + lhs->rows[0].w * rhs->w,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z + lhs->rows[1].w * rhs->w,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z + lhs->rows[2].w * rhs->w,
		lhs->rows[3].x * rhs->x + lhs->rows[3].y * rhs->y + lhs->rows[3].z * rhs->z + lhs->rows[3].w * rhs->w
	};
}

int4x4 int4x4_translate( const int4x4* mat, const int3* vec )
{
	return HLML_CONSTRUCT( int4x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z,
		mat->rows[3].x, mat->rows[3].y, mat->rows[3].z, mat->rows[3].w
	};
}

int4x4 int4x4_scale( const int4x4* mat, const int3* vec )
{
	return HLML_CONSTRUCT( int4x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z * vec->z,
		mat->rows[2].w,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z,
		mat->rows[3].w
	};
}

bool uint2x2_cmpe( const uint2x2* lhs, const uint2x2* rhs )
{
	return uint2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint2_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool uint2x2_cmpne( const uint2x2* lhs, const uint2x2* rhs )
{
	return !( uint2x2_cmpe( lhs, rhs ) );
}

uint2x2 uint2x2_cadds( const uint2x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar
	};
}

uint2x2 uint2x2_caddm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_csubs( const uint2x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar
	};
}

uint2x2 uint2x2_csubm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_cmuls( const uint2x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar
	};
}

uint2x2 uint2x2_cmulm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_cdivs( const uint2x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar
	};
}

uint2x2 uint2x2_cdivm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_cand( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_cand( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cand( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_cor( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_cor( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cor( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_cxor( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_cxor( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cxor( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_cunary( const uint2x2* lhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,

		~lhs->rows[1].x,
		~lhs->rows[1].y

	};
}

uint2x2 uint2x2_cshift_left( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cshift_left( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_cshift_right( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cshift_right( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 uint2x2_cmpl( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		uint2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 uint2x2_cmple( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		uint2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 uint2x2_cmpg( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		uint2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 uint2x2_cmpge( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		uint2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void uint2x2_identity( uint2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
}

uint2x2 uint2x2_transpose( const uint2x2* mat )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

uint2x2 uint2x2_mulm( const uint2x2* lhs, const uint2x2* rhs )
{
	uint2 row0 = lhs->rows[0];
	uint2 row1 = lhs->rows[1];

	uint2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	uint2 col1 = { rhs->rows[0].y, rhs->rows[1].y };

	return HLML_CONSTRUCT( uint2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

uint2 uint2x2_mulv( const uint2x2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( uint2 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y
	};
}

bool uint2x3_cmpe( const uint2x3* lhs, const uint2x3* rhs )
{
	return uint3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint3_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool uint2x3_cmpne( const uint2x3* lhs, const uint2x3* rhs )
{
	return !( uint2x3_cmpe( lhs, rhs ) );
}

uint2x3 uint2x3_cadds( const uint2x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar
	};
}

uint2x3 uint2x3_caddm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_csubs( const uint2x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar
	};
}

uint2x3 uint2x3_csubm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_cmuls( const uint2x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar
	};
}

uint2x3 uint2x3_cmulm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_cdivs( const uint2x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar
	};
}

uint2x3 uint2x3_cdivm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_cand( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_cand( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cand( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_cor( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_cor( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cor( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_cxor( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_cxor( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cxor( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_cunary( const uint2x3* lhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z

	};
}

uint2x3 uint2x3_cshift_left( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cshift_left( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_cshift_right( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cshift_right( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 uint2x3_cmpl( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		uint3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 uint2x3_cmple( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		uint3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 uint2x3_cmpg( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		uint3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 uint2x3_cmpge( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		uint3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void uint2x3_identity( uint2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
}

uint3x2 uint2x3_transpose( const uint2x3* mat )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

uint2x2 uint2x3_mulm( const uint2x3* lhs, const uint3x2* rhs )
{
	uint3 row0 = lhs->rows[0];
	uint3 row1 = lhs->rows[1];

	uint3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	uint3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };

	return HLML_CONSTRUCT( uint2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

uint2x3 uint2x3_scale( const uint2x3* mat, const uint2* vec )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z
	};
}

bool uint2x4_cmpe( const uint2x4* lhs, const uint2x4* rhs )
{
	return uint4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint4_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool uint2x4_cmpne( const uint2x4* lhs, const uint2x4* rhs )
{
	return !( uint2x4_cmpe( lhs, rhs ) );
}

uint2x4 uint2x4_cadds( const uint2x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar
	};
}

uint2x4 uint2x4_caddm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_csubs( const uint2x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar
	};
}

uint2x4 uint2x4_csubm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_cmuls( const uint2x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar
	};
}

uint2x4 uint2x4_cmulm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_cdivs( const uint2x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar
	};
}

uint2x4 uint2x4_cdivm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_cand( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_cand( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cand( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_cor( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_cor( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cor( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_cxor( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_cxor( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cxor( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_cunary( const uint2x4* lhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,
		~lhs->rows[0].w,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,
		~lhs->rows[1].w

	};
}

uint2x4 uint2x4_cshift_left( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cshift_left( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_cshift_right( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cshift_right( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 uint2x4_cmpl( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		uint4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 uint2x4_cmple( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		uint4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 uint2x4_cmpg( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		uint4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 uint2x4_cmpge( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		uint4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void uint2x4_identity( uint2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
}

uint4x2 uint2x4_transpose( const uint2x4* mat )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

uint2x2 uint2x4_mulm( const uint2x4* lhs, const uint4x2* rhs )
{
	uint4 row0 = lhs->rows[0];
	uint4 row1 = lhs->rows[1];

	uint4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	uint4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };

	return HLML_CONSTRUCT( uint2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

uint2x4 uint2x4_scale( const uint2x4* mat, const uint2* vec )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w
	};
}

bool uint3x2_cmpe( const uint3x2* lhs, const uint3x2* rhs )
{
	return uint2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& uint2_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool uint3x2_cmpne( const uint3x2* lhs, const uint3x2* rhs )
{
	return !( uint3x2_cmpe( lhs, rhs ) );
}

uint3x2 uint3x2_cadds( const uint3x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar
	};
}

uint3x2 uint3x2_caddm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_csubs( const uint3x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar
	};
}

uint3x2 uint3x2_csubm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_cmuls( const uint3x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar
	};
}

uint3x2 uint3x2_cmulm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_cdivs( const uint3x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar
	};
}

uint3x2 uint3x2_cdivm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_cand( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_cand( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cand( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cand( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_cor( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_cor( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cor( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cor( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_cxor( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_cxor( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cxor( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cxor( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_cunary( const uint3x2* lhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,

		~lhs->rows[1].x,
		~lhs->rows[1].y,

		~lhs->rows[2].x,
		~lhs->rows[2].y

	};
}

uint3x2 uint3x2_cshift_left( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cshift_left( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cshift_left( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_cshift_right( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cshift_right( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cshift_right( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 uint3x2_cmpl( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		uint2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 uint3x2_cmple( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		uint2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 uint3x2_cmpg( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		uint2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 uint3x2_cmpge( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		uint2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void uint3x2_identity( uint3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
	mat->rows[2] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
}

uint2x3 uint3x2_transpose( const uint3x2* mat )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

uint3x3 uint3x2_mulm( const uint3x2* lhs, const uint2x3* rhs )
{
	uint2 row0 = lhs->rows[0];
	uint2 row1 = lhs->rows[1];
	uint2 row2 = lhs->rows[2];

	uint2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	uint2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	uint2 col2 = { rhs->rows[0].z, rhs->rows[1].z };

	return HLML_CONSTRUCT( uint3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

bool uint3x3_cmpe( const uint3x3* lhs, const uint3x3* rhs )
{
	return uint3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& uint3_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool uint3x3_cmpne( const uint3x3* lhs, const uint3x3* rhs )
{
	return !( uint3x3_cmpe( lhs, rhs ) );
}

uint3x3 uint3x3_cadds( const uint3x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar
	};
}

uint3x3 uint3x3_caddm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_csubs( const uint3x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar
	};
}

uint3x3 uint3x3_csubm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_cmuls( const uint3x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar
	};
}

uint3x3 uint3x3_cmulm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_cdivs( const uint3x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar
	};
}

uint3x3 uint3x3_cdivm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_cand( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_cand( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cand( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cand( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_cor( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_cor( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cor( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cor( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_cxor( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_cxor( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cxor( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cxor( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_cunary( const uint3x3* lhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z

	};
}

uint3x3 uint3x3_cshift_left( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cshift_left( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cshift_left( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_cshift_right( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cshift_right( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cshift_right( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 uint3x3_cmpl( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		uint3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 uint3x3_cmple( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		uint3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 uint3x3_cmpg( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		uint3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 uint3x3_cmpge( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		uint3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void uint3x3_identity( uint3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
	mat->rows[2] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 1U };
}

uint3x3 uint3x3_transpose( const uint3x3* mat )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

uint3x3 uint3x3_mulm( const uint3x3* lhs, const uint3x3* rhs )
{
	uint3 row0 = lhs->rows[0];
	uint3 row1 = lhs->rows[1];
	uint3 row2 = lhs->rows[2];

	uint3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	uint3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	uint3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };

	return HLML_CONSTRUCT( uint3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

uint3 uint3x3_mulv( const uint3x3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( uint3 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z
	};
}

uint3x3 uint3x3_translate( const uint3x3* mat, const uint2* vec )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z
	};
}

uint3x3 uint3x3_scale( const uint3x3* mat, const uint2* vec )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z
	};
}

bool uint3x4_cmpe( const uint3x4* lhs, const uint3x4* rhs )
{
	return uint4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& uint4_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool uint3x4_cmpne( const uint3x4* lhs, const uint3x4* rhs )
{
	return !( uint3x4_cmpe( lhs, rhs ) );
}

uint3x4 uint3x4_cadds( const uint3x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar
	};
}

uint3x4 uint3x4_caddm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_csubs( const uint3x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar
	};
}

uint3x4 uint3x4_csubm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_cmuls( const uint3x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar
	};
}

uint3x4 uint3x4_cmulm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_cdivs( const uint3x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar
	};
}

uint3x4 uint3x4_cdivm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_cand( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_cand( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cand( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cand( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_cor( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_cor( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cor( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cor( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_cxor( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_cxor( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cxor( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cxor( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_cunary( const uint3x4* lhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,
		~lhs->rows[0].w,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,
		~lhs->rows[1].w,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z,
		~lhs->rows[2].w

	};
}

uint3x4 uint3x4_cshift_left( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cshift_left( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cshift_left( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_cshift_right( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cshift_right( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cshift_right( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 uint3x4_cmpl( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		uint4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 uint3x4_cmple( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		uint4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 uint3x4_cmpg( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		uint4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 uint3x4_cmpge( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		uint4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void uint3x4_identity( uint3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
	mat->rows[2] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 1U, 0U };
}

uint4x3 uint3x4_transpose( const uint3x4* mat )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

uint3x3 uint3x4_mulm( const uint3x4* lhs, const uint4x3* rhs )
{
	uint4 row0 = lhs->rows[0];
	uint4 row1 = lhs->rows[1];
	uint4 row2 = lhs->rows[2];

	uint4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	uint4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	uint4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };

	return HLML_CONSTRUCT( uint3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

uint3x4 uint3x4_translate( const uint3x4* mat, const uint3* vec )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z
	};
}

uint3x4 uint3x4_scale( const uint3x4* mat, const uint2* vec )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,
		mat->rows[2].w
	};
}

bool uint4x2_cmpe( const uint4x2* lhs, const uint4x2* rhs )
{
	return uint2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& uint2_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& uint2_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool uint4x2_cmpne( const uint4x2* lhs, const uint4x2* rhs )
{
	return !( uint4x2_cmpe( lhs, rhs ) );
}

uint4x2 uint4x2_cadds( const uint4x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar
	};
}

uint4x2 uint4x2_caddm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_caddv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_csubs( const uint4x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar
	};
}

uint4x2 uint4x2_csubm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_csubv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_cmuls( const uint4x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar
	};
}

uint4x2 uint4x2_cmulm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_cdivs( const uint4x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar
	};
}

uint4x2 uint4x2_cdivm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_cand( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_cand( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cand( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cand( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cand( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_cor( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_cor( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cor( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cor( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cor( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_cxor( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_cxor( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cxor( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cxor( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cxor( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_cunary( const uint4x2* lhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,

		~lhs->rows[1].x,
		~lhs->rows[1].y,

		~lhs->rows[2].x,
		~lhs->rows[2].y,

		~lhs->rows[3].x,
		~lhs->rows[3].y

	};
}

uint4x2 uint4x2_cshift_left( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cshift_left( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cshift_left( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cshift_left( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_cshift_right( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cshift_right( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cshift_right( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cshift_right( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 uint4x2_cmpl( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		uint2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 uint4x2_cmple( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		uint2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmple( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 uint4x2_cmpg( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		uint2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 uint4x2_cmpge( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		uint2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void uint4x2_identity( uint4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
	mat->rows[2] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
	mat->rows[3] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
}

uint2x4 uint4x2_transpose( const uint4x2* mat )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

uint4x4 uint4x2_mulm( const uint4x2* lhs, const uint2x4* rhs )
{
	uint2 row0 = lhs->rows[0];
	uint2 row1 = lhs->rows[1];
	uint2 row2 = lhs->rows[2];
	uint2 row3 = lhs->rows[3];

	uint2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	uint2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	uint2 col2 = { rhs->rows[0].z, rhs->rows[1].z };
	uint2 col3 = { rhs->rows[0].w, rhs->rows[1].w };

	return HLML_CONSTRUCT( uint4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

bool uint4x3_cmpe( const uint4x3* lhs, const uint4x3* rhs )
{
	return uint3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& uint3_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& uint3_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool uint4x3_cmpne( const uint4x3* lhs, const uint4x3* rhs )
{
	return !( uint4x3_cmpe( lhs, rhs ) );
}

uint4x3 uint4x3_cadds( const uint4x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar
	};
}

uint4x3 uint4x3_caddm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_caddv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_csubs( const uint4x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar
	};
}

uint4x3 uint4x3_csubm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_csubv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_cmuls( const uint4x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar
	};
}

uint4x3 uint4x3_cmulm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_cdivs( const uint4x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar
	};
}

uint4x3 uint4x3_cdivm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_cand( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_cand( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cand( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cand( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cand( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_cor( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_cor( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cor( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cor( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cor( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_cxor( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_cxor( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cxor( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cxor( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cxor( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_cunary( const uint4x3* lhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z,

		~lhs->rows[3].x,
		~lhs->rows[3].y,
		~lhs->rows[3].z

	};
}

uint4x3 uint4x3_cshift_left( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cshift_left( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cshift_left( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cshift_left( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_cshift_right( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cshift_right( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cshift_right( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cshift_right( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 uint4x3_cmpl( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		uint3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 uint4x3_cmple( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		uint3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmple( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 uint4x3_cmpg( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		uint3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 uint4x3_cmpge( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		uint3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void uint4x3_identity( uint4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
	mat->rows[2] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 1U };
	mat->rows[3] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 0U };
}

uint3x4 uint4x3_transpose( const uint4x3* mat )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

uint4x4 uint4x3_mulm( const uint4x3* lhs, const uint3x4* rhs )
{
	uint3 row0 = lhs->rows[0];
	uint3 row1 = lhs->rows[1];
	uint3 row2 = lhs->rows[2];
	uint3 row3 = lhs->rows[3];

	uint3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	uint3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	uint3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };
	uint3 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w };

	return HLML_CONSTRUCT( uint4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

uint4x3 uint4x3_scale( const uint4x3* mat, const uint2* vec )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z
	};
}

bool uint4x4_cmpe( const uint4x4* lhs, const uint4x4* rhs )
{
	return uint4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& uint4_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& uint4_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool uint4x4_cmpne( const uint4x4* lhs, const uint4x4* rhs )
{
	return !( uint4x4_cmpe( lhs, rhs ) );
}

uint4x4 uint4x4_cadds( const uint4x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar, lhs->rows[3].w + scalar
	};
}

uint4x4 uint4x4_caddm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_caddv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_csubs( const uint4x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar, lhs->rows[3].w - scalar
	};
}

uint4x4 uint4x4_csubm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_csubv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_cmuls( const uint4x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar, lhs->rows[3].w * scalar
	};
}

uint4x4 uint4x4_cmulm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_cdivs( const uint4x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar, lhs->rows[3].w / scalar
	};
}

uint4x4 uint4x4_cdivm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_cand( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_cand( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cand( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cand( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cand( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_cor( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_cor( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cor( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cor( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cor( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_cxor( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_cxor( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cxor( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cxor( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cxor( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_cunary( const uint4x4* lhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,
		~lhs->rows[0].w,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,
		~lhs->rows[1].w,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z,
		~lhs->rows[2].w,

		~lhs->rows[3].x,
		~lhs->rows[3].y,
		~lhs->rows[3].z,
		~lhs->rows[3].w

	};
}

uint4x4 uint4x4_cshift_left( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_cshift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cshift_left( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cshift_left( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cshift_left( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_cshift_right( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_cshift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cshift_right( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cshift_right( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cshift_right( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 uint4x4_cmpl( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		uint4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 uint4x4_cmple( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		uint4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmple( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 uint4x4_cmpg( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		uint4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 uint4x4_cmpge( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		uint4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void uint4x4_identity( uint4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
	mat->rows[2] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 1U, 0U };
	mat->rows[3] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 0U, 1U };
}

uint4x4 uint4x4_transpose( const uint4x4* mat )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

uint4x4 uint4x4_mulm( const uint4x4* lhs, const uint4x4* rhs )
{
	uint4 row0 = lhs->rows[0];
	uint4 row1 = lhs->rows[1];
	uint4 row2 = lhs->rows[2];
	uint4 row3 = lhs->rows[3];

	uint4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	uint4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	uint4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };
	uint4 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w, rhs->rows[3].w };

	return HLML_CONSTRUCT( uint4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

uint4 uint4x4_mulv( const uint4x4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( uint4 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z + lhs->rows[0].w * rhs->w,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z + lhs->rows[1].w * rhs->w,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z + lhs->rows[2].w * rhs->w,
		lhs->rows[3].x * rhs->x + lhs->rows[3].y * rhs->y + lhs->rows[3].z * rhs->z + lhs->rows[3].w * rhs->w
	};
}

uint4x4 uint4x4_translate( const uint4x4* mat, const uint3* vec )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z,
		mat->rows[3].x, mat->rows[3].y, mat->rows[3].z, mat->rows[3].w
	};
}

uint4x4 uint4x4_scale( const uint4x4* mat, const uint3* vec )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z * vec->z,
		mat->rows[2].w,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z,
		mat->rows[3].w
	};
}

bool float2x2_cmpe( const float2x2* lhs, const float2x2* rhs )
{
	return float2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float2_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool float2x2_cmpne( const float2x2* lhs, const float2x2* rhs )
{
	return !( float2x2_cmpe( lhs, rhs ) );
}

float2x2 float2x2_cadds( const float2x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar
	};
}

float2x2 float2x2_caddm( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		float2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float2_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x2 float2x2_csubs( const float2x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar
	};
}

float2x2 float2x2_csubm( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		float2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float2_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x2 float2x2_cmuls( const float2x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar
	};
}

float2x2 float2x2_cmulm( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		float2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x2 float2x2_cdivs( const float2x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar
	};
}

float2x2 float2x2_cdivm( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		float2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float2_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 float2x2_cmpl( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		float2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 float2x2_cmple( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		float2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 float2x2_cmpg( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		float2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 float2x2_cmpge( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		float2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void float2x2_identity( float2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
}

float2x2 float2x2_transpose( const float2x2* mat )
{
	return HLML_CONSTRUCT( float2x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

float float2x2_determinant( const float2x2* mat )
{
	return mat->rows[0].x * mat->rows[1].y - mat->rows[1].x * mat->rows[0].y;
}

float2x2 float2x2_inverse( const float2x2* mat )
{
	const float invdet = 1.0f / float2x2_determinant( mat );
	return HLML_CONSTRUCT( float2x2 ) {
		 mat->rows[1].y * invdet, -mat->rows[0].y * invdet,
		-mat->rows[1].x * invdet,  mat->rows[0].x * invdet
	};
}

float2x2 float2x2_mulm( const float2x2* lhs, const float2x2* rhs )
{
	float2 row0 = lhs->rows[0];
	float2 row1 = lhs->rows[1];

	float2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	float2 col1 = { rhs->rows[0].y, rhs->rows[1].y };

	return HLML_CONSTRUCT( float2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

float2 float2x2_mulv( const float2x2* lhs, const float2* rhs )
{
	return HLML_CONSTRUCT( float2 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y
	};
}

bool float2x3_cmpe( const float2x3* lhs, const float2x3* rhs )
{
	return float3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float3_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool float2x3_cmpne( const float2x3* lhs, const float2x3* rhs )
{
	return !( float2x3_cmpe( lhs, rhs ) );
}

float2x3 float2x3_cadds( const float2x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar
	};
}

float2x3 float2x3_caddm( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		float3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float3_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x3 float2x3_csubs( const float2x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar
	};
}

float2x3 float2x3_csubm( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		float3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float3_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x3 float2x3_cmuls( const float2x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar
	};
}

float2x3 float2x3_cmulm( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		float3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x3 float2x3_cdivs( const float2x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar
	};
}

float2x3 float2x3_cdivm( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		float3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float3_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 float2x3_cmpl( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		float3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 float2x3_cmple( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		float3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 float2x3_cmpg( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		float3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 float2x3_cmpge( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		float3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void float2x3_identity( float2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
}

float3x2 float2x3_transpose( const float2x3* mat )
{
	return HLML_CONSTRUCT( float3x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

float2x2 float2x3_mulm( const float2x3* lhs, const float3x2* rhs )
{
	float3 row0 = lhs->rows[0];
	float3 row1 = lhs->rows[1];

	float3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	float3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };

	return HLML_CONSTRUCT( float2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

float2x3 float2x3_scale( const float2x3* mat, const float2* vec )
{
	return HLML_CONSTRUCT( float2x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z
	};
}

bool float2x4_cmpe( const float2x4* lhs, const float2x4* rhs )
{
	return float4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float4_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool float2x4_cmpne( const float2x4* lhs, const float2x4* rhs )
{
	return !( float2x4_cmpe( lhs, rhs ) );
}

float2x4 float2x4_cadds( const float2x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar
	};
}

float2x4 float2x4_caddm( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		float4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float4_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x4 float2x4_csubs( const float2x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar
	};
}

float2x4 float2x4_csubm( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		float4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float4_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x4 float2x4_cmuls( const float2x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar
	};
}

float2x4 float2x4_cmulm( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		float4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x4 float2x4_cdivs( const float2x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar
	};
}

float2x4 float2x4_cdivm( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		float4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float4_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 float2x4_cmpl( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		float4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 float2x4_cmple( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		float4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 float2x4_cmpg( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		float4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 float2x4_cmpge( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		float4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void float2x4_identity( float2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
}

float4x2 float2x4_transpose( const float2x4* mat )
{
	return HLML_CONSTRUCT( float4x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

float2x2 float2x4_mulm( const float2x4* lhs, const float4x2* rhs )
{
	float4 row0 = lhs->rows[0];
	float4 row1 = lhs->rows[1];

	float4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	float4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };

	return HLML_CONSTRUCT( float2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

float2x4 float2x4_scale( const float2x4* mat, const float2* vec )
{
	return HLML_CONSTRUCT( float2x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w
	};
}

bool float3x2_cmpe( const float3x2* lhs, const float3x2* rhs )
{
	return float2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& float2_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool float3x2_cmpne( const float3x2* lhs, const float3x2* rhs )
{
	return !( float3x2_cmpe( lhs, rhs ) );
}

float3x2 float3x2_cadds( const float3x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar
	};
}

float3x2 float3x2_caddm( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		float2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		float2_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x2 float3x2_csubs( const float3x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar
	};
}

float3x2 float3x2_csubm( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		float2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		float2_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x2 float3x2_cmuls( const float3x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar
	};
}

float3x2 float3x2_cmulm( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		float2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x2 float3x2_cdivs( const float3x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar
	};
}

float3x2 float3x2_cdivm( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		float2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		float2_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 float3x2_cmpl( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		float2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 float3x2_cmple( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		float2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 float3x2_cmpg( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		float2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 float3x2_cmpge( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		float2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void float3x2_identity( float3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
	mat->rows[2] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
}

float2x3 float3x2_transpose( const float3x2* mat )
{
	return HLML_CONSTRUCT( float2x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

float3x3 float3x2_mulm( const float3x2* lhs, const float2x3* rhs )
{
	float2 row0 = lhs->rows[0];
	float2 row1 = lhs->rows[1];
	float2 row2 = lhs->rows[2];

	float2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	float2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	float2 col2 = { rhs->rows[0].z, rhs->rows[1].z };

	return HLML_CONSTRUCT( float3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

bool float3x3_cmpe( const float3x3* lhs, const float3x3* rhs )
{
	return float3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& float3_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool float3x3_cmpne( const float3x3* lhs, const float3x3* rhs )
{
	return !( float3x3_cmpe( lhs, rhs ) );
}

float3x3 float3x3_cadds( const float3x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar
	};
}

float3x3 float3x3_caddm( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		float3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		float3_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x3 float3x3_csubs( const float3x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar
	};
}

float3x3 float3x3_csubm( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		float3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		float3_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x3 float3x3_cmuls( const float3x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar
	};
}

float3x3 float3x3_cmulm( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		float3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x3 float3x3_cdivs( const float3x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar
	};
}

float3x3 float3x3_cdivm( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		float3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		float3_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 float3x3_cmpl( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		float3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 float3x3_cmple( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		float3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 float3x3_cmpg( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		float3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 float3x3_cmpge( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		float3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void float3x3_identity( float3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
	mat->rows[2] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 1.0f };
}

float3x3 float3x3_transpose( const float3x3* mat )
{
	return HLML_CONSTRUCT( float3x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

float float3x3_determinant( const float3x3* mat )
{
	return
		+ mat->rows[0].x * ( mat->rows[1].y * mat->rows[2].z - mat->rows[2].y * mat->rows[1].z ) 
		- mat->rows[0].y * ( mat->rows[1].x * mat->rows[2].z - mat->rows[2].x * mat->rows[1].z ) 
		+ mat->rows[0].z * ( mat->rows[1].x * mat->rows[2].y - mat->rows[2].x * mat->rows[1].y );
}

float3x3 float3x3_inverse( const float3x3* mat )
{
	const float invdet = 1.0f / float3x3_determinant( mat );
	return HLML_CONSTRUCT( float3x3 ) {
		 ( mat->rows[1].y * mat->rows[2].z - mat->rows[1].z * mat->rows[2].y ) * invdet,
		-( mat->rows[0].y * mat->rows[2].z - mat->rows[0].z * mat->rows[2].y ) * invdet,
		 ( mat->rows[0].y * mat->rows[1].z - mat->rows[0].z * mat->rows[1].y ) * invdet,

		-( mat->rows[1].x * mat->rows[2].z - mat->rows[1].z * mat->rows[2].x ) * invdet,
		 ( mat->rows[0].x * mat->rows[2].z - mat->rows[0].z * mat->rows[2].x ) * invdet,
		-( mat->rows[0].x * mat->rows[1].z - mat->rows[0].z * mat->rows[1].x ) * invdet,

		 ( mat->rows[1].x * mat->rows[2].y - mat->rows[1].y * mat->rows[2].x ) * invdet,
		-( mat->rows[0].x * mat->rows[2].y - mat->rows[0].y * mat->rows[2].x ) * invdet,
		 ( mat->rows[0].x * mat->rows[1].y - mat->rows[0].y * mat->rows[1].x ) * invdet
	};
}

float3x3 float3x3_mulm( const float3x3* lhs, const float3x3* rhs )
{
	float3 row0 = lhs->rows[0];
	float3 row1 = lhs->rows[1];
	float3 row2 = lhs->rows[2];

	float3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	float3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	float3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };

	return HLML_CONSTRUCT( float3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

float3 float3x3_mulv( const float3x3* lhs, const float3* rhs )
{
	return HLML_CONSTRUCT( float3 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z
	};
}

float3x3 float3x3_translate( const float3x3* mat, const float2* vec )
{
	return HLML_CONSTRUCT( float3x3 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z
	};
}

float3x3 float3x3_rotate( const float3x3* mat, const float rad )
{
	const float c = cosf( rad );
	const float s = sinf( rad );

	float3 row0_cos  = float3_cmuls( &mat->rows[0], c );
	float3 row0_sin  = float3_cmuls( &mat->rows[0], s );
	float3 row1_nsin = float3_cmuls( &mat->rows[1], -s );
	float3 row1_cos  = float3_cmuls( &mat->rows[1], c );

	return HLML_CONSTRUCT( float3x3 ) {
		float3_caddv( &row0_cos, &row1_nsin ),
		float3_caddv( &row0_sin, &row1_cos  ),
		mat->rows[2]
	};
}

float3x3 float3x3_scale( const float3x3* mat, const float2* vec )
{
	return HLML_CONSTRUCT( float3x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z
	};
}

bool float3x4_cmpe( const float3x4* lhs, const float3x4* rhs )
{
	return float4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& float4_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool float3x4_cmpne( const float3x4* lhs, const float3x4* rhs )
{
	return !( float3x4_cmpe( lhs, rhs ) );
}

float3x4 float3x4_cadds( const float3x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar
	};
}

float3x4 float3x4_caddm( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		float4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		float4_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x4 float3x4_csubs( const float3x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar
	};
}

float3x4 float3x4_csubm( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		float4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		float4_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x4 float3x4_cmuls( const float3x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar
	};
}

float3x4 float3x4_cmulm( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		float4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x4 float3x4_cdivs( const float3x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar
	};
}

float3x4 float3x4_cdivm( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		float4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		float4_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 float3x4_cmpl( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		float4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 float3x4_cmple( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		float4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 float3x4_cmpg( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		float4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 float3x4_cmpge( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		float4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void float3x4_identity( float3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
	mat->rows[2] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 1.0f, 0.0f };
}

float4x3 float3x4_transpose( const float3x4* mat )
{
	return HLML_CONSTRUCT( float4x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

float3x3 float3x4_mulm( const float3x4* lhs, const float4x3* rhs )
{
	float4 row0 = lhs->rows[0];
	float4 row1 = lhs->rows[1];
	float4 row2 = lhs->rows[2];

	float4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	float4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	float4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };

	return HLML_CONSTRUCT( float3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

float3x4 float3x4_translate( const float3x4* mat, const float3* vec )
{
	return HLML_CONSTRUCT( float3x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z
	};
}

float3x4 float3x4_scale( const float3x4* mat, const float2* vec )
{
	return HLML_CONSTRUCT( float3x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,
		mat->rows[2].w
	};
}

bool float4x2_cmpe( const float4x2* lhs, const float4x2* rhs )
{
	return float2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& float2_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& float2_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool float4x2_cmpne( const float4x2* lhs, const float4x2* rhs )
{
	return !( float4x2_cmpe( lhs, rhs ) );
}

float4x2 float4x2_cadds( const float4x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar
	};
}

float4x2 float4x2_caddm( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		float2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		float2_caddv( &lhs->rows[2], &rhs->rows[2] ),
		float2_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x2 float4x2_csubs( const float4x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar
	};
}

float4x2 float4x2_csubm( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		float2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		float2_csubv( &lhs->rows[2], &rhs->rows[2] ),
		float2_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x2 float4x2_cmuls( const float4x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar
	};
}

float4x2 float4x2_cmulm( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		float2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		float2_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x2 float4x2_cdivs( const float4x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar
	};
}

float4x2 float4x2_cdivm( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		float2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		float2_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		float2_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 float4x2_cmpl( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		float2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		float2_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 float4x2_cmple( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		float2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmple( &lhs->rows[2], &rhs->rows[2] ),
		float2_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 float4x2_cmpg( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		float2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		float2_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 float4x2_cmpge( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		float2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		float2_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void float4x2_identity( float4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
	mat->rows[2] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
	mat->rows[3] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
}

float2x4 float4x2_transpose( const float4x2* mat )
{
	return HLML_CONSTRUCT( float2x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

float4x4 float4x2_mulm( const float4x2* lhs, const float2x4* rhs )
{
	float2 row0 = lhs->rows[0];
	float2 row1 = lhs->rows[1];
	float2 row2 = lhs->rows[2];
	float2 row3 = lhs->rows[3];

	float2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	float2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	float2 col2 = { rhs->rows[0].z, rhs->rows[1].z };
	float2 col3 = { rhs->rows[0].w, rhs->rows[1].w };

	return HLML_CONSTRUCT( float4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

bool float4x3_cmpe( const float4x3* lhs, const float4x3* rhs )
{
	return float3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& float3_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& float3_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool float4x3_cmpne( const float4x3* lhs, const float4x3* rhs )
{
	return !( float4x3_cmpe( lhs, rhs ) );
}

float4x3 float4x3_cadds( const float4x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar
	};
}

float4x3 float4x3_caddm( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		float3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		float3_caddv( &lhs->rows[2], &rhs->rows[2] ),
		float3_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x3 float4x3_csubs( const float4x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar
	};
}

float4x3 float4x3_csubm( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		float3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		float3_csubv( &lhs->rows[2], &rhs->rows[2] ),
		float3_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x3 float4x3_cmuls( const float4x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar
	};
}

float4x3 float4x3_cmulm( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		float3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		float3_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x3 float4x3_cdivs( const float4x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar
	};
}

float4x3 float4x3_cdivm( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		float3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		float3_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		float3_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 float4x3_cmpl( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		float3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		float3_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 float4x3_cmple( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		float3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmple( &lhs->rows[2], &rhs->rows[2] ),
		float3_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 float4x3_cmpg( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		float3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		float3_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 float4x3_cmpge( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		float3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		float3_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void float4x3_identity( float4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
	mat->rows[2] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 1.0f };
	mat->rows[3] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 0.0f };
}

float3x4 float4x3_transpose( const float4x3* mat )
{
	return HLML_CONSTRUCT( float3x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

float4x4 float4x3_mulm( const float4x3* lhs, const float3x4* rhs )
{
	float3 row0 = lhs->rows[0];
	float3 row1 = lhs->rows[1];
	float3 row2 = lhs->rows[2];
	float3 row3 = lhs->rows[3];

	float3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	float3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	float3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };
	float3 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w };

	return HLML_CONSTRUCT( float4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

float4x3 float4x3_scale( const float4x3* mat, const float2* vec )
{
	return HLML_CONSTRUCT( float4x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z
	};
}

bool float4x4_cmpe( const float4x4* lhs, const float4x4* rhs )
{
	return float4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& float4_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& float4_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool float4x4_cmpne( const float4x4* lhs, const float4x4* rhs )
{
	return !( float4x4_cmpe( lhs, rhs ) );
}

float4x4 float4x4_cadds( const float4x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar, lhs->rows[3].w + scalar
	};
}

float4x4 float4x4_caddm( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		float4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		float4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		float4_caddv( &lhs->rows[2], &rhs->rows[2] ),
		float4_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x4 float4x4_csubs( const float4x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar, lhs->rows[3].w - scalar
	};
}

float4x4 float4x4_csubm( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		float4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		float4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		float4_csubv( &lhs->rows[2], &rhs->rows[2] ),
		float4_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x4 float4x4_cmuls( const float4x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar, lhs->rows[3].w * scalar
	};
}

float4x4 float4x4_cmulm( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		float4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		float4_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x4 float4x4_cdivs( const float4x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar, lhs->rows[3].w / scalar
	};
}

float4x4 float4x4_cdivm( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		float4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		float4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		float4_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		float4_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 float4x4_cmpl( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		float4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		float4_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 float4x4_cmple( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		float4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmple( &lhs->rows[2], &rhs->rows[2] ),
		float4_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 float4x4_cmpg( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		float4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		float4_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 float4x4_cmpge( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		float4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		float4_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void float4x4_identity( float4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
	mat->rows[2] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 1.0f, 0.0f };
	mat->rows[3] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 0.0f, 1.0f };
}

float4x4 float4x4_transpose( const float4x4* mat )
{
	return HLML_CONSTRUCT( float4x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

float float4x4_determinant( const float4x4* mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	float sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	float sub01 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	float sub02 = mat->rows[2].y * mat->rows[3].z - mat->rows[3].y * mat->rows[2].z;
	float sub03 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	float sub04 = mat->rows[2].x * mat->rows[3].z - mat->rows[3].x * mat->rows[2].z;
	float sub05 = mat->rows[2].x * mat->rows[3].y - mat->rows[3].x * mat->rows[2].y;

	float4 cofactor = HLML_CONSTRUCT( float4 ) {
		 ( ( ( mat->rows[1].y * sub00 ) - ( mat->rows[1].z * sub01 ) ) + ( mat->rows[1].w * sub02 ) ),
		-( ( ( mat->rows[1].x * sub00 ) - ( mat->rows[1].z * sub03 ) ) + ( mat->rows[1].w * sub04 ) ),
		 ( ( ( mat->rows[1].x * sub01 ) - ( mat->rows[1].y * sub03 ) ) + ( mat->rows[1].w * sub05 ) ),
		-( ( ( mat->rows[1].x * sub02 ) - ( mat->rows[1].y * sub04 ) ) + ( mat->rows[1].z * sub05 ) ) 
	};

	return
		mat->rows[0].x * cofactor.x + mat->rows[0].y * cofactor.y +
		mat->rows[0].z * cofactor.z + mat->rows[0].w * cofactor.w; 
}

float4x4 float4x4_inverse( const float4x4* mat )
{
	// uses the glm version, which is basically just an optimised version of the adjugate formula
	float sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	float sub01 = mat->rows[1].z * mat->rows[3].w - mat->rows[1].w * mat->rows[2].w;
	float sub02 = mat->rows[1].z * mat->rows[2].w - mat->rows[1].w * mat->rows[2].z;

	float sub03 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	float sub04 = mat->rows[1].y * mat->rows[3].w - mat->rows[1].w * mat->rows[3].y;
	float sub05 = mat->rows[1].y * mat->rows[2].w - mat->rows[1].w * mat->rows[2].y;

	float sub06 = mat->rows[2].y * mat->rows[3].z - mat->rows[2].z * mat->rows[3].y;
	float sub07 = mat->rows[1].y * mat->rows[3].z - mat->rows[1].z * mat->rows[3].y;
	float sub08 = mat->rows[1].y * mat->rows[2].z - mat->rows[1].z * mat->rows[2].y;

	float sub09 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	float sub10 = mat->rows[1].x * mat->rows[3].w - mat->rows[3].x * mat->rows[1].w;
	float sub11 = mat->rows[1].x * mat->rows[2].w - mat->rows[2].x * mat->rows[1].w;

	float sub12 = mat->rows[2].x * mat->rows[3].z - mat->rows[2].z * mat->rows[3].x;
	float sub13 = mat->rows[1].x * mat->rows[3].z - mat->rows[1].z * mat->rows[3].x;
	float sub14 = mat->rows[1].x * mat->rows[2].z - mat->rows[1].z * mat->rows[2].x;

	float sub15 = mat->rows[2].x * mat->rows[3].y - mat->rows[2].y * mat->rows[3].x;
	float sub16 = mat->rows[1].x * mat->rows[3].y - mat->rows[1].y * mat->rows[3].x;
	float sub17 = mat->rows[1].x * mat->rows[2].y - mat->rows[1].y * mat->rows[2].x;

	float4 fac0 = (float4) { sub00, sub00, sub01, sub02 };
	float4 fac1 = (float4) { sub03, sub03, sub04, sub05 };
	float4 fac2 = (float4) { sub06, sub06, sub07, sub08 };
	float4 fac3 = (float4) { sub09, sub09, sub10, sub11 };
	float4 fac4 = (float4) { sub12, sub12, sub13, sub14 };
	float4 fac5 = (float4) { sub15, sub15, sub16, sub17 };

	float4 vec0 = (float4) { mat->rows[1].x, mat->rows[0].x, mat->rows[0].x, mat->rows[0].x };
	float4 vec1 = (float4) { mat->rows[1].y, mat->rows[0].y, mat->rows[0].y, mat->rows[0].y };
	float4 vec2 = (float4) { mat->rows[1].z, mat->rows[0].z, mat->rows[0].z, mat->rows[0].z };
	float4 vec3 = (float4) { mat->rows[1].w, mat->rows[0].w, mat->rows[0].w, mat->rows[0].w };

	float4 inv0mula = float4_cmulv( &vec1, &fac0 );
	float4 inv0mulb = float4_cmulv( &vec2, &fac1 );
	float4 inv0mulc = float4_cmulv( &vec3, &fac2 );
	float4 inv0     = float4_csubv( &inv0mula, &inv0mulb );
	inv0 = float4_caddv( &inv0, &inv0mulc );

	float4 inv1mula = float4_cmulv( &vec0, &fac0 );
	float4 inv1mulb = float4_cmulv( &vec2, &fac3 );
	float4 inv1mulc = float4_cmulv( &vec3, &fac4 );
	float4 inv1     = float4_csubv( &inv1mula, &inv1mulb );
	inv1 = float4_caddv( &inv1, &inv1mulc );

	float4 inv2mula = float4_cmulv( &vec0, &fac1 );
	float4 inv2mulb = float4_cmulv( &vec1, &fac3 );
	float4 inv2mulc = float4_cmulv( &vec3, &fac5 );
	float4 inv2     = float4_csubv( &inv2mula, &inv2mulb );
	inv2 = float4_caddv( &inv2, &inv2mulc );

	float4 inv3mula = float4_cmulv( &vec0, &fac2 );
	float4 inv3mulb = float4_cmulv( &vec1, &fac4 );
	float4 inv3mulc = float4_cmulv( &vec2, &fac5 );
	float4 inv3     = float4_csubv( &inv3mula, &inv3mulb );
	inv3 = float4_caddv( &inv3, &inv3mulc );


	float4 sign0 = (float4) {  1, -1,  1, -1 };
	float4 sign1 = (float4) { -1,  1, -1,  1 };

	float4x4 result = (float4x4) {
		float4_cmulv( &inv0, &sign0 ),
		float4_cmulv( &inv1, &sign1 ),
		float4_cmulv( &inv2, &sign0 ),
		float4_cmulv( &inv3, &sign1 )
	};

	float4 col0 = (float4) { result.rows[0].x, result.rows[1].x, result.rows[2].x, result.rows[3].x };
	float4 dot0 = float4_cmulv( &mat->rows[0], &col0 );

	const float dot1 = ( dot0.x + dot0.y ) + ( dot0.z + dot0.w );

	const float invdet = 1.0f / dot1;

	return float4x4_cmuls( &result, invdet );
}

float4x4 float4x4_mulm( const float4x4* lhs, const float4x4* rhs )
{
	float4 row0 = lhs->rows[0];
	float4 row1 = lhs->rows[1];
	float4 row2 = lhs->rows[2];
	float4 row3 = lhs->rows[3];

	float4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	float4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	float4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };
	float4 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w, rhs->rows[3].w };

	return HLML_CONSTRUCT( float4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

float4 float4x4_mulv( const float4x4* lhs, const float4* rhs )
{
	return HLML_CONSTRUCT( float4 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z + lhs->rows[0].w * rhs->w,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z + lhs->rows[1].w * rhs->w,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z + lhs->rows[2].w * rhs->w,
		lhs->rows[3].x * rhs->x + lhs->rows[3].y * rhs->y + lhs->rows[3].z * rhs->z + lhs->rows[3].w * rhs->w
	};
}

float4x4 float4x4_translate( const float4x4* mat, const float3* vec )
{
	return HLML_CONSTRUCT( float4x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z,
		mat->rows[3].x, mat->rows[3].y, mat->rows[3].z, mat->rows[3].w
	};
}

float4x4 float4x4_rotate( const float4x4* mat, const float rad, const float3* axis )
{
	const float c = cosf( rad );
	const float s = sinf( rad );

	float3 u = float3_normalized( axis );
	float ic = 1.0f - c;

	float4x4 rotation = *mat;
	rotation.rows[0].x = c + u.x * ic;
	rotation.rows[0].y = u.x * u.y * ic - u.z * s;
	rotation.rows[0].z = u.x * u.z * ic + u.y * s;

	rotation.rows[1].x = u.y * u.x * ic + u.z * s;
	rotation.rows[1].y = c + u.y * ic;
	rotation.rows[1].z = u.y * u.z * ic - u.x * s;

	rotation.rows[2].x = u.z * u.x * ic - u.y * s;
	rotation.rows[2].y = u.z * u.y * ic + u.x * s;
	rotation.rows[2].z = c + u.z * ic;

	return float4x4_mulm( mat, &rotation );
}

float4x4 float4x4_scale( const float4x4* mat, const float3* vec )
{
	return HLML_CONSTRUCT( float4x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z * vec->z,
		mat->rows[2].w,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z,
		mat->rows[3].w
	};
}

float4x4 float4x4_ortho_lh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// left-handed, clip-space range: zero to one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( float4x4 ) {
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, 1.0f / far_minus_near, -znear / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 float4x4_ortho_lh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// left-handed, clip-space range: minus-one to one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( float4x4 ) {
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, 2.0f / far_minus_near, -far_plus_near / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 float4x4_ortho_rh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// right-handed, clip-space range: zero to one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( float4x4 ) {
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, -1.0f / far_minus_near, -znear / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 float4x4_ortho_rh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// right-handed, clip-space range: minus-one to one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( float4x4 ) {
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, -2.0f / far_minus_near, -far_plus_near / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 float4x4_perspective_lh_zo( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// left-handed, clip space range: zero to one
	const float far_minus_near = zfar - znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 ) {
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, zfar / far_minus_near, -( zfar * znear ) / far_minus_near,
		0.0f, 0.0f, 1.0f, 0.0f
	};
}

float4x4 float4x4_perspective_lh_no( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// left-handed, clip space range: minus-one to one
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 ) {
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, far_plus_near / far_minus_near, -( 2.0f * zfar * znear ) / far_minus_near,
		0.0f, 0.0f, 1.0f, 0.0f
	};
}

float4x4 float4x4_perspective_rh_zo( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// right-handed, clip space range: zero to one
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 ) {
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, zfar / ( znear - zfar ), -( zfar * znear ) / ( zfar - znear ),
		0.0f, 0.0f, -1.0f, 0.0f
	};
}

float4x4 float4x4_perspective_rh_no( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// right-handed, clip space range: minus-one to one
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 ) {
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, -far_plus_near / far_minus_near, -( 2.0f * zfar * znear ) / far_minus_near,
		0.0f, 0.0f, -1.0f, 0.0f
	};
}

float4x4 float4x4_lookat_lh( const float3* eye, const float3* target, const float3* up )
{
	// left handed
	const float3 eye_to_target = float3_csubv( target, eye );
	const float3 forward = float3_normalized( &eye_to_target );
	const float3 up_cross_forward = float3_cross( up, &forward );
	const float3 right = float3_normalized( &up_cross_forward );
	const float3 up1 = float3_cross( &forward, &right );

	return HLML_CONSTRUCT( float4x4 ) {
		right.x,   right.y,   right.z,   -float3_dot( &right, eye ),
		up1.x,     up1.y,     up1.z,     -float3_dot( &up1, eye ),
		forward.x, forward.y, forward.z, -float3_dot( &forward, eye ),
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 float4x4_lookat_rh( const float3* eye, const float3* target, const float3* up )
{
	// right handed
	const float3 eye_to_target = float3_csubv( target, eye );
	const float3 forward = float3_normalized( &eye_to_target );
	const float3 forward_cross_up = float3_cross( &forward, up );
	const float3 right = float3_normalized( &forward_cross_up );
	const float3 up1 = float3_cross( &right, &forward );

	return HLML_CONSTRUCT( float4x4 ) {
		 right.x,    right.y,    right.z,   -float3_dot( &right, eye ),
		 up1.x,      up1.y,      up1.z,     -float3_dot( &up1, eye ),
		-forward.x, -forward.y, -forward.z,  float3_dot( &forward, eye ),
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

bool double2x2_cmpe( const double2x2* lhs, const double2x2* rhs )
{
	return double2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double2_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool double2x2_cmpne( const double2x2* lhs, const double2x2* rhs )
{
	return !( double2x2_cmpe( lhs, rhs ) );
}

double2x2 double2x2_cadds( const double2x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar
	};
}

double2x2 double2x2_caddm( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		double2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double2_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x2 double2x2_csubs( const double2x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar
	};
}

double2x2 double2x2_csubm( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		double2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double2_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x2 double2x2_cmuls( const double2x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar
	};
}

double2x2 double2x2_cmulm( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		double2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x2 double2x2_cdivs( const double2x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar
	};
}

double2x2 double2x2_cdivm( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		double2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double2_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 double2x2_cmpl( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		double2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 double2x2_cmple( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		double2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 double2x2_cmpg( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		double2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 double2x2_cmpge( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		double2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void double2x2_identity( double2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
}

double2x2 double2x2_transpose( const double2x2* mat )
{
	return HLML_CONSTRUCT( double2x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

double double2x2_determinant( const double2x2* mat )
{
	return mat->rows[0].x * mat->rows[1].y - mat->rows[1].x * mat->rows[0].y;
}

double2x2 double2x2_inverse( const double2x2* mat )
{
	const double invdet = 1.0 / double2x2_determinant( mat );
	return HLML_CONSTRUCT( double2x2 ) {
		 mat->rows[1].y * invdet, -mat->rows[0].y * invdet,
		-mat->rows[1].x * invdet,  mat->rows[0].x * invdet
	};
}

double2x2 double2x2_mulm( const double2x2* lhs, const double2x2* rhs )
{
	double2 row0 = lhs->rows[0];
	double2 row1 = lhs->rows[1];

	double2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	double2 col1 = { rhs->rows[0].y, rhs->rows[1].y };

	return HLML_CONSTRUCT( double2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

double2 double2x2_mulv( const double2x2* lhs, const double2* rhs )
{
	return HLML_CONSTRUCT( double2 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y
	};
}

bool double2x3_cmpe( const double2x3* lhs, const double2x3* rhs )
{
	return double3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double3_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool double2x3_cmpne( const double2x3* lhs, const double2x3* rhs )
{
	return !( double2x3_cmpe( lhs, rhs ) );
}

double2x3 double2x3_cadds( const double2x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar
	};
}

double2x3 double2x3_caddm( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		double3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double3_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x3 double2x3_csubs( const double2x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar
	};
}

double2x3 double2x3_csubm( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		double3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double3_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x3 double2x3_cmuls( const double2x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar
	};
}

double2x3 double2x3_cmulm( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		double3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x3 double2x3_cdivs( const double2x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar
	};
}

double2x3 double2x3_cdivm( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		double3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double3_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 double2x3_cmpl( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		double3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 double2x3_cmple( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		double3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 double2x3_cmpg( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		double3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 double2x3_cmpge( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		double3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void double2x3_identity( double2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
}

double3x2 double2x3_transpose( const double2x3* mat )
{
	return HLML_CONSTRUCT( double3x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

double2x2 double2x3_mulm( const double2x3* lhs, const double3x2* rhs )
{
	double3 row0 = lhs->rows[0];
	double3 row1 = lhs->rows[1];

	double3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	double3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };

	return HLML_CONSTRUCT( double2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

double2x3 double2x3_scale( const double2x3* mat, const double2* vec )
{
	return HLML_CONSTRUCT( double2x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z
	};
}

bool double2x4_cmpe( const double2x4* lhs, const double2x4* rhs )
{
	return double4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double4_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool double2x4_cmpne( const double2x4* lhs, const double2x4* rhs )
{
	return !( double2x4_cmpe( lhs, rhs ) );
}

double2x4 double2x4_cadds( const double2x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar
	};
}

double2x4 double2x4_caddm( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		double4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double4_caddv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x4 double2x4_csubs( const double2x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar
	};
}

double2x4 double2x4_csubm( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		double4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double4_csubv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x4 double2x4_cmuls( const double2x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar
	};
}

double2x4 double2x4_cmulm( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		double4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x4 double2x4_cdivs( const double2x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar
	};
}

double2x4 double2x4_cdivm( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		double4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double4_cdivv( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 double2x4_cmpl( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		double4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 double2x4_cmple( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		double4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 double2x4_cmpg( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		double4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 double2x4_cmpge( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		double4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void double2x4_identity( double2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
}

double4x2 double2x4_transpose( const double2x4* mat )
{
	return HLML_CONSTRUCT( double4x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

double2x2 double2x4_mulm( const double2x4* lhs, const double4x2* rhs )
{
	double4 row0 = lhs->rows[0];
	double4 row1 = lhs->rows[1];

	double4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	double4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };

	return HLML_CONSTRUCT( double2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

double2x4 double2x4_scale( const double2x4* mat, const double2* vec )
{
	return HLML_CONSTRUCT( double2x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w
	};
}

bool double3x2_cmpe( const double3x2* lhs, const double3x2* rhs )
{
	return double2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& double2_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool double3x2_cmpne( const double3x2* lhs, const double3x2* rhs )
{
	return !( double3x2_cmpe( lhs, rhs ) );
}

double3x2 double3x2_cadds( const double3x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar
	};
}

double3x2 double3x2_caddm( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		double2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		double2_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x2 double3x2_csubs( const double3x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar
	};
}

double3x2 double3x2_csubm( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		double2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		double2_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x2 double3x2_cmuls( const double3x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar
	};
}

double3x2 double3x2_cmulm( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		double2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x2 double3x2_cdivs( const double3x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar
	};
}

double3x2 double3x2_cdivm( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		double2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		double2_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 double3x2_cmpl( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		double2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 double3x2_cmple( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		double2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 double3x2_cmpg( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		double2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 double3x2_cmpge( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		double2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void double3x2_identity( double3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
	mat->rows[2] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
}

double2x3 double3x2_transpose( const double3x2* mat )
{
	return HLML_CONSTRUCT( double2x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

double3x3 double3x2_mulm( const double3x2* lhs, const double2x3* rhs )
{
	double2 row0 = lhs->rows[0];
	double2 row1 = lhs->rows[1];
	double2 row2 = lhs->rows[2];

	double2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	double2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	double2 col2 = { rhs->rows[0].z, rhs->rows[1].z };

	return HLML_CONSTRUCT( double3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

bool double3x3_cmpe( const double3x3* lhs, const double3x3* rhs )
{
	return double3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& double3_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool double3x3_cmpne( const double3x3* lhs, const double3x3* rhs )
{
	return !( double3x3_cmpe( lhs, rhs ) );
}

double3x3 double3x3_cadds( const double3x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar
	};
}

double3x3 double3x3_caddm( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		double3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		double3_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x3 double3x3_csubs( const double3x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar
	};
}

double3x3 double3x3_csubm( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		double3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		double3_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x3 double3x3_cmuls( const double3x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar
	};
}

double3x3 double3x3_cmulm( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		double3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x3 double3x3_cdivs( const double3x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar
	};
}

double3x3 double3x3_cdivm( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		double3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		double3_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 double3x3_cmpl( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		double3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 double3x3_cmple( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		double3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 double3x3_cmpg( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		double3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 double3x3_cmpge( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		double3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void double3x3_identity( double3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
	mat->rows[2] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 1.0 };
}

double3x3 double3x3_transpose( const double3x3* mat )
{
	return HLML_CONSTRUCT( double3x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

double double3x3_determinant( const double3x3* mat )
{
	return
		+ mat->rows[0].x * ( mat->rows[1].y * mat->rows[2].z - mat->rows[2].y * mat->rows[1].z ) 
		- mat->rows[0].y * ( mat->rows[1].x * mat->rows[2].z - mat->rows[2].x * mat->rows[1].z ) 
		+ mat->rows[0].z * ( mat->rows[1].x * mat->rows[2].y - mat->rows[2].x * mat->rows[1].y );
}

double3x3 double3x3_inverse( const double3x3* mat )
{
	const double invdet = 1.0 / double3x3_determinant( mat );
	return HLML_CONSTRUCT( double3x3 ) {
		 ( mat->rows[1].y * mat->rows[2].z - mat->rows[1].z * mat->rows[2].y ) * invdet,
		-( mat->rows[0].y * mat->rows[2].z - mat->rows[0].z * mat->rows[2].y ) * invdet,
		 ( mat->rows[0].y * mat->rows[1].z - mat->rows[0].z * mat->rows[1].y ) * invdet,

		-( mat->rows[1].x * mat->rows[2].z - mat->rows[1].z * mat->rows[2].x ) * invdet,
		 ( mat->rows[0].x * mat->rows[2].z - mat->rows[0].z * mat->rows[2].x ) * invdet,
		-( mat->rows[0].x * mat->rows[1].z - mat->rows[0].z * mat->rows[1].x ) * invdet,

		 ( mat->rows[1].x * mat->rows[2].y - mat->rows[1].y * mat->rows[2].x ) * invdet,
		-( mat->rows[0].x * mat->rows[2].y - mat->rows[0].y * mat->rows[2].x ) * invdet,
		 ( mat->rows[0].x * mat->rows[1].y - mat->rows[0].y * mat->rows[1].x ) * invdet
	};
}

double3x3 double3x3_mulm( const double3x3* lhs, const double3x3* rhs )
{
	double3 row0 = lhs->rows[0];
	double3 row1 = lhs->rows[1];
	double3 row2 = lhs->rows[2];

	double3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	double3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	double3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };

	return HLML_CONSTRUCT( double3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

double3 double3x3_mulv( const double3x3* lhs, const double3* rhs )
{
	return HLML_CONSTRUCT( double3 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z
	};
}

double3x3 double3x3_translate( const double3x3* mat, const double2* vec )
{
	return HLML_CONSTRUCT( double3x3 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z
	};
}

double3x3 double3x3_rotate( const double3x3* mat, const double rad )
{
	const double c = cos( rad );
	const double s = sin( rad );

	double3 row0_cos  = double3_cmuls( &mat->rows[0], c );
	double3 row0_sin  = double3_cmuls( &mat->rows[0], s );
	double3 row1_nsin = double3_cmuls( &mat->rows[1], -s );
	double3 row1_cos  = double3_cmuls( &mat->rows[1], c );

	return HLML_CONSTRUCT( double3x3 ) {
		double3_caddv( &row0_cos, &row1_nsin ),
		double3_caddv( &row0_sin, &row1_cos  ),
		mat->rows[2]
	};
}

double3x3 double3x3_scale( const double3x3* mat, const double2* vec )
{
	return HLML_CONSTRUCT( double3x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z
	};
}

bool double3x4_cmpe( const double3x4* lhs, const double3x4* rhs )
{
	return double4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& double4_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool double3x4_cmpne( const double3x4* lhs, const double3x4* rhs )
{
	return !( double3x4_cmpe( lhs, rhs ) );
}

double3x4 double3x4_cadds( const double3x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar
	};
}

double3x4 double3x4_caddm( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		double4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		double4_caddv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x4 double3x4_csubs( const double3x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar
	};
}

double3x4 double3x4_csubm( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		double4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		double4_csubv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x4 double3x4_cmuls( const double3x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar
	};
}

double3x4 double3x4_cmulm( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		double4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x4 double3x4_cdivs( const double3x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar
	};
}

double3x4 double3x4_cdivm( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		double4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		double4_cdivv( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 double3x4_cmpl( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		double4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 double3x4_cmple( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		double4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 double3x4_cmpg( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		double4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 double3x4_cmpge( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		double4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void double3x4_identity( double3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
	mat->rows[2] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 1.0, 0.0 };
}

double4x3 double3x4_transpose( const double3x4* mat )
{
	return HLML_CONSTRUCT( double4x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

double3x3 double3x4_mulm( const double3x4* lhs, const double4x3* rhs )
{
	double4 row0 = lhs->rows[0];
	double4 row1 = lhs->rows[1];
	double4 row2 = lhs->rows[2];

	double4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	double4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	double4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };

	return HLML_CONSTRUCT( double3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

double3x4 double3x4_translate( const double3x4* mat, const double3* vec )
{
	return HLML_CONSTRUCT( double3x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z
	};
}

double3x4 double3x4_scale( const double3x4* mat, const double2* vec )
{
	return HLML_CONSTRUCT( double3x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,
		mat->rows[2].w
	};
}

bool double4x2_cmpe( const double4x2* lhs, const double4x2* rhs )
{
	return double2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& double2_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& double2_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool double4x2_cmpne( const double4x2* lhs, const double4x2* rhs )
{
	return !( double4x2_cmpe( lhs, rhs ) );
}

double4x2 double4x2_cadds( const double4x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar
	};
}

double4x2 double4x2_caddm( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		double2_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double2_caddv( &lhs->rows[1], &rhs->rows[1] ),
		double2_caddv( &lhs->rows[2], &rhs->rows[2] ),
		double2_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x2 double4x2_csubs( const double4x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar
	};
}

double4x2 double4x2_csubm( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		double2_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double2_csubv( &lhs->rows[1], &rhs->rows[1] ),
		double2_csubv( &lhs->rows[2], &rhs->rows[2] ),
		double2_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x2 double4x2_cmuls( const double4x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar
	};
}

double4x2 double4x2_cmulm( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		double2_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		double2_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x2 double4x2_cdivs( const double4x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar
	};
}

double4x2 double4x2_cdivm( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		double2_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double2_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		double2_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		double2_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 double4x2_cmpl( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		double2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		double2_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 double4x2_cmple( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		double2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmple( &lhs->rows[2], &rhs->rows[2] ),
		double2_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 double4x2_cmpg( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		double2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		double2_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 double4x2_cmpge( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		double2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		double2_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void double4x2_identity( double4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
	mat->rows[2] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
	mat->rows[3] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
}

double2x4 double4x2_transpose( const double4x2* mat )
{
	return HLML_CONSTRUCT( double2x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

double4x4 double4x2_mulm( const double4x2* lhs, const double2x4* rhs )
{
	double2 row0 = lhs->rows[0];
	double2 row1 = lhs->rows[1];
	double2 row2 = lhs->rows[2];
	double2 row3 = lhs->rows[3];

	double2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	double2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	double2 col2 = { rhs->rows[0].z, rhs->rows[1].z };
	double2 col3 = { rhs->rows[0].w, rhs->rows[1].w };

	return HLML_CONSTRUCT( double4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

bool double4x3_cmpe( const double4x3* lhs, const double4x3* rhs )
{
	return double3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& double3_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& double3_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool double4x3_cmpne( const double4x3* lhs, const double4x3* rhs )
{
	return !( double4x3_cmpe( lhs, rhs ) );
}

double4x3 double4x3_cadds( const double4x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar
	};
}

double4x3 double4x3_caddm( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		double3_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double3_caddv( &lhs->rows[1], &rhs->rows[1] ),
		double3_caddv( &lhs->rows[2], &rhs->rows[2] ),
		double3_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x3 double4x3_csubs( const double4x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar
	};
}

double4x3 double4x3_csubm( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		double3_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double3_csubv( &lhs->rows[1], &rhs->rows[1] ),
		double3_csubv( &lhs->rows[2], &rhs->rows[2] ),
		double3_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x3 double4x3_cmuls( const double4x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar
	};
}

double4x3 double4x3_cmulm( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		double3_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		double3_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x3 double4x3_cdivs( const double4x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar
	};
}

double4x3 double4x3_cdivm( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		double3_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double3_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		double3_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		double3_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 double4x3_cmpl( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		double3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		double3_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 double4x3_cmple( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		double3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmple( &lhs->rows[2], &rhs->rows[2] ),
		double3_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 double4x3_cmpg( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		double3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		double3_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 double4x3_cmpge( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		double3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		double3_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void double4x3_identity( double4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
	mat->rows[2] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 1.0 };
	mat->rows[3] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 0.0 };
}

double3x4 double4x3_transpose( const double4x3* mat )
{
	return HLML_CONSTRUCT( double3x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

double4x4 double4x3_mulm( const double4x3* lhs, const double3x4* rhs )
{
	double3 row0 = lhs->rows[0];
	double3 row1 = lhs->rows[1];
	double3 row2 = lhs->rows[2];
	double3 row3 = lhs->rows[3];

	double3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	double3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	double3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };
	double3 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w };

	return HLML_CONSTRUCT( double4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

double4x3 double4x3_scale( const double4x3* mat, const double2* vec )
{
	return HLML_CONSTRUCT( double4x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z
	};
}

bool double4x4_cmpe( const double4x4* lhs, const double4x4* rhs )
{
	return double4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& double4_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& double4_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool double4x4_cmpne( const double4x4* lhs, const double4x4* rhs )
{
	return !( double4x4_cmpe( lhs, rhs ) );
}

double4x4 double4x4_cadds( const double4x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar, lhs->rows[3].w + scalar
	};
}

double4x4 double4x4_caddm( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		double4_caddv( &lhs->rows[0], &rhs->rows[0] ),
		double4_caddv( &lhs->rows[1], &rhs->rows[1] ),
		double4_caddv( &lhs->rows[2], &rhs->rows[2] ),
		double4_caddv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x4 double4x4_csubs( const double4x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar, lhs->rows[3].w - scalar
	};
}

double4x4 double4x4_csubm( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		double4_csubv( &lhs->rows[0], &rhs->rows[0] ),
		double4_csubv( &lhs->rows[1], &rhs->rows[1] ),
		double4_csubv( &lhs->rows[2], &rhs->rows[2] ),
		double4_csubv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x4 double4x4_cmuls( const double4x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar, lhs->rows[3].w * scalar
	};
}

double4x4 double4x4_cmulm( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		double4_cmulv( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmulv( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmulv( &lhs->rows[2], &rhs->rows[2] ),
		double4_cmulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x4 double4x4_cdivs( const double4x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar, lhs->rows[3].w / scalar
	};
}

double4x4 double4x4_cdivm( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		double4_cdivv( &lhs->rows[0], &rhs->rows[0] ),
		double4_cdivv( &lhs->rows[1], &rhs->rows[1] ),
		double4_cdivv( &lhs->rows[2], &rhs->rows[2] ),
		double4_cdivv( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 double4x4_cmpl( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		double4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		double4_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 double4x4_cmple( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		double4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmple( &lhs->rows[2], &rhs->rows[2] ),
		double4_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 double4x4_cmpg( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		double4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		double4_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 double4x4_cmpge( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		double4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		double4_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void double4x4_identity( double4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
	mat->rows[2] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 1.0, 0.0 };
	mat->rows[3] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 0.0, 1.0 };
}

double4x4 double4x4_transpose( const double4x4* mat )
{
	return HLML_CONSTRUCT( double4x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

double double4x4_determinant( const double4x4* mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	double sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	double sub01 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	double sub02 = mat->rows[2].y * mat->rows[3].z - mat->rows[3].y * mat->rows[2].z;
	double sub03 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	double sub04 = mat->rows[2].x * mat->rows[3].z - mat->rows[3].x * mat->rows[2].z;
	double sub05 = mat->rows[2].x * mat->rows[3].y - mat->rows[3].x * mat->rows[2].y;

	double4 cofactor = HLML_CONSTRUCT( double4 ) {
		 ( ( ( mat->rows[1].y * sub00 ) - ( mat->rows[1].z * sub01 ) ) + ( mat->rows[1].w * sub02 ) ),
		-( ( ( mat->rows[1].x * sub00 ) - ( mat->rows[1].z * sub03 ) ) + ( mat->rows[1].w * sub04 ) ),
		 ( ( ( mat->rows[1].x * sub01 ) - ( mat->rows[1].y * sub03 ) ) + ( mat->rows[1].w * sub05 ) ),
		-( ( ( mat->rows[1].x * sub02 ) - ( mat->rows[1].y * sub04 ) ) + ( mat->rows[1].z * sub05 ) ) 
	};

	return
		mat->rows[0].x * cofactor.x + mat->rows[0].y * cofactor.y +
		mat->rows[0].z * cofactor.z + mat->rows[0].w * cofactor.w; 
}

double4x4 double4x4_inverse( const double4x4* mat )
{
	// uses the glm version, which is basically just an optimised version of the adjugate formula
	double sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	double sub01 = mat->rows[1].z * mat->rows[3].w - mat->rows[1].w * mat->rows[2].w;
	double sub02 = mat->rows[1].z * mat->rows[2].w - mat->rows[1].w * mat->rows[2].z;

	double sub03 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	double sub04 = mat->rows[1].y * mat->rows[3].w - mat->rows[1].w * mat->rows[3].y;
	double sub05 = mat->rows[1].y * mat->rows[2].w - mat->rows[1].w * mat->rows[2].y;

	double sub06 = mat->rows[2].y * mat->rows[3].z - mat->rows[2].z * mat->rows[3].y;
	double sub07 = mat->rows[1].y * mat->rows[3].z - mat->rows[1].z * mat->rows[3].y;
	double sub08 = mat->rows[1].y * mat->rows[2].z - mat->rows[1].z * mat->rows[2].y;

	double sub09 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	double sub10 = mat->rows[1].x * mat->rows[3].w - mat->rows[3].x * mat->rows[1].w;
	double sub11 = mat->rows[1].x * mat->rows[2].w - mat->rows[2].x * mat->rows[1].w;

	double sub12 = mat->rows[2].x * mat->rows[3].z - mat->rows[2].z * mat->rows[3].x;
	double sub13 = mat->rows[1].x * mat->rows[3].z - mat->rows[1].z * mat->rows[3].x;
	double sub14 = mat->rows[1].x * mat->rows[2].z - mat->rows[1].z * mat->rows[2].x;

	double sub15 = mat->rows[2].x * mat->rows[3].y - mat->rows[2].y * mat->rows[3].x;
	double sub16 = mat->rows[1].x * mat->rows[3].y - mat->rows[1].y * mat->rows[3].x;
	double sub17 = mat->rows[1].x * mat->rows[2].y - mat->rows[1].y * mat->rows[2].x;

	double4 fac0 = (double4) { sub00, sub00, sub01, sub02 };
	double4 fac1 = (double4) { sub03, sub03, sub04, sub05 };
	double4 fac2 = (double4) { sub06, sub06, sub07, sub08 };
	double4 fac3 = (double4) { sub09, sub09, sub10, sub11 };
	double4 fac4 = (double4) { sub12, sub12, sub13, sub14 };
	double4 fac5 = (double4) { sub15, sub15, sub16, sub17 };

	double4 vec0 = (double4) { mat->rows[1].x, mat->rows[0].x, mat->rows[0].x, mat->rows[0].x };
	double4 vec1 = (double4) { mat->rows[1].y, mat->rows[0].y, mat->rows[0].y, mat->rows[0].y };
	double4 vec2 = (double4) { mat->rows[1].z, mat->rows[0].z, mat->rows[0].z, mat->rows[0].z };
	double4 vec3 = (double4) { mat->rows[1].w, mat->rows[0].w, mat->rows[0].w, mat->rows[0].w };

	double4 inv0mula = double4_cmulv( &vec1, &fac0 );
	double4 inv0mulb = double4_cmulv( &vec2, &fac1 );
	double4 inv0mulc = double4_cmulv( &vec3, &fac2 );
	double4 inv0     = double4_csubv( &inv0mula, &inv0mulb );
	inv0 = double4_caddv( &inv0, &inv0mulc );

	double4 inv1mula = double4_cmulv( &vec0, &fac0 );
	double4 inv1mulb = double4_cmulv( &vec2, &fac3 );
	double4 inv1mulc = double4_cmulv( &vec3, &fac4 );
	double4 inv1     = double4_csubv( &inv1mula, &inv1mulb );
	inv1 = double4_caddv( &inv1, &inv1mulc );

	double4 inv2mula = double4_cmulv( &vec0, &fac1 );
	double4 inv2mulb = double4_cmulv( &vec1, &fac3 );
	double4 inv2mulc = double4_cmulv( &vec3, &fac5 );
	double4 inv2     = double4_csubv( &inv2mula, &inv2mulb );
	inv2 = double4_caddv( &inv2, &inv2mulc );

	double4 inv3mula = double4_cmulv( &vec0, &fac2 );
	double4 inv3mulb = double4_cmulv( &vec1, &fac4 );
	double4 inv3mulc = double4_cmulv( &vec2, &fac5 );
	double4 inv3     = double4_csubv( &inv3mula, &inv3mulb );
	inv3 = double4_caddv( &inv3, &inv3mulc );


	double4 sign0 = (double4) {  1, -1,  1, -1 };
	double4 sign1 = (double4) { -1,  1, -1,  1 };

	double4x4 result = (double4x4) {
		double4_cmulv( &inv0, &sign0 ),
		double4_cmulv( &inv1, &sign1 ),
		double4_cmulv( &inv2, &sign0 ),
		double4_cmulv( &inv3, &sign1 )
	};

	double4 col0 = (double4) { result.rows[0].x, result.rows[1].x, result.rows[2].x, result.rows[3].x };
	double4 dot0 = double4_cmulv( &mat->rows[0], &col0 );

	const double dot1 = ( dot0.x + dot0.y ) + ( dot0.z + dot0.w );

	const double invdet = 1.0 / dot1;

	return double4x4_cmuls( &result, invdet );
}

double4x4 double4x4_mulm( const double4x4* lhs, const double4x4* rhs )
{
	double4 row0 = lhs->rows[0];
	double4 row1 = lhs->rows[1];
	double4 row2 = lhs->rows[2];
	double4 row3 = lhs->rows[3];

	double4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	double4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	double4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };
	double4 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w, rhs->rows[3].w };

	return HLML_CONSTRUCT( double4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

double4 double4x4_mulv( const double4x4* lhs, const double4* rhs )
{
	return HLML_CONSTRUCT( double4 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z + lhs->rows[0].w * rhs->w,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z + lhs->rows[1].w * rhs->w,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z + lhs->rows[2].w * rhs->w,
		lhs->rows[3].x * rhs->x + lhs->rows[3].y * rhs->y + lhs->rows[3].z * rhs->z + lhs->rows[3].w * rhs->w
	};
}

double4x4 double4x4_translate( const double4x4* mat, const double3* vec )
{
	return HLML_CONSTRUCT( double4x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z,
		mat->rows[3].x, mat->rows[3].y, mat->rows[3].z, mat->rows[3].w
	};
}

double4x4 double4x4_rotate( const double4x4* mat, const double rad, const double3* axis )
{
	const double c = cos( rad );
	const double s = sin( rad );

	double3 u = double3_normalized( axis );
	double ic = 1.0 - c;

	double4x4 rotation = *mat;
	rotation.rows[0].x = c + u.x * ic;
	rotation.rows[0].y = u.x * u.y * ic - u.z * s;
	rotation.rows[0].z = u.x * u.z * ic + u.y * s;

	rotation.rows[1].x = u.y * u.x * ic + u.z * s;
	rotation.rows[1].y = c + u.y * ic;
	rotation.rows[1].z = u.y * u.z * ic - u.x * s;

	rotation.rows[2].x = u.z * u.x * ic - u.y * s;
	rotation.rows[2].y = u.z * u.y * ic + u.x * s;
	rotation.rows[2].z = c + u.z * ic;

	return double4x4_mulm( mat, &rotation );
}

double4x4 double4x4_scale( const double4x4* mat, const double3* vec )
{
	return HLML_CONSTRUCT( double4x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z * vec->z,
		mat->rows[2].w,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z,
		mat->rows[3].w
	};
}

double4x4 double4x4_ortho_lh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// left-handed, clip-space range: zero to one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( double4x4 ) {
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, 1.0 / far_minus_near, -znear / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 double4x4_ortho_lh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// left-handed, clip-space range: minus-one to one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( double4x4 ) {
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, 2.0 / far_minus_near, -far_plus_near / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 double4x4_ortho_rh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// right-handed, clip-space range: zero to one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( double4x4 ) {
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, -1.0 / far_minus_near, -znear / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 double4x4_ortho_rh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// right-handed, clip-space range: minus-one to one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( double4x4 ) {
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, -2.0 / far_minus_near, -far_plus_near / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 double4x4_perspective_lh_zo( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// left-handed, clip space range: zero to one
	const double far_minus_near = zfar - znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 ) {
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, zfar / far_minus_near, -( zfar * znear ) / far_minus_near,
		0.0, 0.0, 1.0, 0.0
	};
}

double4x4 double4x4_perspective_lh_no( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// left-handed, clip space range: minus-one to one
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 ) {
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, far_plus_near / far_minus_near, -( 2.0 * zfar * znear ) / far_minus_near,
		0.0, 0.0, 1.0, 0.0
	};
}

double4x4 double4x4_perspective_rh_zo( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// right-handed, clip space range: zero to one
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 ) {
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, zfar / ( znear - zfar ), -( zfar * znear ) / ( zfar - znear ),
		0.0, 0.0, -1.0, 0.0
	};
}

double4x4 double4x4_perspective_rh_no( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// right-handed, clip space range: minus-one to one
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 ) {
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, -far_plus_near / far_minus_near, -( 2.0 * zfar * znear ) / far_minus_near,
		0.0, 0.0, -1.0, 0.0
	};
}

double4x4 double4x4_lookat_lh( const double3* eye, const double3* target, const double3* up )
{
	// left handed
	const double3 eye_to_target = double3_csubv( target, eye );
	const double3 forward = double3_normalized( &eye_to_target );
	const double3 up_cross_forward = double3_cross( up, &forward );
	const double3 right = double3_normalized( &up_cross_forward );
	const double3 up1 = double3_cross( &forward, &right );

	return HLML_CONSTRUCT( double4x4 ) {
		right.x,   right.y,   right.z,   -double3_dot( &right, eye ),
		up1.x,     up1.y,     up1.z,     -double3_dot( &up1, eye ),
		forward.x, forward.y, forward.z, -double3_dot( &forward, eye ),
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 double4x4_lookat_rh( const double3* eye, const double3* target, const double3* up )
{
	// right handed
	const double3 eye_to_target = double3_csubv( target, eye );
	const double3 forward = double3_normalized( &eye_to_target );
	const double3 forward_cross_up = double3_cross( &forward, up );
	const double3 right = double3_normalized( &forward_cross_up );
	const double3 up1 = double3_cross( &right, &forward );

	return HLML_CONSTRUCT( double4x4 ) {
		 right.x,    right.y,    right.z,   -double3_dot( &right, eye ),
		 up1.x,      up1.y,      up1.z,     -double3_dot( &up1, eye ),
		-forward.x, -forward.y, -forward.z,  double3_dot( &forward, eye ),
		0.0, 0.0, 0.0, 1.0
	};
}

#if defined( __GNUC__ ) || defined( __clang__ )
#pragma GCC diagnostic pop
#endif

#ifdef __cplusplus
}
#endif
