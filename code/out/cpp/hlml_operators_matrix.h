/*
===========================================================================

HLML.

MIT License

Copyright (c) 2019 Dan Moody

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===========================================================================
*/

// THIS FILE WAS AUTOMATICALLY GENERATED BY A TOOL.
// EDITING THIS FILE MAY CAUSE SIDE EFFECTS.
// DO SO AT YOUR OWN RISK.

#pragma once

#include "bool2x2.h"
#include "bool2x3.h"
#include "bool2x4.h"
#include "bool3x2.h"
#include "bool3x3.h"
#include "bool3x4.h"
#include "bool4x2.h"
#include "bool4x3.h"
#include "bool4x4.h"

#include "int2x2.h"
#include "int2x3.h"
#include "int2x4.h"
#include "int3x2.h"
#include "int3x3.h"
#include "int3x4.h"
#include "int4x2.h"
#include "int4x3.h"
#include "int4x4.h"

#include "uint2x2.h"
#include "uint2x3.h"
#include "uint2x4.h"
#include "uint3x2.h"
#include "uint3x3.h"
#include "uint3x4.h"
#include "uint4x2.h"
#include "uint4x3.h"
#include "uint4x4.h"

#include "float2x2.h"
#include "float2x3.h"
#include "float2x4.h"
#include "float3x2.h"
#include "float3x3.h"
#include "float3x4.h"
#include "float4x2.h"
#include "float4x3.h"
#include "float4x4.h"

#include "double2x2.h"
#include "double2x3.h"
#include "double2x4.h"
#include "double3x2.h"
#include "double3x3.h"
#include "double3x4.h"
#include "double4x2.h"
#include "double4x3.h"
#include "double4x4.h"

#include "hlml_functions_vector.h"

// bool2x2
inline bool operator==( const bool2x2& lhs, const bool2x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const bool2x2& lhs, const bool2x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}


// bool2x3
inline bool operator==( const bool2x3& lhs, const bool2x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const bool2x3& lhs, const bool2x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}


// bool2x4
inline bool operator==( const bool2x4& lhs, const bool2x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const bool2x4& lhs, const bool2x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}


// bool3x2
inline bool operator==( const bool3x2& lhs, const bool3x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const bool3x2& lhs, const bool3x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}


// bool3x3
inline bool operator==( const bool3x3& lhs, const bool3x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const bool3x3& lhs, const bool3x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}


// bool3x4
inline bool operator==( const bool3x4& lhs, const bool3x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const bool3x4& lhs, const bool3x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}


// bool4x2
inline bool operator==( const bool4x2& lhs, const bool4x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const bool4x2& lhs, const bool4x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}


// bool4x3
inline bool operator==( const bool4x3& lhs, const bool4x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const bool4x3& lhs, const bool4x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}


// bool4x4
inline bool operator==( const bool4x4& lhs, const bool4x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const bool4x4& lhs, const bool4x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}


// int2x2
inline bool operator==( const int2x2& lhs, const int2x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const int2x2& lhs, const int2x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline int2x2 operator+( const int2x2& lhs, const int32_t scalar )
{
	return int2x2(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

inline int2x2 operator+( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

inline int2x2 operator-( const int2x2& lhs, const int32_t scalar )
{
	return int2x2(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

inline int2x2 operator-( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int2x2 operator*( const int2x2& lhs, const int2x2& rhs )
{
	int2 row0 = lhs.rows[0];
	int2 row1 = lhs.rows[1];

	int2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	int2 col1 = { rhs.rows[0].y, rhs.rows[1].y };

	return HLML_CONSTRUCT( int2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

inline int2x2 operator*=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs * rhs );
}

inline int2x2 operator/( const int2x2& lhs, const int32_t scalar )
{
	return int2x2(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

inline int2x2 operator/( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2
/// \brief Returns a copy of the int2 that has been component-wise multiplied by the corresponding component of the right-hand int2x2.
inline int2 operator*( const int2x2& lhs, const int2& rhs )
{
	return HLML_CONSTRUCT( int2 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y
	};
}

/// \relates int2
/// \brief Multiplies each component of the int2 by the corresponding component of the right-hand int2x2.
inline int2 operator*=( int2& lhs, const int2x2& rhs )
{
	return ( lhs = rhs * lhs );
}

// prefix
/// \relates int2x2
/// \brief Prefix increment operator.  Adds one to each component of the given int2x2 before evaluation.
inline int2x2& operator++( int2x2& lhs )
{
	++lhs[0];
	++lhs[1];
	return lhs;
}

// postfix
/// \relates int2x2
/// \brief Postfix increment operator.  Adds one to each component of the given int2x2 after evaluation.
inline int2x2& operator++( int2x2& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	return lhs;
}

// prefix
/// \relates int2x2
/// \brief Prefix decrement operator.  Subtracts one from each component of the given int2x2 before evaluation.
inline int2x2& operator--( int2x2& lhs )
{
	--lhs[0];
	--lhs[1];
	return lhs;
}

// postfix
/// \relates int2x2
/// \brief Postfix decrement operator.  Subtracts one from each component of the given int2x2 after evaluation.
inline int2x2& operator--( int2x2& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	return lhs;
}

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise AND'd against the corresponding component of the right-hand side int2x2.
inline int2x2 operator&( int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x2
/// \brief Performs a bitwise AND on the given left-hand int2x2 against the corresponding component of the given right-hand int2x2.
inline int2x2 operator&=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise OR'd against the corresponding component of the right-hand side int2x2.
inline int2x2 operator|( int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x2
/// \brief Performs a bitwise OR on the given left-hand int2x2 against the corresponding component of the given right-hand int2x2.
inline int2x2 operator|=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise XOR'd against the corresponding component of the right-hand side int2x2.
inline int2x2 operator^( int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x2
/// \brief Performs a bitwise XOR on the given left-hand int2x2 against the corresponding component of the given right-hand int2x2.
inline int2x2 operator^=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise left-shifted by the corresponding component of the right-hand side int2x2.
inline int2x2 operator<<( int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x2
/// \brief Performs a left bitshift on the given left-hand int2x2 by the corresponding component of the given right-hand int2x2.
inline int2x2 operator<<=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise right-shifted by the corresponding component of the right-hand side int2x2.
inline int2x2 operator>>( int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x2
/// \brief Performs a right bitshift on the given left-hand int2x2 by the corresponding component of the given right-hand int2x2.
inline int2x2 operator>>=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates int2x2
/// \brief Performs a unary bitwise operation on all components of the given int2x2.
inline int2x2 operator~( int2x2& lhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] )
	};
}

inline bool2x2 operator<( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x2 operator<=( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x2 operator>( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x2 operator>=( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}


// int2x3
inline bool operator==( const int2x3& lhs, const int2x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const int2x3& lhs, const int2x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline int2x3 operator+( const int2x3& lhs, const int32_t scalar )
{
	return int2x3(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

inline int2x3 operator+( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

inline int2x3 operator-( const int2x3& lhs, const int32_t scalar )
{
	return int2x3(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

inline int2x3 operator-( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int2x2 operator*( const int2x3& lhs, const int3x2& rhs )
{
	int3 row0 = lhs.rows[0];
	int3 row1 = lhs.rows[1];

	int3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	int3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };

	return HLML_CONSTRUCT( int2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

inline int2x3 operator/( const int2x3& lhs, const int32_t scalar )
{
	return int2x3(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

inline int2x3 operator/( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

// prefix
/// \relates int2x3
/// \brief Prefix increment operator.  Adds one to each component of the given int2x3 before evaluation.
inline int2x3& operator++( int2x3& lhs )
{
	++lhs[0];
	++lhs[1];
	return lhs;
}

// postfix
/// \relates int2x3
/// \brief Postfix increment operator.  Adds one to each component of the given int2x3 after evaluation.
inline int2x3& operator++( int2x3& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	return lhs;
}

// prefix
/// \relates int2x3
/// \brief Prefix decrement operator.  Subtracts one from each component of the given int2x3 before evaluation.
inline int2x3& operator--( int2x3& lhs )
{
	--lhs[0];
	--lhs[1];
	return lhs;
}

// postfix
/// \relates int2x3
/// \brief Postfix decrement operator.  Subtracts one from each component of the given int2x3 after evaluation.
inline int2x3& operator--( int2x3& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	return lhs;
}

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise AND'd against the corresponding component of the right-hand side int2x3.
inline int2x3 operator&( int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x3
/// \brief Performs a bitwise AND on the given left-hand int2x3 against the corresponding component of the given right-hand int2x3.
inline int2x3 operator&=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise OR'd against the corresponding component of the right-hand side int2x3.
inline int2x3 operator|( int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x3
/// \brief Performs a bitwise OR on the given left-hand int2x3 against the corresponding component of the given right-hand int2x3.
inline int2x3 operator|=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise XOR'd against the corresponding component of the right-hand side int2x3.
inline int2x3 operator^( int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x3
/// \brief Performs a bitwise XOR on the given left-hand int2x3 against the corresponding component of the given right-hand int2x3.
inline int2x3 operator^=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise left-shifted by the corresponding component of the right-hand side int2x3.
inline int2x3 operator<<( int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x3
/// \brief Performs a left bitshift on the given left-hand int2x3 by the corresponding component of the given right-hand int2x3.
inline int2x3 operator<<=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise right-shifted by the corresponding component of the right-hand side int2x3.
inline int2x3 operator>>( int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x3
/// \brief Performs a right bitshift on the given left-hand int2x3 by the corresponding component of the given right-hand int2x3.
inline int2x3 operator>>=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates int2x3
/// \brief Performs a unary bitwise operation on all components of the given int2x3.
inline int2x3 operator~( int2x3& lhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] )
	};
}

inline bool2x3 operator<( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x3 operator<=( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x3 operator>( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x3 operator>=( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}


// int2x4
inline bool operator==( const int2x4& lhs, const int2x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const int2x4& lhs, const int2x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline int2x4 operator+( const int2x4& lhs, const int32_t scalar )
{
	return int2x4(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

inline int2x4 operator+( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

inline int2x4 operator-( const int2x4& lhs, const int32_t scalar )
{
	return int2x4(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

inline int2x4 operator-( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int2x2 operator*( const int2x4& lhs, const int4x2& rhs )
{
	int4 row0 = lhs.rows[0];
	int4 row1 = lhs.rows[1];

	int4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	int4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };

	return HLML_CONSTRUCT( int2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

inline int2x4 operator/( const int2x4& lhs, const int32_t scalar )
{
	return int2x4(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

inline int2x4 operator/( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

// prefix
/// \relates int2x4
/// \brief Prefix increment operator.  Adds one to each component of the given int2x4 before evaluation.
inline int2x4& operator++( int2x4& lhs )
{
	++lhs[0];
	++lhs[1];
	return lhs;
}

// postfix
/// \relates int2x4
/// \brief Postfix increment operator.  Adds one to each component of the given int2x4 after evaluation.
inline int2x4& operator++( int2x4& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	return lhs;
}

// prefix
/// \relates int2x4
/// \brief Prefix decrement operator.  Subtracts one from each component of the given int2x4 before evaluation.
inline int2x4& operator--( int2x4& lhs )
{
	--lhs[0];
	--lhs[1];
	return lhs;
}

// postfix
/// \relates int2x4
/// \brief Postfix decrement operator.  Subtracts one from each component of the given int2x4 after evaluation.
inline int2x4& operator--( int2x4& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	return lhs;
}

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise AND'd against the corresponding component of the right-hand side int2x4.
inline int2x4 operator&( int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x4
/// \brief Performs a bitwise AND on the given left-hand int2x4 against the corresponding component of the given right-hand int2x4.
inline int2x4 operator&=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise OR'd against the corresponding component of the right-hand side int2x4.
inline int2x4 operator|( int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x4
/// \brief Performs a bitwise OR on the given left-hand int2x4 against the corresponding component of the given right-hand int2x4.
inline int2x4 operator|=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise XOR'd against the corresponding component of the right-hand side int2x4.
inline int2x4 operator^( int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x4
/// \brief Performs a bitwise XOR on the given left-hand int2x4 against the corresponding component of the given right-hand int2x4.
inline int2x4 operator^=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise left-shifted by the corresponding component of the right-hand side int2x4.
inline int2x4 operator<<( int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x4
/// \brief Performs a left bitshift on the given left-hand int2x4 by the corresponding component of the given right-hand int2x4.
inline int2x4 operator<<=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise right-shifted by the corresponding component of the right-hand side int2x4.
inline int2x4 operator>>( int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates int2x4
/// \brief Performs a right bitshift on the given left-hand int2x4 by the corresponding component of the given right-hand int2x4.
inline int2x4 operator>>=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates int2x4
/// \brief Performs a unary bitwise operation on all components of the given int2x4.
inline int2x4 operator~( int2x4& lhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] )
	};
}

inline bool2x4 operator<( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x4 operator<=( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x4 operator>( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x4 operator>=( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}


// int3x2
inline bool operator==( const int3x2& lhs, const int3x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const int3x2& lhs, const int3x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline int3x2 operator+( const int3x2& lhs, const int32_t scalar )
{
	return int3x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

inline int3x2 operator+( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

inline int3x2 operator-( const int3x2& lhs, const int32_t scalar )
{
	return int3x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

inline int3x2 operator-( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int3x3 operator*( const int3x2& lhs, const int2x3& rhs )
{
	int2 row0 = lhs.rows[0];
	int2 row1 = lhs.rows[1];
	int2 row2 = lhs.rows[2];

	int2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	int2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	int2 col2 = { rhs.rows[0].z, rhs.rows[1].z };

	return HLML_CONSTRUCT( int3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

inline int3x2 operator/( const int3x2& lhs, const int32_t scalar )
{
	return int3x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

inline int3x2 operator/( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

// prefix
/// \relates int3x2
/// \brief Prefix increment operator.  Adds one to each component of the given int3x2 before evaluation.
inline int3x2& operator++( int3x2& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	return lhs;
}

// postfix
/// \relates int3x2
/// \brief Postfix increment operator.  Adds one to each component of the given int3x2 after evaluation.
inline int3x2& operator++( int3x2& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	return lhs;
}

// prefix
/// \relates int3x2
/// \brief Prefix decrement operator.  Subtracts one from each component of the given int3x2 before evaluation.
inline int3x2& operator--( int3x2& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	return lhs;
}

// postfix
/// \relates int3x2
/// \brief Postfix decrement operator.  Subtracts one from each component of the given int3x2 after evaluation.
inline int3x2& operator--( int3x2& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	return lhs;
}

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise AND'd against the corresponding component of the right-hand side int3x2.
inline int3x2 operator&( int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x2
/// \brief Performs a bitwise AND on the given left-hand int3x2 against the corresponding component of the given right-hand int3x2.
inline int3x2 operator&=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise OR'd against the corresponding component of the right-hand side int3x2.
inline int3x2 operator|( int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x2
/// \brief Performs a bitwise OR on the given left-hand int3x2 against the corresponding component of the given right-hand int3x2.
inline int3x2 operator|=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise XOR'd against the corresponding component of the right-hand side int3x2.
inline int3x2 operator^( int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x2
/// \brief Performs a bitwise XOR on the given left-hand int3x2 against the corresponding component of the given right-hand int3x2.
inline int3x2 operator^=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise left-shifted by the corresponding component of the right-hand side int3x2.
inline int3x2 operator<<( int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x2
/// \brief Performs a left bitshift on the given left-hand int3x2 by the corresponding component of the given right-hand int3x2.
inline int3x2 operator<<=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise right-shifted by the corresponding component of the right-hand side int3x2.
inline int3x2 operator>>( int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x2
/// \brief Performs a right bitshift on the given left-hand int3x2 by the corresponding component of the given right-hand int3x2.
inline int3x2 operator>>=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates int3x2
/// \brief Performs a unary bitwise operation on all components of the given int3x2.
inline int3x2 operator~( int3x2& lhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] ),
		comp_unary( lhs.rows[2] )
	};
}

inline bool3x2 operator<( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x2 operator<=( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x2 operator>( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x2 operator>=( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}


// int3x3
inline bool operator==( const int3x3& lhs, const int3x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const int3x3& lhs, const int3x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline int3x3 operator+( const int3x3& lhs, const int32_t scalar )
{
	return int3x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

inline int3x3 operator+( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

inline int3x3 operator-( const int3x3& lhs, const int32_t scalar )
{
	return int3x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

inline int3x3 operator-( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int3x3 operator*( const int3x3& lhs, const int3x3& rhs )
{
	int3 row0 = lhs.rows[0];
	int3 row1 = lhs.rows[1];
	int3 row2 = lhs.rows[2];

	int3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	int3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	int3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };

	return HLML_CONSTRUCT( int3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

inline int3x3 operator*=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs * rhs );
}

inline int3x3 operator/( const int3x3& lhs, const int32_t scalar )
{
	return int3x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

inline int3x3 operator/( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3
/// \brief Returns a copy of the int3 that has been component-wise multiplied by the corresponding component of the right-hand int3x3.
inline int3 operator*( const int3x3& lhs, const int3& rhs )
{
	return HLML_CONSTRUCT( int3 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z
	};
}

/// \relates int3
/// \brief Multiplies each component of the int3 by the corresponding component of the right-hand int3x3.
inline int3 operator*=( int3& lhs, const int3x3& rhs )
{
	return ( lhs = rhs * lhs );
}

// prefix
/// \relates int3x3
/// \brief Prefix increment operator.  Adds one to each component of the given int3x3 before evaluation.
inline int3x3& operator++( int3x3& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	return lhs;
}

// postfix
/// \relates int3x3
/// \brief Postfix increment operator.  Adds one to each component of the given int3x3 after evaluation.
inline int3x3& operator++( int3x3& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	return lhs;
}

// prefix
/// \relates int3x3
/// \brief Prefix decrement operator.  Subtracts one from each component of the given int3x3 before evaluation.
inline int3x3& operator--( int3x3& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	return lhs;
}

// postfix
/// \relates int3x3
/// \brief Postfix decrement operator.  Subtracts one from each component of the given int3x3 after evaluation.
inline int3x3& operator--( int3x3& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	return lhs;
}

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise AND'd against the corresponding component of the right-hand side int3x3.
inline int3x3 operator&( int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x3
/// \brief Performs a bitwise AND on the given left-hand int3x3 against the corresponding component of the given right-hand int3x3.
inline int3x3 operator&=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise OR'd against the corresponding component of the right-hand side int3x3.
inline int3x3 operator|( int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x3
/// \brief Performs a bitwise OR on the given left-hand int3x3 against the corresponding component of the given right-hand int3x3.
inline int3x3 operator|=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise XOR'd against the corresponding component of the right-hand side int3x3.
inline int3x3 operator^( int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x3
/// \brief Performs a bitwise XOR on the given left-hand int3x3 against the corresponding component of the given right-hand int3x3.
inline int3x3 operator^=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise left-shifted by the corresponding component of the right-hand side int3x3.
inline int3x3 operator<<( int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x3
/// \brief Performs a left bitshift on the given left-hand int3x3 by the corresponding component of the given right-hand int3x3.
inline int3x3 operator<<=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise right-shifted by the corresponding component of the right-hand side int3x3.
inline int3x3 operator>>( int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x3
/// \brief Performs a right bitshift on the given left-hand int3x3 by the corresponding component of the given right-hand int3x3.
inline int3x3 operator>>=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates int3x3
/// \brief Performs a unary bitwise operation on all components of the given int3x3.
inline int3x3 operator~( int3x3& lhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] ),
		comp_unary( lhs.rows[2] )
	};
}

inline bool3x3 operator<( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x3 operator<=( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x3 operator>( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x3 operator>=( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}


// int3x4
inline bool operator==( const int3x4& lhs, const int3x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const int3x4& lhs, const int3x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline int3x4 operator+( const int3x4& lhs, const int32_t scalar )
{
	return int3x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

inline int3x4 operator+( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

inline int3x4 operator-( const int3x4& lhs, const int32_t scalar )
{
	return int3x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

inline int3x4 operator-( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int3x3 operator*( const int3x4& lhs, const int4x3& rhs )
{
	int4 row0 = lhs.rows[0];
	int4 row1 = lhs.rows[1];
	int4 row2 = lhs.rows[2];

	int4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	int4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	int4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };

	return HLML_CONSTRUCT( int3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

inline int3x4 operator/( const int3x4& lhs, const int32_t scalar )
{
	return int3x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

inline int3x4 operator/( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

// prefix
/// \relates int3x4
/// \brief Prefix increment operator.  Adds one to each component of the given int3x4 before evaluation.
inline int3x4& operator++( int3x4& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	return lhs;
}

// postfix
/// \relates int3x4
/// \brief Postfix increment operator.  Adds one to each component of the given int3x4 after evaluation.
inline int3x4& operator++( int3x4& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	return lhs;
}

// prefix
/// \relates int3x4
/// \brief Prefix decrement operator.  Subtracts one from each component of the given int3x4 before evaluation.
inline int3x4& operator--( int3x4& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	return lhs;
}

// postfix
/// \relates int3x4
/// \brief Postfix decrement operator.  Subtracts one from each component of the given int3x4 after evaluation.
inline int3x4& operator--( int3x4& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	return lhs;
}

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise AND'd against the corresponding component of the right-hand side int3x4.
inline int3x4 operator&( int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x4
/// \brief Performs a bitwise AND on the given left-hand int3x4 against the corresponding component of the given right-hand int3x4.
inline int3x4 operator&=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise OR'd against the corresponding component of the right-hand side int3x4.
inline int3x4 operator|( int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x4
/// \brief Performs a bitwise OR on the given left-hand int3x4 against the corresponding component of the given right-hand int3x4.
inline int3x4 operator|=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise XOR'd against the corresponding component of the right-hand side int3x4.
inline int3x4 operator^( int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x4
/// \brief Performs a bitwise XOR on the given left-hand int3x4 against the corresponding component of the given right-hand int3x4.
inline int3x4 operator^=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise left-shifted by the corresponding component of the right-hand side int3x4.
inline int3x4 operator<<( int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x4
/// \brief Performs a left bitshift on the given left-hand int3x4 by the corresponding component of the given right-hand int3x4.
inline int3x4 operator<<=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise right-shifted by the corresponding component of the right-hand side int3x4.
inline int3x4 operator>>( int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates int3x4
/// \brief Performs a right bitshift on the given left-hand int3x4 by the corresponding component of the given right-hand int3x4.
inline int3x4 operator>>=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates int3x4
/// \brief Performs a unary bitwise operation on all components of the given int3x4.
inline int3x4 operator~( int3x4& lhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] ),
		comp_unary( lhs.rows[2] )
	};
}

inline bool3x4 operator<( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x4 operator<=( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x4 operator>( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x4 operator>=( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}


// int4x2
inline bool operator==( const int4x2& lhs, const int4x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const int4x2& lhs, const int4x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline int4x2 operator+( const int4x2& lhs, const int32_t scalar )
{
	return int4x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

inline int4x2 operator+( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

inline int4x2 operator-( const int4x2& lhs, const int32_t scalar )
{
	return int4x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

inline int4x2 operator-( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int4x4 operator*( const int4x2& lhs, const int2x4& rhs )
{
	int2 row0 = lhs.rows[0];
	int2 row1 = lhs.rows[1];
	int2 row2 = lhs.rows[2];
	int2 row3 = lhs.rows[3];

	int2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	int2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	int2 col2 = { rhs.rows[0].z, rhs.rows[1].z };
	int2 col3 = { rhs.rows[0].w, rhs.rows[1].w };

	return HLML_CONSTRUCT( int4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

inline int4x2 operator/( const int4x2& lhs, const int32_t scalar )
{
	return int4x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

inline int4x2 operator/( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

// prefix
/// \relates int4x2
/// \brief Prefix increment operator.  Adds one to each component of the given int4x2 before evaluation.
inline int4x2& operator++( int4x2& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	++lhs[3];
	return lhs;
}

// postfix
/// \relates int4x2
/// \brief Postfix increment operator.  Adds one to each component of the given int4x2 after evaluation.
inline int4x2& operator++( int4x2& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	lhs[3]++;
	return lhs;
}

// prefix
/// \relates int4x2
/// \brief Prefix decrement operator.  Subtracts one from each component of the given int4x2 before evaluation.
inline int4x2& operator--( int4x2& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	--lhs[3];
	return lhs;
}

// postfix
/// \relates int4x2
/// \brief Postfix decrement operator.  Subtracts one from each component of the given int4x2 after evaluation.
inline int4x2& operator--( int4x2& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	lhs[3]--;
	return lhs;
}

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise AND'd against the corresponding component of the right-hand side int4x2.
inline int4x2 operator&( int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] ),
		comp_and( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x2
/// \brief Performs a bitwise AND on the given left-hand int4x2 against the corresponding component of the given right-hand int4x2.
inline int4x2 operator&=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise OR'd against the corresponding component of the right-hand side int4x2.
inline int4x2 operator|( int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] ),
		comp_or( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x2
/// \brief Performs a bitwise OR on the given left-hand int4x2 against the corresponding component of the given right-hand int4x2.
inline int4x2 operator|=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise XOR'd against the corresponding component of the right-hand side int4x2.
inline int4x2 operator^( int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] ),
		comp_xor( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x2
/// \brief Performs a bitwise XOR on the given left-hand int4x2 against the corresponding component of the given right-hand int4x2.
inline int4x2 operator^=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise left-shifted by the corresponding component of the right-hand side int4x2.
inline int4x2 operator<<( int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] ),
		comp_shift_left( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x2
/// \brief Performs a left bitshift on the given left-hand int4x2 by the corresponding component of the given right-hand int4x2.
inline int4x2 operator<<=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise right-shifted by the corresponding component of the right-hand side int4x2.
inline int4x2 operator>>( int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] ),
		comp_shift_right( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x2
/// \brief Performs a right bitshift on the given left-hand int4x2 by the corresponding component of the given right-hand int4x2.
inline int4x2 operator>>=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates int4x2
/// \brief Performs a unary bitwise operation on all components of the given int4x2.
inline int4x2 operator~( int4x2& lhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] ),
		comp_unary( lhs.rows[2] ),
		comp_unary( lhs.rows[3] )
	};
}

inline bool4x2 operator<( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x2 operator<=( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x2 operator>( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x2 operator>=( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}


// int4x3
inline bool operator==( const int4x3& lhs, const int4x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const int4x3& lhs, const int4x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline int4x3 operator+( const int4x3& lhs, const int32_t scalar )
{
	return int4x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

inline int4x3 operator+( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

inline int4x3 operator-( const int4x3& lhs, const int32_t scalar )
{
	return int4x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

inline int4x3 operator-( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int4x4 operator*( const int4x3& lhs, const int3x4& rhs )
{
	int3 row0 = lhs.rows[0];
	int3 row1 = lhs.rows[1];
	int3 row2 = lhs.rows[2];
	int3 row3 = lhs.rows[3];

	int3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	int3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	int3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };
	int3 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w };

	return HLML_CONSTRUCT( int4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

inline int4x3 operator/( const int4x3& lhs, const int32_t scalar )
{
	return int4x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

inline int4x3 operator/( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

// prefix
/// \relates int4x3
/// \brief Prefix increment operator.  Adds one to each component of the given int4x3 before evaluation.
inline int4x3& operator++( int4x3& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	++lhs[3];
	return lhs;
}

// postfix
/// \relates int4x3
/// \brief Postfix increment operator.  Adds one to each component of the given int4x3 after evaluation.
inline int4x3& operator++( int4x3& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	lhs[3]++;
	return lhs;
}

// prefix
/// \relates int4x3
/// \brief Prefix decrement operator.  Subtracts one from each component of the given int4x3 before evaluation.
inline int4x3& operator--( int4x3& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	--lhs[3];
	return lhs;
}

// postfix
/// \relates int4x3
/// \brief Postfix decrement operator.  Subtracts one from each component of the given int4x3 after evaluation.
inline int4x3& operator--( int4x3& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	lhs[3]--;
	return lhs;
}

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise AND'd against the corresponding component of the right-hand side int4x3.
inline int4x3 operator&( int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] ),
		comp_and( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x3
/// \brief Performs a bitwise AND on the given left-hand int4x3 against the corresponding component of the given right-hand int4x3.
inline int4x3 operator&=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise OR'd against the corresponding component of the right-hand side int4x3.
inline int4x3 operator|( int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] ),
		comp_or( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x3
/// \brief Performs a bitwise OR on the given left-hand int4x3 against the corresponding component of the given right-hand int4x3.
inline int4x3 operator|=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise XOR'd against the corresponding component of the right-hand side int4x3.
inline int4x3 operator^( int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] ),
		comp_xor( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x3
/// \brief Performs a bitwise XOR on the given left-hand int4x3 against the corresponding component of the given right-hand int4x3.
inline int4x3 operator^=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise left-shifted by the corresponding component of the right-hand side int4x3.
inline int4x3 operator<<( int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] ),
		comp_shift_left( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x3
/// \brief Performs a left bitshift on the given left-hand int4x3 by the corresponding component of the given right-hand int4x3.
inline int4x3 operator<<=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise right-shifted by the corresponding component of the right-hand side int4x3.
inline int4x3 operator>>( int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] ),
		comp_shift_right( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x3
/// \brief Performs a right bitshift on the given left-hand int4x3 by the corresponding component of the given right-hand int4x3.
inline int4x3 operator>>=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates int4x3
/// \brief Performs a unary bitwise operation on all components of the given int4x3.
inline int4x3 operator~( int4x3& lhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] ),
		comp_unary( lhs.rows[2] ),
		comp_unary( lhs.rows[3] )
	};
}

inline bool4x3 operator<( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x3 operator<=( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x3 operator>( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x3 operator>=( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}


// int4x4
inline bool operator==( const int4x4& lhs, const int4x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const int4x4& lhs, const int4x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline int4x4 operator+( const int4x4& lhs, const int32_t scalar )
{
	return int4x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

inline int4x4 operator+( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

inline int4x4 operator-( const int4x4& lhs, const int32_t scalar )
{
	return int4x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

inline int4x4 operator-( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int4x4 operator*( const int4x4& lhs, const int4x4& rhs )
{
	int4 row0 = lhs.rows[0];
	int4 row1 = lhs.rows[1];
	int4 row2 = lhs.rows[2];
	int4 row3 = lhs.rows[3];

	int4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	int4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	int4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };
	int4 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w, rhs.rows[3].w };

	return HLML_CONSTRUCT( int4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

inline int4x4 operator*=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs * rhs );
}

inline int4x4 operator/( const int4x4& lhs, const int32_t scalar )
{
	return int4x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

inline int4x4 operator/( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4
/// \brief Returns a copy of the int4 that has been component-wise multiplied by the corresponding component of the right-hand int4x4.
inline int4 operator*( const int4x4& lhs, const int4& rhs )
{
	return HLML_CONSTRUCT( int4 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z + lhs.rows[0].w * rhs.w,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z + lhs.rows[1].w * rhs.w,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z + lhs.rows[2].w * rhs.w,
		lhs.rows[3].x * rhs.x + lhs.rows[3].y * rhs.y + lhs.rows[3].z * rhs.z + lhs.rows[3].w * rhs.w
	};
}

/// \relates int4
/// \brief Multiplies each component of the int4 by the corresponding component of the right-hand int4x4.
inline int4 operator*=( int4& lhs, const int4x4& rhs )
{
	return ( lhs = rhs * lhs );
}

// prefix
/// \relates int4x4
/// \brief Prefix increment operator.  Adds one to each component of the given int4x4 before evaluation.
inline int4x4& operator++( int4x4& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	++lhs[3];
	return lhs;
}

// postfix
/// \relates int4x4
/// \brief Postfix increment operator.  Adds one to each component of the given int4x4 after evaluation.
inline int4x4& operator++( int4x4& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	lhs[3]++;
	return lhs;
}

// prefix
/// \relates int4x4
/// \brief Prefix decrement operator.  Subtracts one from each component of the given int4x4 before evaluation.
inline int4x4& operator--( int4x4& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	--lhs[3];
	return lhs;
}

// postfix
/// \relates int4x4
/// \brief Postfix decrement operator.  Subtracts one from each component of the given int4x4 after evaluation.
inline int4x4& operator--( int4x4& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	lhs[3]--;
	return lhs;
}

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise AND'd against the corresponding component of the right-hand side int4x4.
inline int4x4 operator&( int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] ),
		comp_and( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x4
/// \brief Performs a bitwise AND on the given left-hand int4x4 against the corresponding component of the given right-hand int4x4.
inline int4x4 operator&=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise OR'd against the corresponding component of the right-hand side int4x4.
inline int4x4 operator|( int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] ),
		comp_or( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x4
/// \brief Performs a bitwise OR on the given left-hand int4x4 against the corresponding component of the given right-hand int4x4.
inline int4x4 operator|=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise XOR'd against the corresponding component of the right-hand side int4x4.
inline int4x4 operator^( int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] ),
		comp_xor( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x4
/// \brief Performs a bitwise XOR on the given left-hand int4x4 against the corresponding component of the given right-hand int4x4.
inline int4x4 operator^=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise left-shifted by the corresponding component of the right-hand side int4x4.
inline int4x4 operator<<( int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] ),
		comp_shift_left( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x4
/// \brief Performs a left bitshift on the given left-hand int4x4 by the corresponding component of the given right-hand int4x4.
inline int4x4 operator<<=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise right-shifted by the corresponding component of the right-hand side int4x4.
inline int4x4 operator>>( int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] ),
		comp_shift_right( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates int4x4
/// \brief Performs a right bitshift on the given left-hand int4x4 by the corresponding component of the given right-hand int4x4.
inline int4x4 operator>>=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates int4x4
/// \brief Performs a unary bitwise operation on all components of the given int4x4.
inline int4x4 operator~( int4x4& lhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] ),
		comp_unary( lhs.rows[2] ),
		comp_unary( lhs.rows[3] )
	};
}

inline bool4x4 operator<( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x4 operator<=( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x4 operator>( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x4 operator>=( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}


// uint2x2
inline bool operator==( const uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const uint2x2& lhs, const uint2x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline uint2x2 operator+( const uint2x2& lhs, const uint32_t scalar )
{
	return uint2x2(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

inline uint2x2 operator+( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

inline uint2x2 operator-( const uint2x2& lhs, const uint32_t scalar )
{
	return uint2x2(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

inline uint2x2 operator-( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint2x2 operator*( const uint2x2& lhs, const uint2x2& rhs )
{
	uint2 row0 = lhs.rows[0];
	uint2 row1 = lhs.rows[1];

	uint2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	uint2 col1 = { rhs.rows[0].y, rhs.rows[1].y };

	return HLML_CONSTRUCT( uint2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

inline uint2x2 operator*=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs * rhs );
}

inline uint2x2 operator/( const uint2x2& lhs, const uint32_t scalar )
{
	return uint2x2(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

inline uint2x2 operator/( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2
/// \brief Returns a copy of the uint2 that has been component-wise multiplied by the corresponding component of the right-hand uint2x2.
inline uint2 operator*( const uint2x2& lhs, const uint2& rhs )
{
	return HLML_CONSTRUCT( uint2 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y
	};
}

/// \relates uint2
/// \brief Multiplies each component of the uint2 by the corresponding component of the right-hand uint2x2.
inline uint2 operator*=( uint2& lhs, const uint2x2& rhs )
{
	return ( lhs = rhs * lhs );
}

// prefix
/// \relates uint2x2
/// \brief Prefix increment operator.  Adds one to each component of the given uint2x2 before evaluation.
inline uint2x2& operator++( uint2x2& lhs )
{
	++lhs[0];
	++lhs[1];
	return lhs;
}

// postfix
/// \relates uint2x2
/// \brief Postfix increment operator.  Adds one to each component of the given uint2x2 after evaluation.
inline uint2x2& operator++( uint2x2& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	return lhs;
}

// prefix
/// \relates uint2x2
/// \brief Prefix decrement operator.  Subtracts one from each component of the given uint2x2 before evaluation.
inline uint2x2& operator--( uint2x2& lhs )
{
	--lhs[0];
	--lhs[1];
	return lhs;
}

// postfix
/// \relates uint2x2
/// \brief Postfix decrement operator.  Subtracts one from each component of the given uint2x2 after evaluation.
inline uint2x2& operator--( uint2x2& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	return lhs;
}

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise AND'd against the corresponding component of the right-hand side uint2x2.
inline uint2x2 operator&( uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x2
/// \brief Performs a bitwise AND on the given left-hand uint2x2 against the corresponding component of the given right-hand uint2x2.
inline uint2x2 operator&=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise OR'd against the corresponding component of the right-hand side uint2x2.
inline uint2x2 operator|( uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x2
/// \brief Performs a bitwise OR on the given left-hand uint2x2 against the corresponding component of the given right-hand uint2x2.
inline uint2x2 operator|=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise XOR'd against the corresponding component of the right-hand side uint2x2.
inline uint2x2 operator^( uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x2
/// \brief Performs a bitwise XOR on the given left-hand uint2x2 against the corresponding component of the given right-hand uint2x2.
inline uint2x2 operator^=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise left-shifted by the corresponding component of the right-hand side uint2x2.
inline uint2x2 operator<<( uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x2
/// \brief Performs a left bitshift on the given left-hand uint2x2 by the corresponding component of the given right-hand uint2x2.
inline uint2x2 operator<<=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise right-shifted by the corresponding component of the right-hand side uint2x2.
inline uint2x2 operator>>( uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x2
/// \brief Performs a right bitshift on the given left-hand uint2x2 by the corresponding component of the given right-hand uint2x2.
inline uint2x2 operator>>=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates uint2x2
/// \brief Performs a unary bitwise operation on all components of the given uint2x2.
inline uint2x2 operator~( uint2x2& lhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] )
	};
}

inline bool2x2 operator<( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x2 operator<=( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x2 operator>( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x2 operator>=( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}


// uint2x3
inline bool operator==( const uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const uint2x3& lhs, const uint2x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline uint2x3 operator+( const uint2x3& lhs, const uint32_t scalar )
{
	return uint2x3(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

inline uint2x3 operator+( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

inline uint2x3 operator-( const uint2x3& lhs, const uint32_t scalar )
{
	return uint2x3(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

inline uint2x3 operator-( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint2x2 operator*( const uint2x3& lhs, const uint3x2& rhs )
{
	uint3 row0 = lhs.rows[0];
	uint3 row1 = lhs.rows[1];

	uint3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	uint3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };

	return HLML_CONSTRUCT( uint2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

inline uint2x3 operator/( const uint2x3& lhs, const uint32_t scalar )
{
	return uint2x3(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

inline uint2x3 operator/( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

// prefix
/// \relates uint2x3
/// \brief Prefix increment operator.  Adds one to each component of the given uint2x3 before evaluation.
inline uint2x3& operator++( uint2x3& lhs )
{
	++lhs[0];
	++lhs[1];
	return lhs;
}

// postfix
/// \relates uint2x3
/// \brief Postfix increment operator.  Adds one to each component of the given uint2x3 after evaluation.
inline uint2x3& operator++( uint2x3& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	return lhs;
}

// prefix
/// \relates uint2x3
/// \brief Prefix decrement operator.  Subtracts one from each component of the given uint2x3 before evaluation.
inline uint2x3& operator--( uint2x3& lhs )
{
	--lhs[0];
	--lhs[1];
	return lhs;
}

// postfix
/// \relates uint2x3
/// \brief Postfix decrement operator.  Subtracts one from each component of the given uint2x3 after evaluation.
inline uint2x3& operator--( uint2x3& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	return lhs;
}

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise AND'd against the corresponding component of the right-hand side uint2x3.
inline uint2x3 operator&( uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x3
/// \brief Performs a bitwise AND on the given left-hand uint2x3 against the corresponding component of the given right-hand uint2x3.
inline uint2x3 operator&=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise OR'd against the corresponding component of the right-hand side uint2x3.
inline uint2x3 operator|( uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x3
/// \brief Performs a bitwise OR on the given left-hand uint2x3 against the corresponding component of the given right-hand uint2x3.
inline uint2x3 operator|=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise XOR'd against the corresponding component of the right-hand side uint2x3.
inline uint2x3 operator^( uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x3
/// \brief Performs a bitwise XOR on the given left-hand uint2x3 against the corresponding component of the given right-hand uint2x3.
inline uint2x3 operator^=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise left-shifted by the corresponding component of the right-hand side uint2x3.
inline uint2x3 operator<<( uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x3
/// \brief Performs a left bitshift on the given left-hand uint2x3 by the corresponding component of the given right-hand uint2x3.
inline uint2x3 operator<<=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise right-shifted by the corresponding component of the right-hand side uint2x3.
inline uint2x3 operator>>( uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x3
/// \brief Performs a right bitshift on the given left-hand uint2x3 by the corresponding component of the given right-hand uint2x3.
inline uint2x3 operator>>=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates uint2x3
/// \brief Performs a unary bitwise operation on all components of the given uint2x3.
inline uint2x3 operator~( uint2x3& lhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] )
	};
}

inline bool2x3 operator<( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x3 operator<=( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x3 operator>( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x3 operator>=( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}


// uint2x4
inline bool operator==( const uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const uint2x4& lhs, const uint2x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline uint2x4 operator+( const uint2x4& lhs, const uint32_t scalar )
{
	return uint2x4(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

inline uint2x4 operator+( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

inline uint2x4 operator-( const uint2x4& lhs, const uint32_t scalar )
{
	return uint2x4(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

inline uint2x4 operator-( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint2x2 operator*( const uint2x4& lhs, const uint4x2& rhs )
{
	uint4 row0 = lhs.rows[0];
	uint4 row1 = lhs.rows[1];

	uint4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	uint4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };

	return HLML_CONSTRUCT( uint2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

inline uint2x4 operator/( const uint2x4& lhs, const uint32_t scalar )
{
	return uint2x4(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

inline uint2x4 operator/( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

// prefix
/// \relates uint2x4
/// \brief Prefix increment operator.  Adds one to each component of the given uint2x4 before evaluation.
inline uint2x4& operator++( uint2x4& lhs )
{
	++lhs[0];
	++lhs[1];
	return lhs;
}

// postfix
/// \relates uint2x4
/// \brief Postfix increment operator.  Adds one to each component of the given uint2x4 after evaluation.
inline uint2x4& operator++( uint2x4& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	return lhs;
}

// prefix
/// \relates uint2x4
/// \brief Prefix decrement operator.  Subtracts one from each component of the given uint2x4 before evaluation.
inline uint2x4& operator--( uint2x4& lhs )
{
	--lhs[0];
	--lhs[1];
	return lhs;
}

// postfix
/// \relates uint2x4
/// \brief Postfix decrement operator.  Subtracts one from each component of the given uint2x4 after evaluation.
inline uint2x4& operator--( uint2x4& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	return lhs;
}

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise AND'd against the corresponding component of the right-hand side uint2x4.
inline uint2x4 operator&( uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x4
/// \brief Performs a bitwise AND on the given left-hand uint2x4 against the corresponding component of the given right-hand uint2x4.
inline uint2x4 operator&=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise OR'd against the corresponding component of the right-hand side uint2x4.
inline uint2x4 operator|( uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x4
/// \brief Performs a bitwise OR on the given left-hand uint2x4 against the corresponding component of the given right-hand uint2x4.
inline uint2x4 operator|=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise XOR'd against the corresponding component of the right-hand side uint2x4.
inline uint2x4 operator^( uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x4
/// \brief Performs a bitwise XOR on the given left-hand uint2x4 against the corresponding component of the given right-hand uint2x4.
inline uint2x4 operator^=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise left-shifted by the corresponding component of the right-hand side uint2x4.
inline uint2x4 operator<<( uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x4
/// \brief Performs a left bitshift on the given left-hand uint2x4 by the corresponding component of the given right-hand uint2x4.
inline uint2x4 operator<<=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise right-shifted by the corresponding component of the right-hand side uint2x4.
inline uint2x4 operator>>( uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates uint2x4
/// \brief Performs a right bitshift on the given left-hand uint2x4 by the corresponding component of the given right-hand uint2x4.
inline uint2x4 operator>>=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates uint2x4
/// \brief Performs a unary bitwise operation on all components of the given uint2x4.
inline uint2x4 operator~( uint2x4& lhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] )
	};
}

inline bool2x4 operator<( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x4 operator<=( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x4 operator>( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x4 operator>=( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}


// uint3x2
inline bool operator==( const uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const uint3x2& lhs, const uint3x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline uint3x2 operator+( const uint3x2& lhs, const uint32_t scalar )
{
	return uint3x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

inline uint3x2 operator+( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

inline uint3x2 operator-( const uint3x2& lhs, const uint32_t scalar )
{
	return uint3x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

inline uint3x2 operator-( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint3x3 operator*( const uint3x2& lhs, const uint2x3& rhs )
{
	uint2 row0 = lhs.rows[0];
	uint2 row1 = lhs.rows[1];
	uint2 row2 = lhs.rows[2];

	uint2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	uint2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	uint2 col2 = { rhs.rows[0].z, rhs.rows[1].z };

	return HLML_CONSTRUCT( uint3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

inline uint3x2 operator/( const uint3x2& lhs, const uint32_t scalar )
{
	return uint3x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

inline uint3x2 operator/( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

// prefix
/// \relates uint3x2
/// \brief Prefix increment operator.  Adds one to each component of the given uint3x2 before evaluation.
inline uint3x2& operator++( uint3x2& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	return lhs;
}

// postfix
/// \relates uint3x2
/// \brief Postfix increment operator.  Adds one to each component of the given uint3x2 after evaluation.
inline uint3x2& operator++( uint3x2& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	return lhs;
}

// prefix
/// \relates uint3x2
/// \brief Prefix decrement operator.  Subtracts one from each component of the given uint3x2 before evaluation.
inline uint3x2& operator--( uint3x2& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	return lhs;
}

// postfix
/// \relates uint3x2
/// \brief Postfix decrement operator.  Subtracts one from each component of the given uint3x2 after evaluation.
inline uint3x2& operator--( uint3x2& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	return lhs;
}

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise AND'd against the corresponding component of the right-hand side uint3x2.
inline uint3x2 operator&( uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x2
/// \brief Performs a bitwise AND on the given left-hand uint3x2 against the corresponding component of the given right-hand uint3x2.
inline uint3x2 operator&=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise OR'd against the corresponding component of the right-hand side uint3x2.
inline uint3x2 operator|( uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x2
/// \brief Performs a bitwise OR on the given left-hand uint3x2 against the corresponding component of the given right-hand uint3x2.
inline uint3x2 operator|=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise XOR'd against the corresponding component of the right-hand side uint3x2.
inline uint3x2 operator^( uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x2
/// \brief Performs a bitwise XOR on the given left-hand uint3x2 against the corresponding component of the given right-hand uint3x2.
inline uint3x2 operator^=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise left-shifted by the corresponding component of the right-hand side uint3x2.
inline uint3x2 operator<<( uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x2
/// \brief Performs a left bitshift on the given left-hand uint3x2 by the corresponding component of the given right-hand uint3x2.
inline uint3x2 operator<<=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise right-shifted by the corresponding component of the right-hand side uint3x2.
inline uint3x2 operator>>( uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x2
/// \brief Performs a right bitshift on the given left-hand uint3x2 by the corresponding component of the given right-hand uint3x2.
inline uint3x2 operator>>=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates uint3x2
/// \brief Performs a unary bitwise operation on all components of the given uint3x2.
inline uint3x2 operator~( uint3x2& lhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] ),
		comp_unary( lhs.rows[2] )
	};
}

inline bool3x2 operator<( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x2 operator<=( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x2 operator>( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x2 operator>=( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}


// uint3x3
inline bool operator==( const uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const uint3x3& lhs, const uint3x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline uint3x3 operator+( const uint3x3& lhs, const uint32_t scalar )
{
	return uint3x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

inline uint3x3 operator+( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

inline uint3x3 operator-( const uint3x3& lhs, const uint32_t scalar )
{
	return uint3x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

inline uint3x3 operator-( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint3x3 operator*( const uint3x3& lhs, const uint3x3& rhs )
{
	uint3 row0 = lhs.rows[0];
	uint3 row1 = lhs.rows[1];
	uint3 row2 = lhs.rows[2];

	uint3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	uint3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	uint3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };

	return HLML_CONSTRUCT( uint3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

inline uint3x3 operator*=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs * rhs );
}

inline uint3x3 operator/( const uint3x3& lhs, const uint32_t scalar )
{
	return uint3x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

inline uint3x3 operator/( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3
/// \brief Returns a copy of the uint3 that has been component-wise multiplied by the corresponding component of the right-hand uint3x3.
inline uint3 operator*( const uint3x3& lhs, const uint3& rhs )
{
	return HLML_CONSTRUCT( uint3 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z
	};
}

/// \relates uint3
/// \brief Multiplies each component of the uint3 by the corresponding component of the right-hand uint3x3.
inline uint3 operator*=( uint3& lhs, const uint3x3& rhs )
{
	return ( lhs = rhs * lhs );
}

// prefix
/// \relates uint3x3
/// \brief Prefix increment operator.  Adds one to each component of the given uint3x3 before evaluation.
inline uint3x3& operator++( uint3x3& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	return lhs;
}

// postfix
/// \relates uint3x3
/// \brief Postfix increment operator.  Adds one to each component of the given uint3x3 after evaluation.
inline uint3x3& operator++( uint3x3& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	return lhs;
}

// prefix
/// \relates uint3x3
/// \brief Prefix decrement operator.  Subtracts one from each component of the given uint3x3 before evaluation.
inline uint3x3& operator--( uint3x3& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	return lhs;
}

// postfix
/// \relates uint3x3
/// \brief Postfix decrement operator.  Subtracts one from each component of the given uint3x3 after evaluation.
inline uint3x3& operator--( uint3x3& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	return lhs;
}

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise AND'd against the corresponding component of the right-hand side uint3x3.
inline uint3x3 operator&( uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x3
/// \brief Performs a bitwise AND on the given left-hand uint3x3 against the corresponding component of the given right-hand uint3x3.
inline uint3x3 operator&=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise OR'd against the corresponding component of the right-hand side uint3x3.
inline uint3x3 operator|( uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x3
/// \brief Performs a bitwise OR on the given left-hand uint3x3 against the corresponding component of the given right-hand uint3x3.
inline uint3x3 operator|=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise XOR'd against the corresponding component of the right-hand side uint3x3.
inline uint3x3 operator^( uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x3
/// \brief Performs a bitwise XOR on the given left-hand uint3x3 against the corresponding component of the given right-hand uint3x3.
inline uint3x3 operator^=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise left-shifted by the corresponding component of the right-hand side uint3x3.
inline uint3x3 operator<<( uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x3
/// \brief Performs a left bitshift on the given left-hand uint3x3 by the corresponding component of the given right-hand uint3x3.
inline uint3x3 operator<<=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise right-shifted by the corresponding component of the right-hand side uint3x3.
inline uint3x3 operator>>( uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x3
/// \brief Performs a right bitshift on the given left-hand uint3x3 by the corresponding component of the given right-hand uint3x3.
inline uint3x3 operator>>=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates uint3x3
/// \brief Performs a unary bitwise operation on all components of the given uint3x3.
inline uint3x3 operator~( uint3x3& lhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] ),
		comp_unary( lhs.rows[2] )
	};
}

inline bool3x3 operator<( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x3 operator<=( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x3 operator>( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x3 operator>=( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}


// uint3x4
inline bool operator==( const uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const uint3x4& lhs, const uint3x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline uint3x4 operator+( const uint3x4& lhs, const uint32_t scalar )
{
	return uint3x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

inline uint3x4 operator+( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

inline uint3x4 operator-( const uint3x4& lhs, const uint32_t scalar )
{
	return uint3x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

inline uint3x4 operator-( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint3x3 operator*( const uint3x4& lhs, const uint4x3& rhs )
{
	uint4 row0 = lhs.rows[0];
	uint4 row1 = lhs.rows[1];
	uint4 row2 = lhs.rows[2];

	uint4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	uint4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	uint4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };

	return HLML_CONSTRUCT( uint3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

inline uint3x4 operator/( const uint3x4& lhs, const uint32_t scalar )
{
	return uint3x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

inline uint3x4 operator/( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

// prefix
/// \relates uint3x4
/// \brief Prefix increment operator.  Adds one to each component of the given uint3x4 before evaluation.
inline uint3x4& operator++( uint3x4& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	return lhs;
}

// postfix
/// \relates uint3x4
/// \brief Postfix increment operator.  Adds one to each component of the given uint3x4 after evaluation.
inline uint3x4& operator++( uint3x4& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	return lhs;
}

// prefix
/// \relates uint3x4
/// \brief Prefix decrement operator.  Subtracts one from each component of the given uint3x4 before evaluation.
inline uint3x4& operator--( uint3x4& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	return lhs;
}

// postfix
/// \relates uint3x4
/// \brief Postfix decrement operator.  Subtracts one from each component of the given uint3x4 after evaluation.
inline uint3x4& operator--( uint3x4& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	return lhs;
}

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise AND'd against the corresponding component of the right-hand side uint3x4.
inline uint3x4 operator&( uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x4
/// \brief Performs a bitwise AND on the given left-hand uint3x4 against the corresponding component of the given right-hand uint3x4.
inline uint3x4 operator&=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise OR'd against the corresponding component of the right-hand side uint3x4.
inline uint3x4 operator|( uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x4
/// \brief Performs a bitwise OR on the given left-hand uint3x4 against the corresponding component of the given right-hand uint3x4.
inline uint3x4 operator|=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise XOR'd against the corresponding component of the right-hand side uint3x4.
inline uint3x4 operator^( uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x4
/// \brief Performs a bitwise XOR on the given left-hand uint3x4 against the corresponding component of the given right-hand uint3x4.
inline uint3x4 operator^=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise left-shifted by the corresponding component of the right-hand side uint3x4.
inline uint3x4 operator<<( uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x4
/// \brief Performs a left bitshift on the given left-hand uint3x4 by the corresponding component of the given right-hand uint3x4.
inline uint3x4 operator<<=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise right-shifted by the corresponding component of the right-hand side uint3x4.
inline uint3x4 operator>>( uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates uint3x4
/// \brief Performs a right bitshift on the given left-hand uint3x4 by the corresponding component of the given right-hand uint3x4.
inline uint3x4 operator>>=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates uint3x4
/// \brief Performs a unary bitwise operation on all components of the given uint3x4.
inline uint3x4 operator~( uint3x4& lhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] ),
		comp_unary( lhs.rows[2] )
	};
}

inline bool3x4 operator<( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x4 operator<=( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x4 operator>( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x4 operator>=( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}


// uint4x2
inline bool operator==( const uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const uint4x2& lhs, const uint4x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline uint4x2 operator+( const uint4x2& lhs, const uint32_t scalar )
{
	return uint4x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

inline uint4x2 operator+( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

inline uint4x2 operator-( const uint4x2& lhs, const uint32_t scalar )
{
	return uint4x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

inline uint4x2 operator-( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint4x4 operator*( const uint4x2& lhs, const uint2x4& rhs )
{
	uint2 row0 = lhs.rows[0];
	uint2 row1 = lhs.rows[1];
	uint2 row2 = lhs.rows[2];
	uint2 row3 = lhs.rows[3];

	uint2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	uint2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	uint2 col2 = { rhs.rows[0].z, rhs.rows[1].z };
	uint2 col3 = { rhs.rows[0].w, rhs.rows[1].w };

	return HLML_CONSTRUCT( uint4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

inline uint4x2 operator/( const uint4x2& lhs, const uint32_t scalar )
{
	return uint4x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

inline uint4x2 operator/( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

// prefix
/// \relates uint4x2
/// \brief Prefix increment operator.  Adds one to each component of the given uint4x2 before evaluation.
inline uint4x2& operator++( uint4x2& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	++lhs[3];
	return lhs;
}

// postfix
/// \relates uint4x2
/// \brief Postfix increment operator.  Adds one to each component of the given uint4x2 after evaluation.
inline uint4x2& operator++( uint4x2& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	lhs[3]++;
	return lhs;
}

// prefix
/// \relates uint4x2
/// \brief Prefix decrement operator.  Subtracts one from each component of the given uint4x2 before evaluation.
inline uint4x2& operator--( uint4x2& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	--lhs[3];
	return lhs;
}

// postfix
/// \relates uint4x2
/// \brief Postfix decrement operator.  Subtracts one from each component of the given uint4x2 after evaluation.
inline uint4x2& operator--( uint4x2& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	lhs[3]--;
	return lhs;
}

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise AND'd against the corresponding component of the right-hand side uint4x2.
inline uint4x2 operator&( uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] ),
		comp_and( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x2
/// \brief Performs a bitwise AND on the given left-hand uint4x2 against the corresponding component of the given right-hand uint4x2.
inline uint4x2 operator&=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise OR'd against the corresponding component of the right-hand side uint4x2.
inline uint4x2 operator|( uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] ),
		comp_or( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x2
/// \brief Performs a bitwise OR on the given left-hand uint4x2 against the corresponding component of the given right-hand uint4x2.
inline uint4x2 operator|=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise XOR'd against the corresponding component of the right-hand side uint4x2.
inline uint4x2 operator^( uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] ),
		comp_xor( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x2
/// \brief Performs a bitwise XOR on the given left-hand uint4x2 against the corresponding component of the given right-hand uint4x2.
inline uint4x2 operator^=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise left-shifted by the corresponding component of the right-hand side uint4x2.
inline uint4x2 operator<<( uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] ),
		comp_shift_left( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x2
/// \brief Performs a left bitshift on the given left-hand uint4x2 by the corresponding component of the given right-hand uint4x2.
inline uint4x2 operator<<=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise right-shifted by the corresponding component of the right-hand side uint4x2.
inline uint4x2 operator>>( uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] ),
		comp_shift_right( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x2
/// \brief Performs a right bitshift on the given left-hand uint4x2 by the corresponding component of the given right-hand uint4x2.
inline uint4x2 operator>>=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates uint4x2
/// \brief Performs a unary bitwise operation on all components of the given uint4x2.
inline uint4x2 operator~( uint4x2& lhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] ),
		comp_unary( lhs.rows[2] ),
		comp_unary( lhs.rows[3] )
	};
}

inline bool4x2 operator<( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x2 operator<=( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x2 operator>( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x2 operator>=( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}


// uint4x3
inline bool operator==( const uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const uint4x3& lhs, const uint4x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline uint4x3 operator+( const uint4x3& lhs, const uint32_t scalar )
{
	return uint4x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

inline uint4x3 operator+( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

inline uint4x3 operator-( const uint4x3& lhs, const uint32_t scalar )
{
	return uint4x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

inline uint4x3 operator-( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint4x4 operator*( const uint4x3& lhs, const uint3x4& rhs )
{
	uint3 row0 = lhs.rows[0];
	uint3 row1 = lhs.rows[1];
	uint3 row2 = lhs.rows[2];
	uint3 row3 = lhs.rows[3];

	uint3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	uint3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	uint3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };
	uint3 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w };

	return HLML_CONSTRUCT( uint4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

inline uint4x3 operator/( const uint4x3& lhs, const uint32_t scalar )
{
	return uint4x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

inline uint4x3 operator/( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

// prefix
/// \relates uint4x3
/// \brief Prefix increment operator.  Adds one to each component of the given uint4x3 before evaluation.
inline uint4x3& operator++( uint4x3& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	++lhs[3];
	return lhs;
}

// postfix
/// \relates uint4x3
/// \brief Postfix increment operator.  Adds one to each component of the given uint4x3 after evaluation.
inline uint4x3& operator++( uint4x3& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	lhs[3]++;
	return lhs;
}

// prefix
/// \relates uint4x3
/// \brief Prefix decrement operator.  Subtracts one from each component of the given uint4x3 before evaluation.
inline uint4x3& operator--( uint4x3& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	--lhs[3];
	return lhs;
}

// postfix
/// \relates uint4x3
/// \brief Postfix decrement operator.  Subtracts one from each component of the given uint4x3 after evaluation.
inline uint4x3& operator--( uint4x3& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	lhs[3]--;
	return lhs;
}

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise AND'd against the corresponding component of the right-hand side uint4x3.
inline uint4x3 operator&( uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] ),
		comp_and( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x3
/// \brief Performs a bitwise AND on the given left-hand uint4x3 against the corresponding component of the given right-hand uint4x3.
inline uint4x3 operator&=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise OR'd against the corresponding component of the right-hand side uint4x3.
inline uint4x3 operator|( uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] ),
		comp_or( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x3
/// \brief Performs a bitwise OR on the given left-hand uint4x3 against the corresponding component of the given right-hand uint4x3.
inline uint4x3 operator|=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise XOR'd against the corresponding component of the right-hand side uint4x3.
inline uint4x3 operator^( uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] ),
		comp_xor( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x3
/// \brief Performs a bitwise XOR on the given left-hand uint4x3 against the corresponding component of the given right-hand uint4x3.
inline uint4x3 operator^=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise left-shifted by the corresponding component of the right-hand side uint4x3.
inline uint4x3 operator<<( uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] ),
		comp_shift_left( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x3
/// \brief Performs a left bitshift on the given left-hand uint4x3 by the corresponding component of the given right-hand uint4x3.
inline uint4x3 operator<<=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise right-shifted by the corresponding component of the right-hand side uint4x3.
inline uint4x3 operator>>( uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] ),
		comp_shift_right( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x3
/// \brief Performs a right bitshift on the given left-hand uint4x3 by the corresponding component of the given right-hand uint4x3.
inline uint4x3 operator>>=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates uint4x3
/// \brief Performs a unary bitwise operation on all components of the given uint4x3.
inline uint4x3 operator~( uint4x3& lhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] ),
		comp_unary( lhs.rows[2] ),
		comp_unary( lhs.rows[3] )
	};
}

inline bool4x3 operator<( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x3 operator<=( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x3 operator>( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x3 operator>=( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}


// uint4x4
inline bool operator==( const uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const uint4x4& lhs, const uint4x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline uint4x4 operator+( const uint4x4& lhs, const uint32_t scalar )
{
	return uint4x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

inline uint4x4 operator+( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

inline uint4x4 operator-( const uint4x4& lhs, const uint32_t scalar )
{
	return uint4x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

inline uint4x4 operator-( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint4x4 operator*( const uint4x4& lhs, const uint4x4& rhs )
{
	uint4 row0 = lhs.rows[0];
	uint4 row1 = lhs.rows[1];
	uint4 row2 = lhs.rows[2];
	uint4 row3 = lhs.rows[3];

	uint4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	uint4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	uint4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };
	uint4 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w, rhs.rows[3].w };

	return HLML_CONSTRUCT( uint4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

inline uint4x4 operator*=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs * rhs );
}

inline uint4x4 operator/( const uint4x4& lhs, const uint32_t scalar )
{
	return uint4x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

inline uint4x4 operator/( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4
/// \brief Returns a copy of the uint4 that has been component-wise multiplied by the corresponding component of the right-hand uint4x4.
inline uint4 operator*( const uint4x4& lhs, const uint4& rhs )
{
	return HLML_CONSTRUCT( uint4 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z + lhs.rows[0].w * rhs.w,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z + lhs.rows[1].w * rhs.w,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z + lhs.rows[2].w * rhs.w,
		lhs.rows[3].x * rhs.x + lhs.rows[3].y * rhs.y + lhs.rows[3].z * rhs.z + lhs.rows[3].w * rhs.w
	};
}

/// \relates uint4
/// \brief Multiplies each component of the uint4 by the corresponding component of the right-hand uint4x4.
inline uint4 operator*=( uint4& lhs, const uint4x4& rhs )
{
	return ( lhs = rhs * lhs );
}

// prefix
/// \relates uint4x4
/// \brief Prefix increment operator.  Adds one to each component of the given uint4x4 before evaluation.
inline uint4x4& operator++( uint4x4& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	++lhs[3];
	return lhs;
}

// postfix
/// \relates uint4x4
/// \brief Postfix increment operator.  Adds one to each component of the given uint4x4 after evaluation.
inline uint4x4& operator++( uint4x4& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	lhs[3]++;
	return lhs;
}

// prefix
/// \relates uint4x4
/// \brief Prefix decrement operator.  Subtracts one from each component of the given uint4x4 before evaluation.
inline uint4x4& operator--( uint4x4& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	--lhs[3];
	return lhs;
}

// postfix
/// \relates uint4x4
/// \brief Postfix decrement operator.  Subtracts one from each component of the given uint4x4 after evaluation.
inline uint4x4& operator--( uint4x4& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	lhs[3]--;
	return lhs;
}

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise AND'd against the corresponding component of the right-hand side uint4x4.
inline uint4x4 operator&( uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] ),
		comp_and( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x4
/// \brief Performs a bitwise AND on the given left-hand uint4x4 against the corresponding component of the given right-hand uint4x4.
inline uint4x4 operator&=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs & rhs );
}

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise OR'd against the corresponding component of the right-hand side uint4x4.
inline uint4x4 operator|( uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] ),
		comp_or( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x4
/// \brief Performs a bitwise OR on the given left-hand uint4x4 against the corresponding component of the given right-hand uint4x4.
inline uint4x4 operator|=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs | rhs );
}

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise XOR'd against the corresponding component of the right-hand side uint4x4.
inline uint4x4 operator^( uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] ),
		comp_xor( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x4
/// \brief Performs a bitwise XOR on the given left-hand uint4x4 against the corresponding component of the given right-hand uint4x4.
inline uint4x4 operator^=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise left-shifted by the corresponding component of the right-hand side uint4x4.
inline uint4x4 operator<<( uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] ),
		comp_shift_left( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x4
/// \brief Performs a left bitshift on the given left-hand uint4x4 by the corresponding component of the given right-hand uint4x4.
inline uint4x4 operator<<=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs << rhs );
}

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise right-shifted by the corresponding component of the right-hand side uint4x4.
inline uint4x4 operator>>( uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] ),
		comp_shift_right( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates uint4x4
/// \brief Performs a right bitshift on the given left-hand uint4x4 by the corresponding component of the given right-hand uint4x4.
inline uint4x4 operator>>=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs >> rhs );
}

/// \relates uint4x4
/// \brief Performs a unary bitwise operation on all components of the given uint4x4.
inline uint4x4 operator~( uint4x4& lhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_unary( lhs.rows[0] ),
		comp_unary( lhs.rows[1] ),
		comp_unary( lhs.rows[2] ),
		comp_unary( lhs.rows[3] )
	};
}

inline bool4x4 operator<( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x4 operator<=( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x4 operator>( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x4 operator>=( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}


// float2x2
inline bool operator==( const float2x2& lhs, const float2x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const float2x2& lhs, const float2x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline float2x2 operator+( const float2x2& lhs, const float scalar )
{
	return float2x2(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

inline float2x2 operator+( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

inline float2x2 operator-( const float2x2& lhs, const float scalar )
{
	return float2x2(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

inline float2x2 operator-( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates float2x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float2x2 operator*( const float2x2& lhs, const float2x2& rhs )
{
	float2 row0 = lhs.rows[0];
	float2 row1 = lhs.rows[1];

	float2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	float2 col1 = { rhs.rows[0].y, rhs.rows[1].y };

	return HLML_CONSTRUCT( float2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

inline float2x2 operator*=( float2x2& lhs, const float2x2& rhs )
{
	return ( lhs = lhs * rhs );
}

/// \relates float2x2
/// \brief Returns a copy of the matrix where the left-hand matrix has been mathematically multiplied by the inverse of the right-hand matrix.
inline float2x2 operator/( const float2x2& lhs, const float2x2& rhs )
{
	return lhs * inverse( rhs );
}

/// \relates float2x2
/// \brief Multiplies the left-hand matrix by the right-hand matrix (dot product row/col style).
inline float2x2 operator/=( float2x2& lhs, const float2x2& rhs )
{
	return ( lhs = lhs / rhs );
}

/// \relates float2
/// \brief Returns a copy of the float2 that has been component-wise multiplied by the corresponding component of the right-hand float2x2.
inline float2 operator*( const float2x2& lhs, const float2& rhs )
{
	return HLML_CONSTRUCT( float2 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y
	};
}

/// \relates float2
/// \brief Multiplies each component of the float2 by the corresponding component of the right-hand float2x2.
inline float2 operator*=( float2& lhs, const float2x2& rhs )
{
	return ( lhs = rhs * lhs );
}

// prefix
/// \relates float2x2
/// \brief Prefix increment operator.  Adds one to each component of the given float2x2 before evaluation.
inline float2x2& operator++( float2x2& lhs )
{
	++lhs[0];
	++lhs[1];
	return lhs;
}

// postfix
/// \relates float2x2
/// \brief Postfix increment operator.  Adds one to each component of the given float2x2 after evaluation.
inline float2x2& operator++( float2x2& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	return lhs;
}

// prefix
/// \relates float2x2
/// \brief Prefix decrement operator.  Subtracts one from each component of the given float2x2 before evaluation.
inline float2x2& operator--( float2x2& lhs )
{
	--lhs[0];
	--lhs[1];
	return lhs;
}

// postfix
/// \relates float2x2
/// \brief Postfix decrement operator.  Subtracts one from each component of the given float2x2 after evaluation.
inline float2x2& operator--( float2x2& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	return lhs;
}

inline bool2x2 operator<( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x2 operator<=( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x2 operator>( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x2 operator>=( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}


// float2x3
inline bool operator==( const float2x3& lhs, const float2x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const float2x3& lhs, const float2x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline float2x3 operator+( const float2x3& lhs, const float scalar )
{
	return float2x3(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

inline float2x3 operator+( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

inline float2x3 operator-( const float2x3& lhs, const float scalar )
{
	return float2x3(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

inline float2x3 operator-( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates float2x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float2x2 operator*( const float2x3& lhs, const float3x2& rhs )
{
	float3 row0 = lhs.rows[0];
	float3 row1 = lhs.rows[1];

	float3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	float3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };

	return HLML_CONSTRUCT( float2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

inline float2x3 operator/( const float2x3& lhs, const float scalar )
{
	return float2x3(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

inline float2x3 operator/( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

// prefix
/// \relates float2x3
/// \brief Prefix increment operator.  Adds one to each component of the given float2x3 before evaluation.
inline float2x3& operator++( float2x3& lhs )
{
	++lhs[0];
	++lhs[1];
	return lhs;
}

// postfix
/// \relates float2x3
/// \brief Postfix increment operator.  Adds one to each component of the given float2x3 after evaluation.
inline float2x3& operator++( float2x3& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	return lhs;
}

// prefix
/// \relates float2x3
/// \brief Prefix decrement operator.  Subtracts one from each component of the given float2x3 before evaluation.
inline float2x3& operator--( float2x3& lhs )
{
	--lhs[0];
	--lhs[1];
	return lhs;
}

// postfix
/// \relates float2x3
/// \brief Postfix decrement operator.  Subtracts one from each component of the given float2x3 after evaluation.
inline float2x3& operator--( float2x3& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	return lhs;
}

inline bool2x3 operator<( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x3 operator<=( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x3 operator>( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x3 operator>=( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}


// float2x4
inline bool operator==( const float2x4& lhs, const float2x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const float2x4& lhs, const float2x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline float2x4 operator+( const float2x4& lhs, const float scalar )
{
	return float2x4(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

inline float2x4 operator+( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

inline float2x4 operator-( const float2x4& lhs, const float scalar )
{
	return float2x4(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

inline float2x4 operator-( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates float2x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float2x2 operator*( const float2x4& lhs, const float4x2& rhs )
{
	float4 row0 = lhs.rows[0];
	float4 row1 = lhs.rows[1];

	float4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	float4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };

	return HLML_CONSTRUCT( float2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

inline float2x4 operator/( const float2x4& lhs, const float scalar )
{
	return float2x4(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

inline float2x4 operator/( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

// prefix
/// \relates float2x4
/// \brief Prefix increment operator.  Adds one to each component of the given float2x4 before evaluation.
inline float2x4& operator++( float2x4& lhs )
{
	++lhs[0];
	++lhs[1];
	return lhs;
}

// postfix
/// \relates float2x4
/// \brief Postfix increment operator.  Adds one to each component of the given float2x4 after evaluation.
inline float2x4& operator++( float2x4& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	return lhs;
}

// prefix
/// \relates float2x4
/// \brief Prefix decrement operator.  Subtracts one from each component of the given float2x4 before evaluation.
inline float2x4& operator--( float2x4& lhs )
{
	--lhs[0];
	--lhs[1];
	return lhs;
}

// postfix
/// \relates float2x4
/// \brief Postfix decrement operator.  Subtracts one from each component of the given float2x4 after evaluation.
inline float2x4& operator--( float2x4& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	return lhs;
}

inline bool2x4 operator<( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x4 operator<=( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x4 operator>( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x4 operator>=( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}


// float3x2
inline bool operator==( const float3x2& lhs, const float3x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const float3x2& lhs, const float3x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline float3x2 operator+( const float3x2& lhs, const float scalar )
{
	return float3x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

inline float3x2 operator+( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

inline float3x2 operator-( const float3x2& lhs, const float scalar )
{
	return float3x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

inline float3x2 operator-( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates float3x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float3x3 operator*( const float3x2& lhs, const float2x3& rhs )
{
	float2 row0 = lhs.rows[0];
	float2 row1 = lhs.rows[1];
	float2 row2 = lhs.rows[2];

	float2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	float2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	float2 col2 = { rhs.rows[0].z, rhs.rows[1].z };

	return HLML_CONSTRUCT( float3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

inline float3x2 operator/( const float3x2& lhs, const float scalar )
{
	return float3x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

inline float3x2 operator/( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

// prefix
/// \relates float3x2
/// \brief Prefix increment operator.  Adds one to each component of the given float3x2 before evaluation.
inline float3x2& operator++( float3x2& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	return lhs;
}

// postfix
/// \relates float3x2
/// \brief Postfix increment operator.  Adds one to each component of the given float3x2 after evaluation.
inline float3x2& operator++( float3x2& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	return lhs;
}

// prefix
/// \relates float3x2
/// \brief Prefix decrement operator.  Subtracts one from each component of the given float3x2 before evaluation.
inline float3x2& operator--( float3x2& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	return lhs;
}

// postfix
/// \relates float3x2
/// \brief Postfix decrement operator.  Subtracts one from each component of the given float3x2 after evaluation.
inline float3x2& operator--( float3x2& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	return lhs;
}

inline bool3x2 operator<( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x2 operator<=( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x2 operator>( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x2 operator>=( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}


// float3x3
inline bool operator==( const float3x3& lhs, const float3x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const float3x3& lhs, const float3x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline float3x3 operator+( const float3x3& lhs, const float scalar )
{
	return float3x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

inline float3x3 operator+( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

inline float3x3 operator-( const float3x3& lhs, const float scalar )
{
	return float3x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

inline float3x3 operator-( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates float3x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float3x3 operator*( const float3x3& lhs, const float3x3& rhs )
{
	float3 row0 = lhs.rows[0];
	float3 row1 = lhs.rows[1];
	float3 row2 = lhs.rows[2];

	float3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	float3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	float3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };

	return HLML_CONSTRUCT( float3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

inline float3x3 operator*=( float3x3& lhs, const float3x3& rhs )
{
	return ( lhs = lhs * rhs );
}

/// \relates float3x3
/// \brief Returns a copy of the matrix where the left-hand matrix has been mathematically multiplied by the inverse of the right-hand matrix.
inline float3x3 operator/( const float3x3& lhs, const float3x3& rhs )
{
	return lhs * inverse( rhs );
}

/// \relates float3x3
/// \brief Multiplies the left-hand matrix by the right-hand matrix (dot product row/col style).
inline float3x3 operator/=( float3x3& lhs, const float3x3& rhs )
{
	return ( lhs = lhs / rhs );
}

/// \relates float3
/// \brief Returns a copy of the float3 that has been component-wise multiplied by the corresponding component of the right-hand float3x3.
inline float3 operator*( const float3x3& lhs, const float3& rhs )
{
	return HLML_CONSTRUCT( float3 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z
	};
}

/// \relates float3
/// \brief Multiplies each component of the float3 by the corresponding component of the right-hand float3x3.
inline float3 operator*=( float3& lhs, const float3x3& rhs )
{
	return ( lhs = rhs * lhs );
}

// prefix
/// \relates float3x3
/// \brief Prefix increment operator.  Adds one to each component of the given float3x3 before evaluation.
inline float3x3& operator++( float3x3& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	return lhs;
}

// postfix
/// \relates float3x3
/// \brief Postfix increment operator.  Adds one to each component of the given float3x3 after evaluation.
inline float3x3& operator++( float3x3& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	return lhs;
}

// prefix
/// \relates float3x3
/// \brief Prefix decrement operator.  Subtracts one from each component of the given float3x3 before evaluation.
inline float3x3& operator--( float3x3& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	return lhs;
}

// postfix
/// \relates float3x3
/// \brief Postfix decrement operator.  Subtracts one from each component of the given float3x3 after evaluation.
inline float3x3& operator--( float3x3& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	return lhs;
}

inline bool3x3 operator<( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x3 operator<=( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x3 operator>( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x3 operator>=( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}


// float3x4
inline bool operator==( const float3x4& lhs, const float3x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const float3x4& lhs, const float3x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline float3x4 operator+( const float3x4& lhs, const float scalar )
{
	return float3x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

inline float3x4 operator+( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

inline float3x4 operator-( const float3x4& lhs, const float scalar )
{
	return float3x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

inline float3x4 operator-( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates float3x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float3x3 operator*( const float3x4& lhs, const float4x3& rhs )
{
	float4 row0 = lhs.rows[0];
	float4 row1 = lhs.rows[1];
	float4 row2 = lhs.rows[2];

	float4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	float4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	float4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };

	return HLML_CONSTRUCT( float3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

inline float3x4 operator/( const float3x4& lhs, const float scalar )
{
	return float3x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

inline float3x4 operator/( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

// prefix
/// \relates float3x4
/// \brief Prefix increment operator.  Adds one to each component of the given float3x4 before evaluation.
inline float3x4& operator++( float3x4& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	return lhs;
}

// postfix
/// \relates float3x4
/// \brief Postfix increment operator.  Adds one to each component of the given float3x4 after evaluation.
inline float3x4& operator++( float3x4& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	return lhs;
}

// prefix
/// \relates float3x4
/// \brief Prefix decrement operator.  Subtracts one from each component of the given float3x4 before evaluation.
inline float3x4& operator--( float3x4& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	return lhs;
}

// postfix
/// \relates float3x4
/// \brief Postfix decrement operator.  Subtracts one from each component of the given float3x4 after evaluation.
inline float3x4& operator--( float3x4& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	return lhs;
}

inline bool3x4 operator<( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x4 operator<=( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x4 operator>( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x4 operator>=( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}


// float4x2
inline bool operator==( const float4x2& lhs, const float4x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const float4x2& lhs, const float4x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline float4x2 operator+( const float4x2& lhs, const float scalar )
{
	return float4x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

inline float4x2 operator+( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

inline float4x2 operator-( const float4x2& lhs, const float scalar )
{
	return float4x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

inline float4x2 operator-( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates float4x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float4x4 operator*( const float4x2& lhs, const float2x4& rhs )
{
	float2 row0 = lhs.rows[0];
	float2 row1 = lhs.rows[1];
	float2 row2 = lhs.rows[2];
	float2 row3 = lhs.rows[3];

	float2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	float2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	float2 col2 = { rhs.rows[0].z, rhs.rows[1].z };
	float2 col3 = { rhs.rows[0].w, rhs.rows[1].w };

	return HLML_CONSTRUCT( float4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

inline float4x2 operator/( const float4x2& lhs, const float scalar )
{
	return float4x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

inline float4x2 operator/( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

// prefix
/// \relates float4x2
/// \brief Prefix increment operator.  Adds one to each component of the given float4x2 before evaluation.
inline float4x2& operator++( float4x2& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	++lhs[3];
	return lhs;
}

// postfix
/// \relates float4x2
/// \brief Postfix increment operator.  Adds one to each component of the given float4x2 after evaluation.
inline float4x2& operator++( float4x2& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	lhs[3]++;
	return lhs;
}

// prefix
/// \relates float4x2
/// \brief Prefix decrement operator.  Subtracts one from each component of the given float4x2 before evaluation.
inline float4x2& operator--( float4x2& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	--lhs[3];
	return lhs;
}

// postfix
/// \relates float4x2
/// \brief Postfix decrement operator.  Subtracts one from each component of the given float4x2 after evaluation.
inline float4x2& operator--( float4x2& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	lhs[3]--;
	return lhs;
}

inline bool4x2 operator<( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x2 operator<=( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x2 operator>( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x2 operator>=( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}


// float4x3
inline bool operator==( const float4x3& lhs, const float4x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const float4x3& lhs, const float4x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline float4x3 operator+( const float4x3& lhs, const float scalar )
{
	return float4x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

inline float4x3 operator+( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

inline float4x3 operator-( const float4x3& lhs, const float scalar )
{
	return float4x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

inline float4x3 operator-( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates float4x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float4x4 operator*( const float4x3& lhs, const float3x4& rhs )
{
	float3 row0 = lhs.rows[0];
	float3 row1 = lhs.rows[1];
	float3 row2 = lhs.rows[2];
	float3 row3 = lhs.rows[3];

	float3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	float3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	float3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };
	float3 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w };

	return HLML_CONSTRUCT( float4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

inline float4x3 operator/( const float4x3& lhs, const float scalar )
{
	return float4x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

inline float4x3 operator/( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

// prefix
/// \relates float4x3
/// \brief Prefix increment operator.  Adds one to each component of the given float4x3 before evaluation.
inline float4x3& operator++( float4x3& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	++lhs[3];
	return lhs;
}

// postfix
/// \relates float4x3
/// \brief Postfix increment operator.  Adds one to each component of the given float4x3 after evaluation.
inline float4x3& operator++( float4x3& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	lhs[3]++;
	return lhs;
}

// prefix
/// \relates float4x3
/// \brief Prefix decrement operator.  Subtracts one from each component of the given float4x3 before evaluation.
inline float4x3& operator--( float4x3& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	--lhs[3];
	return lhs;
}

// postfix
/// \relates float4x3
/// \brief Postfix decrement operator.  Subtracts one from each component of the given float4x3 after evaluation.
inline float4x3& operator--( float4x3& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	lhs[3]--;
	return lhs;
}

inline bool4x3 operator<( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x3 operator<=( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x3 operator>( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x3 operator>=( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}


// float4x4
inline bool operator==( const float4x4& lhs, const float4x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const float4x4& lhs, const float4x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline float4x4 operator+( const float4x4& lhs, const float scalar )
{
	return float4x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

inline float4x4 operator+( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

inline float4x4 operator-( const float4x4& lhs, const float scalar )
{
	return float4x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

inline float4x4 operator-( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates float4x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float4x4 operator*( const float4x4& lhs, const float4x4& rhs )
{
	float4 row0 = lhs.rows[0];
	float4 row1 = lhs.rows[1];
	float4 row2 = lhs.rows[2];
	float4 row3 = lhs.rows[3];

	float4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	float4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	float4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };
	float4 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w, rhs.rows[3].w };

	return HLML_CONSTRUCT( float4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

inline float4x4 operator*=( float4x4& lhs, const float4x4& rhs )
{
	return ( lhs = lhs * rhs );
}

/// \relates float4x4
/// \brief Returns a copy of the matrix where the left-hand matrix has been mathematically multiplied by the inverse of the right-hand matrix.
inline float4x4 operator/( const float4x4& lhs, const float4x4& rhs )
{
	return lhs * inverse( rhs );
}

/// \relates float4x4
/// \brief Multiplies the left-hand matrix by the right-hand matrix (dot product row/col style).
inline float4x4 operator/=( float4x4& lhs, const float4x4& rhs )
{
	return ( lhs = lhs / rhs );
}

/// \relates float4
/// \brief Returns a copy of the float4 that has been component-wise multiplied by the corresponding component of the right-hand float4x4.
inline float4 operator*( const float4x4& lhs, const float4& rhs )
{
	return HLML_CONSTRUCT( float4 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z + lhs.rows[0].w * rhs.w,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z + lhs.rows[1].w * rhs.w,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z + lhs.rows[2].w * rhs.w,
		lhs.rows[3].x * rhs.x + lhs.rows[3].y * rhs.y + lhs.rows[3].z * rhs.z + lhs.rows[3].w * rhs.w
	};
}

/// \relates float4
/// \brief Multiplies each component of the float4 by the corresponding component of the right-hand float4x4.
inline float4 operator*=( float4& lhs, const float4x4& rhs )
{
	return ( lhs = rhs * lhs );
}

// prefix
/// \relates float4x4
/// \brief Prefix increment operator.  Adds one to each component of the given float4x4 before evaluation.
inline float4x4& operator++( float4x4& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	++lhs[3];
	return lhs;
}

// postfix
/// \relates float4x4
/// \brief Postfix increment operator.  Adds one to each component of the given float4x4 after evaluation.
inline float4x4& operator++( float4x4& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	lhs[3]++;
	return lhs;
}

// prefix
/// \relates float4x4
/// \brief Prefix decrement operator.  Subtracts one from each component of the given float4x4 before evaluation.
inline float4x4& operator--( float4x4& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	--lhs[3];
	return lhs;
}

// postfix
/// \relates float4x4
/// \brief Postfix decrement operator.  Subtracts one from each component of the given float4x4 after evaluation.
inline float4x4& operator--( float4x4& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	lhs[3]--;
	return lhs;
}

inline bool4x4 operator<( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x4 operator<=( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x4 operator>( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x4 operator>=( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}


// double2x2
inline bool operator==( const double2x2& lhs, const double2x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const double2x2& lhs, const double2x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline double2x2 operator+( const double2x2& lhs, const double scalar )
{
	return double2x2(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

inline double2x2 operator+( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

inline double2x2 operator-( const double2x2& lhs, const double scalar )
{
	return double2x2(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

inline double2x2 operator-( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates double2x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double2x2 operator*( const double2x2& lhs, const double2x2& rhs )
{
	double2 row0 = lhs.rows[0];
	double2 row1 = lhs.rows[1];

	double2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	double2 col1 = { rhs.rows[0].y, rhs.rows[1].y };

	return HLML_CONSTRUCT( double2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

inline double2x2 operator*=( double2x2& lhs, const double2x2& rhs )
{
	return ( lhs = lhs * rhs );
}

/// \relates double2x2
/// \brief Returns a copy of the matrix where the left-hand matrix has been mathematically multiplied by the inverse of the right-hand matrix.
inline double2x2 operator/( const double2x2& lhs, const double2x2& rhs )
{
	return lhs * inverse( rhs );
}

/// \relates double2x2
/// \brief Multiplies the left-hand matrix by the right-hand matrix (dot product row/col style).
inline double2x2 operator/=( double2x2& lhs, const double2x2& rhs )
{
	return ( lhs = lhs / rhs );
}

/// \relates double2
/// \brief Returns a copy of the double2 that has been component-wise multiplied by the corresponding component of the right-hand double2x2.
inline double2 operator*( const double2x2& lhs, const double2& rhs )
{
	return HLML_CONSTRUCT( double2 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y
	};
}

/// \relates double2
/// \brief Multiplies each component of the double2 by the corresponding component of the right-hand double2x2.
inline double2 operator*=( double2& lhs, const double2x2& rhs )
{
	return ( lhs = rhs * lhs );
}

// prefix
/// \relates double2x2
/// \brief Prefix increment operator.  Adds one to each component of the given double2x2 before evaluation.
inline double2x2& operator++( double2x2& lhs )
{
	++lhs[0];
	++lhs[1];
	return lhs;
}

// postfix
/// \relates double2x2
/// \brief Postfix increment operator.  Adds one to each component of the given double2x2 after evaluation.
inline double2x2& operator++( double2x2& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	return lhs;
}

// prefix
/// \relates double2x2
/// \brief Prefix decrement operator.  Subtracts one from each component of the given double2x2 before evaluation.
inline double2x2& operator--( double2x2& lhs )
{
	--lhs[0];
	--lhs[1];
	return lhs;
}

// postfix
/// \relates double2x2
/// \brief Postfix decrement operator.  Subtracts one from each component of the given double2x2 after evaluation.
inline double2x2& operator--( double2x2& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	return lhs;
}

inline bool2x2 operator<( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x2 operator<=( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x2 operator>( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x2 operator>=( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}


// double2x3
inline bool operator==( const double2x3& lhs, const double2x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const double2x3& lhs, const double2x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline double2x3 operator+( const double2x3& lhs, const double scalar )
{
	return double2x3(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

inline double2x3 operator+( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

inline double2x3 operator-( const double2x3& lhs, const double scalar )
{
	return double2x3(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

inline double2x3 operator-( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates double2x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double2x2 operator*( const double2x3& lhs, const double3x2& rhs )
{
	double3 row0 = lhs.rows[0];
	double3 row1 = lhs.rows[1];

	double3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	double3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };

	return HLML_CONSTRUCT( double2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

inline double2x3 operator/( const double2x3& lhs, const double scalar )
{
	return double2x3(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

inline double2x3 operator/( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

// prefix
/// \relates double2x3
/// \brief Prefix increment operator.  Adds one to each component of the given double2x3 before evaluation.
inline double2x3& operator++( double2x3& lhs )
{
	++lhs[0];
	++lhs[1];
	return lhs;
}

// postfix
/// \relates double2x3
/// \brief Postfix increment operator.  Adds one to each component of the given double2x3 after evaluation.
inline double2x3& operator++( double2x3& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	return lhs;
}

// prefix
/// \relates double2x3
/// \brief Prefix decrement operator.  Subtracts one from each component of the given double2x3 before evaluation.
inline double2x3& operator--( double2x3& lhs )
{
	--lhs[0];
	--lhs[1];
	return lhs;
}

// postfix
/// \relates double2x3
/// \brief Postfix decrement operator.  Subtracts one from each component of the given double2x3 after evaluation.
inline double2x3& operator--( double2x3& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	return lhs;
}

inline bool2x3 operator<( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x3 operator<=( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x3 operator>( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x3 operator>=( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}


// double2x4
inline bool operator==( const double2x4& lhs, const double2x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

inline bool operator!=( const double2x4& lhs, const double2x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline double2x4 operator+( const double2x4& lhs, const double scalar )
{
	return double2x4(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

inline double2x4 operator+( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

inline double2x4 operator-( const double2x4& lhs, const double scalar )
{
	return double2x4(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

inline double2x4 operator-( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

/// \relates double2x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double2x2 operator*( const double2x4& lhs, const double4x2& rhs )
{
	double4 row0 = lhs.rows[0];
	double4 row1 = lhs.rows[1];

	double4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	double4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };

	return HLML_CONSTRUCT( double2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

inline double2x4 operator/( const double2x4& lhs, const double scalar )
{
	return double2x4(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

inline double2x4 operator/( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

// prefix
/// \relates double2x4
/// \brief Prefix increment operator.  Adds one to each component of the given double2x4 before evaluation.
inline double2x4& operator++( double2x4& lhs )
{
	++lhs[0];
	++lhs[1];
	return lhs;
}

// postfix
/// \relates double2x4
/// \brief Postfix increment operator.  Adds one to each component of the given double2x4 after evaluation.
inline double2x4& operator++( double2x4& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	return lhs;
}

// prefix
/// \relates double2x4
/// \brief Prefix decrement operator.  Subtracts one from each component of the given double2x4 before evaluation.
inline double2x4& operator--( double2x4& lhs )
{
	--lhs[0];
	--lhs[1];
	return lhs;
}

// postfix
/// \relates double2x4
/// \brief Postfix decrement operator.  Subtracts one from each component of the given double2x4 after evaluation.
inline double2x4& operator--( double2x4& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	return lhs;
}

inline bool2x4 operator<( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x4 operator<=( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x4 operator>( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

inline bool2x4 operator>=( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}


// double3x2
inline bool operator==( const double3x2& lhs, const double3x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const double3x2& lhs, const double3x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline double3x2 operator+( const double3x2& lhs, const double scalar )
{
	return double3x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

inline double3x2 operator+( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

inline double3x2 operator-( const double3x2& lhs, const double scalar )
{
	return double3x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

inline double3x2 operator-( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates double3x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double3x3 operator*( const double3x2& lhs, const double2x3& rhs )
{
	double2 row0 = lhs.rows[0];
	double2 row1 = lhs.rows[1];
	double2 row2 = lhs.rows[2];

	double2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	double2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	double2 col2 = { rhs.rows[0].z, rhs.rows[1].z };

	return HLML_CONSTRUCT( double3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

inline double3x2 operator/( const double3x2& lhs, const double scalar )
{
	return double3x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

inline double3x2 operator/( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

// prefix
/// \relates double3x2
/// \brief Prefix increment operator.  Adds one to each component of the given double3x2 before evaluation.
inline double3x2& operator++( double3x2& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	return lhs;
}

// postfix
/// \relates double3x2
/// \brief Postfix increment operator.  Adds one to each component of the given double3x2 after evaluation.
inline double3x2& operator++( double3x2& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	return lhs;
}

// prefix
/// \relates double3x2
/// \brief Prefix decrement operator.  Subtracts one from each component of the given double3x2 before evaluation.
inline double3x2& operator--( double3x2& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	return lhs;
}

// postfix
/// \relates double3x2
/// \brief Postfix decrement operator.  Subtracts one from each component of the given double3x2 after evaluation.
inline double3x2& operator--( double3x2& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	return lhs;
}

inline bool3x2 operator<( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x2 operator<=( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x2 operator>( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x2 operator>=( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}


// double3x3
inline bool operator==( const double3x3& lhs, const double3x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const double3x3& lhs, const double3x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline double3x3 operator+( const double3x3& lhs, const double scalar )
{
	return double3x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

inline double3x3 operator+( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

inline double3x3 operator-( const double3x3& lhs, const double scalar )
{
	return double3x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

inline double3x3 operator-( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates double3x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double3x3 operator*( const double3x3& lhs, const double3x3& rhs )
{
	double3 row0 = lhs.rows[0];
	double3 row1 = lhs.rows[1];
	double3 row2 = lhs.rows[2];

	double3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	double3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	double3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };

	return HLML_CONSTRUCT( double3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

inline double3x3 operator*=( double3x3& lhs, const double3x3& rhs )
{
	return ( lhs = lhs * rhs );
}

/// \relates double3x3
/// \brief Returns a copy of the matrix where the left-hand matrix has been mathematically multiplied by the inverse of the right-hand matrix.
inline double3x3 operator/( const double3x3& lhs, const double3x3& rhs )
{
	return lhs * inverse( rhs );
}

/// \relates double3x3
/// \brief Multiplies the left-hand matrix by the right-hand matrix (dot product row/col style).
inline double3x3 operator/=( double3x3& lhs, const double3x3& rhs )
{
	return ( lhs = lhs / rhs );
}

/// \relates double3
/// \brief Returns a copy of the double3 that has been component-wise multiplied by the corresponding component of the right-hand double3x3.
inline double3 operator*( const double3x3& lhs, const double3& rhs )
{
	return HLML_CONSTRUCT( double3 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z
	};
}

/// \relates double3
/// \brief Multiplies each component of the double3 by the corresponding component of the right-hand double3x3.
inline double3 operator*=( double3& lhs, const double3x3& rhs )
{
	return ( lhs = rhs * lhs );
}

// prefix
/// \relates double3x3
/// \brief Prefix increment operator.  Adds one to each component of the given double3x3 before evaluation.
inline double3x3& operator++( double3x3& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	return lhs;
}

// postfix
/// \relates double3x3
/// \brief Postfix increment operator.  Adds one to each component of the given double3x3 after evaluation.
inline double3x3& operator++( double3x3& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	return lhs;
}

// prefix
/// \relates double3x3
/// \brief Prefix decrement operator.  Subtracts one from each component of the given double3x3 before evaluation.
inline double3x3& operator--( double3x3& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	return lhs;
}

// postfix
/// \relates double3x3
/// \brief Postfix decrement operator.  Subtracts one from each component of the given double3x3 after evaluation.
inline double3x3& operator--( double3x3& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	return lhs;
}

inline bool3x3 operator<( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x3 operator<=( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x3 operator>( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x3 operator>=( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}


// double3x4
inline bool operator==( const double3x4& lhs, const double3x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

inline bool operator!=( const double3x4& lhs, const double3x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline double3x4 operator+( const double3x4& lhs, const double scalar )
{
	return double3x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

inline double3x4 operator+( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

inline double3x4 operator-( const double3x4& lhs, const double scalar )
{
	return double3x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

inline double3x4 operator-( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

/// \relates double3x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double3x3 operator*( const double3x4& lhs, const double4x3& rhs )
{
	double4 row0 = lhs.rows[0];
	double4 row1 = lhs.rows[1];
	double4 row2 = lhs.rows[2];

	double4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	double4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	double4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };

	return HLML_CONSTRUCT( double3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

inline double3x4 operator/( const double3x4& lhs, const double scalar )
{
	return double3x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

inline double3x4 operator/( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

// prefix
/// \relates double3x4
/// \brief Prefix increment operator.  Adds one to each component of the given double3x4 before evaluation.
inline double3x4& operator++( double3x4& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	return lhs;
}

// postfix
/// \relates double3x4
/// \brief Postfix increment operator.  Adds one to each component of the given double3x4 after evaluation.
inline double3x4& operator++( double3x4& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	return lhs;
}

// prefix
/// \relates double3x4
/// \brief Prefix decrement operator.  Subtracts one from each component of the given double3x4 before evaluation.
inline double3x4& operator--( double3x4& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	return lhs;
}

// postfix
/// \relates double3x4
/// \brief Postfix decrement operator.  Subtracts one from each component of the given double3x4 after evaluation.
inline double3x4& operator--( double3x4& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	return lhs;
}

inline bool3x4 operator<( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x4 operator<=( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x4 operator>( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

inline bool3x4 operator>=( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}


// double4x2
inline bool operator==( const double4x2& lhs, const double4x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const double4x2& lhs, const double4x2& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline double4x2 operator+( const double4x2& lhs, const double scalar )
{
	return double4x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

inline double4x2 operator+( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

inline double4x2 operator-( const double4x2& lhs, const double scalar )
{
	return double4x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

inline double4x2 operator-( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates double4x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double4x4 operator*( const double4x2& lhs, const double2x4& rhs )
{
	double2 row0 = lhs.rows[0];
	double2 row1 = lhs.rows[1];
	double2 row2 = lhs.rows[2];
	double2 row3 = lhs.rows[3];

	double2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	double2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	double2 col2 = { rhs.rows[0].z, rhs.rows[1].z };
	double2 col3 = { rhs.rows[0].w, rhs.rows[1].w };

	return HLML_CONSTRUCT( double4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

inline double4x2 operator/( const double4x2& lhs, const double scalar )
{
	return double4x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

inline double4x2 operator/( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

// prefix
/// \relates double4x2
/// \brief Prefix increment operator.  Adds one to each component of the given double4x2 before evaluation.
inline double4x2& operator++( double4x2& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	++lhs[3];
	return lhs;
}

// postfix
/// \relates double4x2
/// \brief Postfix increment operator.  Adds one to each component of the given double4x2 after evaluation.
inline double4x2& operator++( double4x2& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	lhs[3]++;
	return lhs;
}

// prefix
/// \relates double4x2
/// \brief Prefix decrement operator.  Subtracts one from each component of the given double4x2 before evaluation.
inline double4x2& operator--( double4x2& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	--lhs[3];
	return lhs;
}

// postfix
/// \relates double4x2
/// \brief Postfix decrement operator.  Subtracts one from each component of the given double4x2 after evaluation.
inline double4x2& operator--( double4x2& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	lhs[3]--;
	return lhs;
}

inline bool4x2 operator<( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x2 operator<=( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x2 operator>( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x2 operator>=( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}


// double4x3
inline bool operator==( const double4x3& lhs, const double4x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const double4x3& lhs, const double4x3& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline double4x3 operator+( const double4x3& lhs, const double scalar )
{
	return double4x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

inline double4x3 operator+( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

inline double4x3 operator-( const double4x3& lhs, const double scalar )
{
	return double4x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

inline double4x3 operator-( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates double4x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double4x4 operator*( const double4x3& lhs, const double3x4& rhs )
{
	double3 row0 = lhs.rows[0];
	double3 row1 = lhs.rows[1];
	double3 row2 = lhs.rows[2];
	double3 row3 = lhs.rows[3];

	double3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	double3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	double3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };
	double3 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w };

	return HLML_CONSTRUCT( double4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

inline double4x3 operator/( const double4x3& lhs, const double scalar )
{
	return double4x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

inline double4x3 operator/( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

// prefix
/// \relates double4x3
/// \brief Prefix increment operator.  Adds one to each component of the given double4x3 before evaluation.
inline double4x3& operator++( double4x3& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	++lhs[3];
	return lhs;
}

// postfix
/// \relates double4x3
/// \brief Postfix increment operator.  Adds one to each component of the given double4x3 after evaluation.
inline double4x3& operator++( double4x3& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	lhs[3]++;
	return lhs;
}

// prefix
/// \relates double4x3
/// \brief Prefix decrement operator.  Subtracts one from each component of the given double4x3 before evaluation.
inline double4x3& operator--( double4x3& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	--lhs[3];
	return lhs;
}

// postfix
/// \relates double4x3
/// \brief Postfix decrement operator.  Subtracts one from each component of the given double4x3 after evaluation.
inline double4x3& operator--( double4x3& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	lhs[3]--;
	return lhs;
}

inline bool4x3 operator<( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x3 operator<=( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x3 operator>( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x3 operator>=( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}


// double4x4
inline bool operator==( const double4x4& lhs, const double4x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

inline bool operator!=( const double4x4& lhs, const double4x4& rhs )
{
	return !( operator==( lhs, rhs ) );
}

inline double4x4 operator+( const double4x4& lhs, const double scalar )
{
	return double4x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

inline double4x4 operator+( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

inline double4x4 operator-( const double4x4& lhs, const double scalar )
{
	return double4x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

inline double4x4 operator-( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

/// \relates double4x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double4x4 operator*( const double4x4& lhs, const double4x4& rhs )
{
	double4 row0 = lhs.rows[0];
	double4 row1 = lhs.rows[1];
	double4 row2 = lhs.rows[2];
	double4 row3 = lhs.rows[3];

	double4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	double4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	double4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };
	double4 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w, rhs.rows[3].w };

	return HLML_CONSTRUCT( double4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

inline double4x4 operator*=( double4x4& lhs, const double4x4& rhs )
{
	return ( lhs = lhs * rhs );
}

/// \relates double4x4
/// \brief Returns a copy of the matrix where the left-hand matrix has been mathematically multiplied by the inverse of the right-hand matrix.
inline double4x4 operator/( const double4x4& lhs, const double4x4& rhs )
{
	return lhs * inverse( rhs );
}

/// \relates double4x4
/// \brief Multiplies the left-hand matrix by the right-hand matrix (dot product row/col style).
inline double4x4 operator/=( double4x4& lhs, const double4x4& rhs )
{
	return ( lhs = lhs / rhs );
}

/// \relates double4
/// \brief Returns a copy of the double4 that has been component-wise multiplied by the corresponding component of the right-hand double4x4.
inline double4 operator*( const double4x4& lhs, const double4& rhs )
{
	return HLML_CONSTRUCT( double4 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z + lhs.rows[0].w * rhs.w,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z + lhs.rows[1].w * rhs.w,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z + lhs.rows[2].w * rhs.w,
		lhs.rows[3].x * rhs.x + lhs.rows[3].y * rhs.y + lhs.rows[3].z * rhs.z + lhs.rows[3].w * rhs.w
	};
}

/// \relates double4
/// \brief Multiplies each component of the double4 by the corresponding component of the right-hand double4x4.
inline double4 operator*=( double4& lhs, const double4x4& rhs )
{
	return ( lhs = rhs * lhs );
}

// prefix
/// \relates double4x4
/// \brief Prefix increment operator.  Adds one to each component of the given double4x4 before evaluation.
inline double4x4& operator++( double4x4& lhs )
{
	++lhs[0];
	++lhs[1];
	++lhs[2];
	++lhs[3];
	return lhs;
}

// postfix
/// \relates double4x4
/// \brief Postfix increment operator.  Adds one to each component of the given double4x4 after evaluation.
inline double4x4& operator++( double4x4& lhs, const int )
{
	lhs[0]++;
	lhs[1]++;
	lhs[2]++;
	lhs[3]++;
	return lhs;
}

// prefix
/// \relates double4x4
/// \brief Prefix decrement operator.  Subtracts one from each component of the given double4x4 before evaluation.
inline double4x4& operator--( double4x4& lhs )
{
	--lhs[0];
	--lhs[1];
	--lhs[2];
	--lhs[3];
	return lhs;
}

// postfix
/// \relates double4x4
/// \brief Postfix decrement operator.  Subtracts one from each component of the given double4x4 after evaluation.
inline double4x4& operator--( double4x4& lhs, const int )
{
	lhs[0]--;
	lhs[1]--;
	lhs[2]--;
	lhs[3]--;
	return lhs;
}

inline bool4x4 operator<( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x4 operator<=( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x4 operator>( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

inline bool4x4 operator>=( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}


